Index: rtems-051009/make/custom/mo376.cfg
===================================================================
--- /dev/null
+++ rtems/make/custom/mo376.cfg
@@ -0,0 +1,68 @@
+#
+#  Config file for the mrm332 BSP
+#
+#  $Id: mrm332.cfg,v 1.8 2004/02/04 16:50:30 ralf Exp $
+#
+
+include $(RTEMS_ROOT)/make/custom/default.cfg
+
+RTEMS_CPU=m68k
+RTEMS_CPU_MODEL=m68332
+
+# This is the actual bsp directory used during the build process.
+RTEMS_BSP_FAMILY=mrm332
+
+#  This contains the compiler options necessary to select the CPU model
+#  and (hopefully) optimize for it. 
+CPU_CFLAGS = -mcpu32
+
+# optimize flag: typically -0, could use -O4 or -fast, -O4 is ok for RTEMS
+CFLAGS_OPTIMIZE_V=-O4 -fomit-frame-pointer
+
+# The following are definitions of make-exe which will work using ld as
+# is currently required.  It is expected that as of gcc 2.8, the end user
+# will be able to override parts of the compilers specs and link using gcc.
+
+ifeq ($(MRM_IN_ROM),yes)
+# Build a rommable image - move the .data section after the .text section
+# in the image.
+CPU_CFLAGS += -qnolinkcmds -T $(exec_prefix)/mrm332/lib/linkcmds_ROM
+
+#  This is a good way to get debug information.  The output file is large
+#  though and greatly slows the build process so only do this if needed.
+#	$(OBJDUMP) -dxC $(basename $@).nxe > $(basename $@).dump
+
+define make-exe
+	$(LINK.c) $(AM_CFLAGS) $(AM_LDFLAGS) -o $(basename $@).pxe \
+	    $(LINK_OBJS) $(LINK_LIBS)
+	$(OBJCOPY) --adjust-section-vma \
+	  .data=`m68k-rtems-objdump --section-headers $(basename $@).pxe | \
+	  awk 'function h2d(x) { x=toupper(x); digits=length(x); s=0 ; \
+	       for (p=digits; p>0; p--) \
+	       s += (16^(p-1)) * ( index("0123456789ABCDEF",\
+	        substr(x,1+digits-p,1)) -1 );\
+	        return s } ;\
+	        /\.text/ { base = $$4 ; size = $$3 };\
+	        END { printf("0x%x", h2d(base) + h2d(size)) }'\
+	       ` $(basename $@).pxe $(basename $@).nxe
+	$(OBJCOPY) -O srec $(basename $@).nxe $(basename $@).i
+	sed -e 's/.$$//' -e '/^S0/d' $(basename $@).i | \
+	    $(PACKHEX) > $(basename $@).exe
+	$(NM) -g -n $(basename $@).pxe > $(basename $@).pnum
+	$(NM) -g -n $(basename $@).nxe > $(basename $@).num
+	$(SIZE) $(basename $@).nxe
+endef
+else
+define make-exe
+	$(LINK.c) $(AM_CFLAGS) $(AM_LDFLAGS) -o $(basename $@).nxe \
+	    $(LINK_OBJS) $(LINK_LIBS)
+	$(OBJCOPY) -O srec $(basename $@).nxe $(basename $@).i
+#	m68k-rtems-objdump -dxC $(basename $@).nxe > $(basename $@).dump
+	sed -e 's/.$$//' -e '/^S0/d' $(basename $@).i | \
+	    $(PACKHEX) > $(basename $@).exe
+	$(NM) -g -n $(basename $@).nxe > $(basename $@).num
+	$(SIZE) $(basename $@).nxe
+endef
+endif
+
+# Miscellaneous additions go here
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/console/sci.h
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/console/sci.h
@@ -0,0 +1,231 @@
+/****************************************************************************
+* File:     sci.h
+*
+* Desc:     This is the include file for the serial communications interface.
+*
+* Note:     See bsp.h,confdefs.h,system.h for installing drivers into RTEMS.
+*
+* $Id: sci.h,v 1.4 2004/04/21 16:01:35 ralf Exp $
+****************************************************************************/
+
+#ifndef _sci_h_
+#define _sci_h_
+
+/*******************************************************************************
+  IOCTL commands for the sci driver.
+  I'm still working on these...
+*******************************************************************************/
+
+#define SCI_IOCTL_PARITY_NONE           0x00    // no parity bit after the data bits
+#define SCI_IOCTL_PARITY_ODD            0x01    // parity bit added after data bits
+#define SCI_IOCTL_PARITY_EVEN           0x02    // parity bit added after data bits
+#define SCI_IOCTL_PARITY_MARK           0x03    // parity bit is lo, -12 volts, logical 1
+#define SCI_IOCTL_PARITY_SPACE          0x04    // parity bit is hi, +12 volts, logical 0
+#define SCI_IOCTL_PARITY_FORCED_ON      0x03    // parity bit is forced hi or lo
+#define SCI_IOCTL_PARITY_FORCED_OFF     0x04    // parity bit is forced hi or lo
+
+#define SCI_IOCTL_BAUD_RATE             0x20    // set the baud rate, arg is baud
+
+#define SCI_IOCTL_DATA_BITS             0x30    // set the data bits, arg is # bits
+
+#define SCI_IOCTL_STOP_BITS_1           0x40    // 1 stop bit after char frame
+#define SCI_IOCTL_STOP_BITS_2           0x41    // 2 stop bit after char frame
+
+#define SCI_IOCTL_MODE_NORMAL           0x50    // normal operating mode
+#define SCI_IOCTL_MODE_LOOP             0x51    // internal loopback mode
+
+#define SCI_IOCTL_FLOW_NONE             0x60    // no flow control
+#define SCI_IOCTL_FLOW_RTS_CTS          0x61    // hardware flow control
+
+#define SCI_IOCTL_SEND_BREAK            0x70    // send an rs-232 break
+
+#define SCI_IOCTL_MODE_1200             0x80    // 1200,n,8,1 download mode
+#define SCI_IOCTL_MODE_9600             0x81    // 9600,n,8,1 download mode
+#define SCI_IOCTL_MODE_9_BIT            0x82    // 9600,forced,8,1 command mode
+
+
+/*******************************************************************************
+  SCI Registers
+*******************************************************************************/
+
+// SCI Control Register 0  (SCCR0)  $FFFC08
+
+//  8 4 2 1 - 8 4 2 1 - 8 4 2 1 - 8 4 2 1
+//  ^ ^ ^ ^   ^ ^ ^ ^   ^ ^ ^ ^   ^ ^ ^ ^
+//  | | | |   | | | |   | | | |   | | | |
+//  | | | |   | | | |   | | | |   | | | +-----   0 baud rate divisor
+//  | | | |   | | | |   | | | |   | | +-------   1 baud rate divisor
+//  | | | |   | | | |   | | | |   | +---------   2 baud rate divisor
+//  | | | |   | | | |   | | | |   +-----------   3 baud rate divisor
+//  | | | |   | | | |   | | | |
+//  | | | |   | | | |   | | | +---------------   4 baud rate divisor
+//  | | | |   | | | |   | | +-----------------   5 baud rate divisor
+//  | | | |   | | | |   | +-------------------   6 baud rate divisor
+//  | | | |   | | | |   +---------------------   7 baud rate divisor
+//  | | | |   | | | |
+//  | | | |   | | | +-------------------------   8 baud rate divisor
+//  | | | |   | | +---------------------------   9 baud rate divisor
+//  | | | |   | +-----------------------------  10 baud rate divisor
+//  | | | |   +-------------------------------  11 baud rate divisor
+//  | | | |
+//  | | | +-----------------------------------  12 baud rate divisor
+//  | | +-------------------------------------  13 unused
+//  | +---------------------------------------  14 unused
+//  +-----------------------------------------  15 unused
+
+//  0 0 0 0 - 0 0 0 0 - 0 0 0 0 - 0 1 0 0       reset value - (64k baud?)
+
+#define SCI_BAUD_57_6K            9
+#define SCI_BAUD_38_4K           14
+#define SCI_BAUD_19_2K           27
+#define SCI_BAUD_9600            55
+#define SCI_BAUD_4800           109
+#define SCI_BAUD_2400           218
+#define SCI_BAUD_1200           437
+
+
+//  SCI Control Register 1  (SCCR1)  $FFFC0A
+
+//  8 4 2 1 - 8 4 2 1 - 8 4 2 1 - 8 4 2 1
+//  ^ ^ ^ ^   ^ ^ ^ ^   ^ ^ ^ ^   ^ ^ ^ ^
+//  | | | |   | | | |   | | | |   | | | |
+//  | | | |   | | | |   | | | |   | | | +-----   0 send a break
+//  | | | |   | | | |   | | | |   | | +-------   1 rcvr wakeup mode
+//  | | | |   | | | |   | | | |   | +---------   2 rcvr enable
+//  | | | |   | | | |   | | | |   +-----------   3 xmtr enable
+//  | | | |   | | | |   | | | |
+//  | | | |   | | | |   | | | +---------------   4 idle line intr enable
+//  | | | |   | | | |   | | +-----------------   5 rcvr intr enable
+//  | | | |   | | | |   | +-------------------   6 xmit complete intr enable
+//  | | | |   | | | |   +---------------------   7 xmtr intr enable
+//  | | | |   | | | |
+//  | | | |   | | | +-------------------------   8 wakeup on address mark
+//  | | | |   | | +---------------------------   9 mode 1=9 bits, 0=8 bits
+//  | | | |   | +-----------------------------  10 parity enable 1=on, 0=off
+//  | | | |   +-------------------------------  11 parity type 1=odd, 0=even
+//  | | | |
+//  | | | +-----------------------------------  12 idle line select
+//  | | +-------------------------------------  13 wired-or mode
+//  | +---------------------------------------  14 loop mode
+//  +-----------------------------------------  15 unused
+
+//  0 0 0 0 - 0 0 0 0 - 0 0 0 0 - 0 0 0 0       reset value
+
+#define SCI_SEND_BREAK          0x0001          // 0000-0000-0000-0001
+#define SCI_RCVR_WAKEUP         0x0002          // 0000-0000-0000-0010
+#define SCI_ENABLE_RCVR         0x0004          // 0000-0000-0000-0100
+#define SCI_ENABLE_XMTR         0x0008          // 0000-0000-0000-1000
+
+#define SCI_DISABLE_RCVR        0xFFFB          // 1111-1111-1111-1011
+#define SCI_DISABLE_XMTR        0xFFF7          // 1111-1111-1111-0111
+
+#define SCI_ENABLE_INT_IDLE     0x0010          // 0000-0000-0001-0000
+#define SCI_ENABLE_INT_RX       0x0020          // 0000-0000-0010-0000
+#define SCI_ENABLE_INT_TX_DONE  0x0040          // 0000-0000-0100-0000
+#define SCI_ENABLE_INT_TX       0x0080          // 0000-0000-1000-0000
+
+#define SCI_DISABLE_INT_ALL     0xFF00          // 1111-1111-0000-0000 ???
+
+#define SCI_DISABLE_INT_RX      0xFFDF          // 1111-1111-1101-1111
+#define SCI_CLEAR_RX_INT        0xFFBF          // 1111-1111-1011-1111
+#define SCI_DISABLE_INT_TX      0xFF7F          // 1111-1111-0111-1111
+#define SCI_CLEAR_TDRE          0xFEFF          // 1111-1110-1111-1111
+
+#define SCI_RCVR_WAKE_ON_MARK   0x0100          // 0000-0001-0000-0000
+#define SCI_9_DATA_BITS         0x0200          // 0000-0010-0000-0000
+#define SCI_PARITY_ENABLE       0x0400          // 0000-0100-0000-0000
+#define SCI_PARITY_ODD          0x0800          // 0000-1000-0000-0000
+
+#define SCI_RCVR_WAKE_ON_IDLE   0xFEFF          // 1111-1110-1111-1111
+#define SCI_8_DATA_BITS         0xFDFF          // 1111-1101-1111-1111
+#define SCI_PARITY_DISABLE      0xFBFF          // 1111-1011-1111-1111
+#define SCI_PARITY_EVEN         0xF7FF          // 1111-0111-1111-1111
+
+#define SCI_PARITY_NONE         0xF3FF          // 1111-0011-1111-1111
+
+#define SCI_IDLE_LINE_LONG      0x1000          // 0001-0000-0000-0000
+#define SCI_TXD_OPEN_DRAIN      0x2000          // 0010-0000-0000-0000
+#define SCI_LOOPBACK_MODE       0x4000          // 0100-0000-0000-0000
+#define SCI_SCCR1_UNUSED        0x8000          // 1000-0000-0000-0000
+
+
+//  SCI Status Register  (SCSR)  $FFFC0C
+
+//  8 4 2 1 - 8 4 2 1 - 8 4 2 1 - 8 4 2 1
+//  ^ ^ ^ ^   ^ ^ ^ ^   ^ ^ ^ ^   ^ ^ ^ ^
+//  | | | |   | | | |   | | | |   | | | |
+//  | | | |   | | | |   | | | |   | | | +-----   0 PF - parity error
+//  | | | |   | | | |   | | | |   | | +-------   1 FE - framing error
+//  | | | |   | | | |   | | | |   | +---------   2 NF - noise flag
+//  | | | |   | | | |   | | | |   +-----------   3 OR - overrun flag
+//  | | | |   | | | |   | | | |
+//  | | | |   | | | |   | | | +---------------   4 IDLE - idle line detected
+//  | | | |   | | | |   | | +-----------------   5 RAF  - rcvr active flag
+//  | | | |   | | | |   | +-------------------   6 RDRF - rcv data reg full
+//  | | | |   | | | |   +---------------------   7 TC   - xmt complete flag
+//  | | | |   | | | |
+//  | | | |   | | | +-------------------------   8 TDRE - xmt data reg empty
+//  | | | |   | | +---------------------------   9 always zero
+//  | | | |   | +-----------------------------  10 always zero
+//  | | | |   +-------------------------------  11 always zero
+//  | | | |
+//  | | | +-----------------------------------  12 always zero
+//  | | +-------------------------------------  13 always zero
+//  | +---------------------------------------  14 always zero
+//  +-----------------------------------------  15 always zero
+
+//  0 0 0 0 - 0 0 0 1 - 1 0 0 0 - 0 0 0 0       reset value
+
+#define SCI_ERROR_PARITY        0x0001          // 0000-0000-0000-0001
+#define SCI_ERROR_FRAMING       0x0002          // 0000-0000-0000-0010
+#define SCI_ERROR_NOISE         0x0004          // 0000-0000-0000-0100
+#define SCI_ERROR_OVERRUN       0x0008          // 0000-0000-0000-1000
+
+#define SCI_IDLE_LINE           0x0010          // 0000-0000-0001-0000
+#define SCI_RCVR_ACTIVE         0x0020          // 0000-0000-0010-0000
+#define SCI_RCVR_READY          0x0040          // 0000-0000-0100-0000
+#define SCI_XMTR_IDLE           0x0080          // 0000-0000-1000-0000
+
+#define SCI_CLEAR_RX_INT        0xFFBF          // 1111-1111-1011-1111
+
+#define SCI_XMTR_READY          0x0100          // 0000-0001-0000-0000
+
+#define SCI_CLEAR_TDRE          0xFEFF          // 1111-1110-1111-1111
+
+#define SCI_XMTR_AVAILABLE      0x0180          // 0000-0001-1000-0000
+
+
+
+/*******************************************************************************
+  Function prototypes
+*******************************************************************************/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// look at console_open to see how this is called
+
+const rtems_termios_callbacks * SciGetTermiosHandlers( int32_t   polled );
+
+/* SCI interrupt */
+
+//rtems_isr SciIsr( rtems_vector_number vector );
+
+//int32_t   SciOpenPolled    ( int32_t   major, int32_t   minor, void *arg );
+//int32_t   SciOpenInterrupt ( int32_t   major, int32_t   minor, void *arg );
+
+//int32_t   SciClose         ( int32_t   major, int32_t   minor, void *arg );
+
+//int32_t   SciWritePolled   ( int32_t   minor, const char *buf, int32_t   len );
+//int32_t   SciWriteInterrupt( int32_t   minor, const char *buf, int32_t   len );
+
+//int32_t   SciReadPolled    ( int32_t   minor );
+
+//int32_t   SciSetAttributes ( int32_t   minor, const struct termios *t );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  // _sci_h_
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/startup/linkcmds_ROM
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/startup/linkcmds_ROM
@@ -0,0 +1,200 @@
+/*  linkcmds
+ *
+ *  $Id: linkcmds_ROM,v 1.3 2004/11/26 01:54:51 joel Exp $
+ */
+
+OUTPUT_ARCH(m68k)
+STARTUP(except_vect_332_ROM.o)
+__DYNAMIC  =  0;
+
+/*
+ * ROM:
+ * +--------------------+ <- low memory
+ * | .text              |
+ * |        etext       |
+ * |        ctor list   | the ctor and dtor lists are for
+ * |        dtor list   | C++ support
+ * |        _endtext    |
+ * | temporary .data    | .data is moved to RAM by crt0
+ * |                    |
+ * +--------------------+ <- high memory
+ *
+ *
+ * RAM:
+ * +--------------------+ <- low memory
+ * | .data              | initialized data goes here
+ * |        _sdata      |
+ * |        _edata      |
+ * +--------------------+
+ * | .bss               |
+ * |        __bss_start | start of bss, cleared by crt0
+ * |        _end        | start of heap, used by sbrk()
+ * +--------------------+
+ * |    heap space      |
+ * |        _ENDHEAP    |
+ * |    stack space     | 
+ * |        __stack     | top of stack
+ * +--------------------+ <- high memory
+ */
+
+MEMORY
+{
+  rom     : ORIGIN = 0x90000, LENGTH = 0x70000
+  ram     : ORIGIN = 0x03000, LENGTH = 0x7d000
+}
+
+_RamBase = DEFINED(_RamBase) ? _RamBase : 0x003000;
+_RamSize = DEFINED(_RamSize) ? _RamSize : 0x7d000;
+_RamEnd = _RamBase + _RamSize;
+
+__end_of_ram = 0x080000;
+_copy_data_from_rom = 1;
+_HeapSize = DEFINED(_HeapSize) ? _HeapSize : 0x10000;
+_StackSize = DEFINED(_StackSize) ? _StackSize : 0x2000;
+
+/*
+ * 
+ */
+SECTIONS
+{
+  .text :
+  {
+    . = .;
+    CREATE_OBJECT_SYMBOLS
+    text_start = .;
+    _text_start = .;
+    *(.text)
+    . = ALIGN (16);
+
+
+    /*
+     * Initialization and finalization code.
+     *
+     * Various files can provide initialization and finalization
+     * functions.  crtbegin.o and crtend.o are two instances. The
+     * body of these functions are in .init and .fini sections. We
+     * accumulate the bodies here, and prepend function prologues
+     * from crti.o and function epilogues from crtn.o. crti.o must
+     * be linked first; crtn.o must be linked last.  Because these
+     * are wildcards, it doesn't matter if the user does not
+     * actually link against crti.o and crtn.o; the linker won't
+     * look for a file to match a wildcard.  The wildcard also
+     * means that it doesn't matter which directory crti.o and
+     * crtn.o are in. 
+     */
+    PROVIDE (_init = .);
+    *crti.o(.init)
+    *(.init)
+    *crtn.o(.init)
+    PROVIDE (_fini = .);
+    *crti.o(.fini)
+    *(.fini)
+    *crtn.o(.fini)
+
+    /*
+     * Special FreeBSD sysctl sections.
+     */
+    . = ALIGN (16);
+    __start_set_sysctl_set = .;
+    *(set_sysctl_*);
+    __stop_set_sysctl_set = ABSOLUTE(.);
+    *(set_domain_*);
+    *(set_pseudo_*);
+
+    /*
+     * C++ constructors/destructors
+     *
+     * gcc uses crtbegin.o to find the start of the constructors
+     * and destructors so we make sure it is first.  Because this
+     * is a wildcard, it doesn't matter if the user does not
+     * actually link against crtbegin.o; the linker won't look for
+     * a file to match a wildcard.  The wildcard also means that
+     * it doesn't matter which directory crtbegin.o is in. The
+     * constructor and destructor list are terminated in
+     * crtend.o.  The same comments apply to it.
+     */
+    . = ALIGN (16);
+    *crtbegin.o(.ctors)
+    *(.ctors)
+    *crtend.o(.ctors)
+    *crtbegin.o(.dtors)
+    *(.dtors)
+    *crtend.o(.dtors)
+
+    *(.eh_frame)
+    . = ALIGN (16);
+
+    /*
+     * Read-only data
+     */
+    . = ALIGN (16);
+    _rodata_start = . ;
+    *(.rodata*)
+    *(.gnu.linkonce.r*)
+
+    etext = ALIGN(0x10);
+    __CTOR_LIST__ = .;
+    LONG((__CTOR_END__ - __CTOR_LIST__) / 4 - 2)
+    *(.ctors)
+    LONG(0)
+    __CTOR_END__ = .;
+    __DTOR_LIST__ = .;
+    LONG((__DTOR_END__ - __DTOR_LIST__) / 4 - 2)
+    *(.dtors)
+    LONG(0)
+    __DTOR_END__ = .;
+    *(.lit)
+    *(.shdata)
+    _etext = .;
+    _endtext = .;
+  } > rom
+  .gcc_exc :
+  AT ( ADDR(.text) + SIZEOF( .text ) )
+  {
+    *(.gcc_exc)
+  } > ram
+  .data :
+  {
+    data_start = .;
+    _data_start = .;
+    _copy_start = .;
+    _sdata = . ;
+    *(.data)
+    *(.gnu.linkonce.d*)
+    *(.gcc_except_table)
+    *(.jcr)
+
+    CONSTRUCTORS
+    edata = ALIGN(0x10);
+    _edata = .;
+  } > ram
+  .shbss :
+  {
+    *(.shbss)
+  } > ram
+  .bss :
+  {
+    __bss_start = ALIGN(0x8);
+    bss_start = .;
+    _bss_start = .;
+    _clear_start = .;
+    *(.shbss)
+    *(.dynbss)
+    *(.bss .bss.* .gnu.linkonce.b.*)
+    *(COMMON)
+    . = ALIGN (16);
+    end = .;
+    _end = ALIGN(0x8);
+    __end = ALIGN(0x8);
+
+    _WorkspaceBase = . + _StackSize;
+  } > ram
+  .stab . (NOLOAD) :
+  {
+    [ .stab ]
+  }
+  .stabstr . (NOLOAD) :
+  {
+    [ .stabstr ]
+  }
+}
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/startup/except_vect_332_ROM.S
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/startup/except_vect_332_ROM.S
@@ -0,0 +1,293 @@
+/*
+ *  $Id: except_vect_332_ROM.S,v 1.3 2004/04/21 16:01:35 ralf Exp $
+ */
+
+/* Exception Vector definitions follow */
+
+	/* !!! Warning !!! This table is not tested, and
+	   the user must make sure it is complete. */
+
+	/* If we use TRAP #15 for reboot, note that group 0 and 1 exceptions
+	   will have priority. */
+
+	/* This is the "magic word" that CPU32bug uses to indicate that
+	   there is a bootable image here. */
+	.long   0xBEEFBEEF
+
+	/* Vector 0:	RESET:	Initial SSP */
+	.long	_RamEnd
+	/* Vector 1:	RESET:	Initial PC */
+	.long	start
+
+	/* default action for undefined vectors is to re-boot */
+
+	/* Note group 0 and 1 exception (like trace) have priority
+	   over other exceptions (like trap #15) that may call this. */
+
+	/* Vectors 2-255 */
+	.long reboot   /* exception vector:   2 */
+	.long reboot   /* exception vector:   3 */
+	.long reboot   /* exception vector:   4 */
+	.long reboot   /* exception vector:   5 */
+	.long reboot   /* exception vector:   6 */
+	.long reboot   /* exception vector:   7 */
+	.long reboot   /* exception vector:   8 */
+	.long reboot   /* exception vector:   9 */
+	.long reboot   /* exception vector:  10 */
+	.long reboot   /* exception vector:  11 */
+	.long reboot   /* exception vector:  12 */
+	.long reboot   /* exception vector:  13 */
+	.long reboot   /* exception vector:  14 */
+	.long reboot   /* exception vector:  15 */
+	.long reboot   /* exception vector:  16 */
+	.long reboot   /* exception vector:  17 */
+	.long reboot   /* exception vector:  18 */
+	.long reboot   /* exception vector:  19 */
+	.long reboot   /* exception vector:  20 */
+	.long reboot   /* exception vector:  21 */
+	.long reboot   /* exception vector:  22 */
+	.long reboot   /* exception vector:  23 */
+	.long reboot   /* exception vector:  24 */
+	.long reboot   /* exception vector:  25 */
+	.long reboot   /* exception vector:  26 */
+	.long reboot   /* exception vector:  27 */
+	.long reboot   /* exception vector:  28 */
+	.long reboot   /* exception vector:  29 */
+	.long reboot   /* exception vector:  30 */
+	.long reboot   /* exception vector:  31 */
+	.long reboot   /* exception vector:  32 */
+	.long reboot   /* exception vector:  33 */
+	.long reboot   /* exception vector:  34 */
+	.long reboot   /* exception vector:  35 */
+	.long reboot   /* exception vector:  36 */
+	.long reboot   /* exception vector:  37 */
+	.long reboot   /* exception vector:  38 */
+	.long reboot   /* exception vector:  39 */
+	.long reboot   /* exception vector:  40 */
+	.long reboot   /* exception vector:  41 */
+	.long reboot   /* exception vector:  42 */
+	.long reboot   /* exception vector:  43 */
+	.long reboot   /* exception vector:  44 */
+	.long reboot   /* exception vector:  45 */
+	.long reboot   /* exception vector:  46 */
+	.long _reboot  /* the reboot trap:   47 */
+	.long reboot   /* exception vector:  48 */
+	.long reboot   /* exception vector:  49 */
+	.long reboot   /* exception vector:  50 */
+	.long reboot   /* exception vector:  51 */
+	.long reboot   /* exception vector:  52 */
+	.long reboot   /* exception vector:  53 */
+	.long reboot   /* exception vector:  54 */
+	.long reboot   /* exception vector:  55 */
+	.long reboot   /* exception vector:  56 */
+	.long reboot   /* exception vector:  57 */
+	.long reboot   /* exception vector:  58 */
+	.long reboot   /* exception vector:  59 */
+	.long reboot   /* exception vector:  60 */
+	.long reboot   /* exception vector:  61 */
+	.long reboot   /* exception vector:  62 */
+	.long reboot   /* exception vector:  63 */
+	.long reboot   /* exception vector:  64 */
+	.long reboot   /* exception vector:  65 */
+	.long reboot   /* exception vector:  66 */
+	.long reboot   /* exception vector:  67 */
+	.long reboot   /* exception vector:  68 */
+	.long reboot   /* exception vector:  69 */
+	.long reboot   /* exception vector:  70 */
+	.long reboot   /* exception vector:  71 */
+	.long reboot   /* exception vector:  72 */
+	.long reboot   /* exception vector:  73 */
+	.long reboot   /* exception vector:  74 */
+	.long reboot   /* exception vector:  75 */
+	.long reboot   /* exception vector:  76 */
+	.long reboot   /* exception vector:  77 */
+	.long reboot   /* exception vector:  78 */
+	.long reboot   /* exception vector:  79 */
+	.long reboot   /* exception vector:  80 */
+	.long reboot   /* exception vector:  81 */
+	.long reboot   /* exception vector:  82 */
+	.long reboot   /* exception vector:  83 */
+	.long reboot   /* exception vector:  84 */
+	.long reboot   /* exception vector:  85 */
+	.long reboot   /* exception vector:  86 */
+	.long reboot   /* exception vector:  87 */
+	.long reboot   /* exception vector:  88 */
+	.long reboot   /* exception vector:  89 */
+	.long reboot   /* exception vector:  90 */
+	.long reboot   /* exception vector:  91 */
+	.long reboot   /* exception vector:  92 */
+	.long reboot   /* exception vector:  93 */
+	.long reboot   /* exception vector:  94 */
+	.long reboot   /* exception vector:  95 */
+	.long reboot   /* exception vector:  96 */
+	.long reboot   /* exception vector:  97 */
+	.long reboot   /* exception vector:  98 */
+	.long reboot   /* exception vector:  99 */
+	.long reboot   /* exception vector: 100 */
+	.long reboot   /* exception vector: 101 */
+	.long reboot   /* exception vector: 102 */
+	.long reboot   /* exception vector: 103 */
+	.long reboot   /* exception vector: 104 */
+	.long reboot   /* exception vector: 105 */
+	.long reboot   /* exception vector: 106 */
+	.long reboot   /* exception vector: 107 */
+	.long reboot   /* exception vector: 108 */
+	.long reboot   /* exception vector: 109 */
+	.long reboot   /* exception vector: 110 */
+	.long reboot   /* exception vector: 111 */
+	.long reboot   /* exception vector: 112 */
+	.long reboot   /* exception vector: 113 */
+	.long reboot   /* exception vector: 114 */
+	.long reboot   /* exception vector: 115 */
+	.long reboot   /* exception vector: 116 */
+	.long reboot   /* exception vector: 117 */
+	.long reboot   /* exception vector: 118 */
+	.long reboot   /* exception vector: 119 */
+	.long reboot   /* exception vector: 120 */
+	.long reboot   /* exception vector: 121 */
+	.long reboot   /* exception vector: 122 */
+	.long reboot   /* exception vector: 123 */
+	.long reboot   /* exception vector: 124 */
+	.long reboot   /* exception vector: 125 */
+	.long reboot   /* exception vector: 126 */
+	.long reboot   /* exception vector: 127 */
+	.long reboot   /* exception vector: 128 */
+	.long reboot   /* exception vector: 129 */
+	.long reboot   /* exception vector: 130 */
+	.long reboot   /* exception vector: 131 */
+	.long reboot   /* exception vector: 132 */
+	.long reboot   /* exception vector: 133 */
+	.long reboot   /* exception vector: 134 */
+	.long reboot   /* exception vector: 135 */
+	.long reboot   /* exception vector: 136 */
+	.long reboot   /* exception vector: 137 */
+	.long reboot   /* exception vector: 138 */
+	.long reboot   /* exception vector: 139 */
+	.long reboot   /* exception vector: 140 */
+	.long reboot   /* exception vector: 141 */
+	.long reboot   /* exception vector: 142 */
+	.long reboot   /* exception vector: 143 */
+	.long reboot   /* exception vector: 144 */
+	.long reboot   /* exception vector: 145 */
+	.long reboot   /* exception vector: 146 */
+	.long reboot   /* exception vector: 147 */
+	.long reboot   /* exception vector: 148 */
+	.long reboot   /* exception vector: 149 */
+	.long reboot   /* exception vector: 150 */
+	.long reboot   /* exception vector: 151 */
+	.long reboot   /* exception vector: 152 */
+	.long reboot   /* exception vector: 153 */
+	.long reboot   /* exception vector: 154 */
+	.long reboot   /* exception vector: 155 */
+	.long reboot   /* exception vector: 156 */
+	.long reboot   /* exception vector: 157 */
+	.long reboot   /* exception vector: 158 */
+	.long reboot   /* exception vector: 159 */
+	.long reboot   /* exception vector: 160 */
+	.long reboot   /* exception vector: 161 */
+	.long reboot   /* exception vector: 162 */
+	.long reboot   /* exception vector: 163 */
+	.long reboot   /* exception vector: 164 */
+	.long reboot   /* exception vector: 165 */
+	.long reboot   /* exception vector: 166 */
+	.long reboot   /* exception vector: 167 */
+	.long reboot   /* exception vector: 168 */
+	.long reboot   /* exception vector: 169 */
+	.long reboot   /* exception vector: 170 */
+	.long reboot   /* exception vector: 171 */
+	.long reboot   /* exception vector: 172 */
+	.long reboot   /* exception vector: 173 */
+	.long reboot   /* exception vector: 174 */
+	.long reboot   /* exception vector: 175 */
+	.long reboot   /* exception vector: 176 */
+	.long reboot   /* exception vector: 177 */
+	.long reboot   /* exception vector: 178 */
+	.long reboot   /* exception vector: 179 */
+	.long reboot   /* exception vector: 180 */
+	.long reboot   /* exception vector: 181 */
+	.long reboot   /* exception vector: 182 */
+	.long reboot   /* exception vector: 183 */
+	.long reboot   /* exception vector: 184 */
+	.long reboot   /* exception vector: 185 */
+	.long reboot   /* exception vector: 186 */
+	.long reboot   /* exception vector: 187 */
+	.long reboot   /* exception vector: 188 */
+	.long reboot   /* exception vector: 189 */
+	.long reboot   /* exception vector: 190 */
+	.long reboot   /* exception vector: 191 */
+	.long reboot   /* exception vector: 192 */
+	.long reboot   /* exception vector: 193 */
+	.long reboot   /* exception vector: 194 */
+	.long reboot   /* exception vector: 195 */
+	.long reboot   /* exception vector: 196 */
+	.long reboot   /* exception vector: 197 */
+	.long reboot   /* exception vector: 198 */
+	.long reboot   /* exception vector: 199 */
+	.long reboot   /* exception vector: 200 */
+	.long reboot   /* exception vector: 201 */
+	.long reboot   /* exception vector: 202 */
+	.long reboot   /* exception vector: 203 */
+	.long reboot   /* exception vector: 204 */
+	.long reboot   /* exception vector: 205 */
+	.long reboot   /* exception vector: 206 */
+	.long reboot   /* exception vector: 207 */
+	.long reboot   /* exception vector: 208 */
+	.long reboot   /* exception vector: 209 */
+	.long reboot   /* exception vector: 210 */
+	.long reboot   /* exception vector: 211 */
+	.long reboot   /* exception vector: 212 */
+	.long reboot   /* exception vector: 213 */
+	.long reboot   /* exception vector: 214 */
+	.long reboot   /* exception vector: 215 */
+	.long reboot   /* exception vector: 216 */
+	.long reboot   /* exception vector: 217 */
+	.long reboot   /* exception vector: 218 */
+	.long reboot   /* exception vector: 219 */
+	.long reboot   /* exception vector: 220 */
+	.long reboot   /* exception vector: 221 */
+	.long reboot   /* exception vector: 222 */
+	.long reboot   /* exception vector: 223 */
+	.long reboot   /* exception vector: 224 */
+	.long reboot   /* exception vector: 225 */
+	.long reboot   /* exception vector: 226 */
+	.long reboot   /* exception vector: 227 */
+	.long reboot   /* exception vector: 228 */
+	.long reboot   /* exception vector: 229 */
+	.long reboot   /* exception vector: 230 */
+	.long reboot   /* exception vector: 231 */
+	.long reboot   /* exception vector: 232 */
+	.long reboot   /* exception vector: 233 */
+	.long reboot   /* exception vector: 234 */
+	.long reboot   /* exception vector: 235 */
+	.long reboot   /* exception vector: 236 */
+	.long reboot   /* exception vector: 237 */
+	.long reboot   /* exception vector: 238 */
+	.long reboot   /* exception vector: 239 */
+	.long reboot   /* exception vector: 240 */
+	.long reboot   /* exception vector: 241 */
+	.long reboot   /* exception vector: 242 */
+	.long reboot   /* exception vector: 243 */
+	.long reboot   /* exception vector: 244 */
+	.long reboot   /* exception vector: 245 */
+	.long reboot   /* exception vector: 246 */
+	.long reboot   /* exception vector: 247 */
+	.long reboot   /* exception vector: 248 */
+	.long reboot   /* exception vector: 249 */
+	.long reboot   /* exception vector: 250 */
+	.long reboot   /* exception vector: 251 */
+	.long reboot   /* exception vector: 252 */
+	.long reboot   /* exception vector: 253 */
+	.long reboot   /* exception vector: 254 */
+	.long reboot   /* exception vector: 255 */
+
+_reboot:
+	move	#0x2700,%sr	/* mask interrupts */
+	movea.l	(0x0).w,%a7	/* load stack */
+	movea.l	(0x4).w,%a0	/* jmp to location of reset vector */
+	jmp	(%a0)
+
+reboot:
+	trap	#15		/* use trap exception to enter supervisor
+				   state. Trace mode ( and other group 0
+				   and 1 exceptions) *could* screw this up if
+				   not vectored to reboot or did not return. */
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/console/console.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/console/console.c
@@ -0,0 +1,176 @@
+/*
+ *  This file contains the generic console driver shell used
+ *  by all console drivers using libchip.
+ *
+ *  This driver uses the termios pseudo driver.
+ *
+ *  COPYRIGHT (c) 1989-1997.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: console.c,v 1.7 2004/04/21 16:01:35 ralf Exp $
+ */
+
+#include <bsp.h>
+#include <rtems/libio.h>
+#include <termios.h>
+#include "sci.h"
+//#include "../../../../../../rtems/c/src/lib/libbsp/m68k/opti/console/duart.h"
+//#include "../../../../../../rtems/c/src/lib/libc/libio_.h"
+
+/*PAGE
+ *
+ *  console_open
+ *
+ *  open a port as a termios console.
+ *
+ *  the console is opened in bsp_postdriver_hook() in bsppost.c
+ *
+ */
+
+rtems_device_driver console_open(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void                    * arg
+)
+{
+    rtems_status_code status;
+
+    /* the console is opened three times at startup */
+    /* for standard input, output, and error */
+
+    /* Get correct callback structure for the device */
+
+    /* argument of FALSE gives us interrupt driven serial io */
+    /* argument of TRUE  gives us polling   based  serial io */
+
+    /* SCI internal uart */
+
+    status = rtems_termios_open( major, minor, arg, SciGetTermiosHandlers( TRUE ) );
+
+    return status;
+}
+
+/*PAGE
+ *
+ *  console_close
+ *
+ *  This routine closes a port that has been opened as console.
+ */
+
+rtems_device_driver console_close(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void                    * arg
+)
+{
+  return rtems_termios_close (arg);
+}
+
+/*PAGE
+ *
+ *  console_read
+ *
+ *  This routine uses the termios driver to read a character.
+ */
+
+rtems_device_driver console_read(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void                    * arg
+)
+{
+  return rtems_termios_read (arg);
+}
+
+/*PAGE
+ *
+ *  console_write
+ *
+ *  this routine uses the termios driver to write a character.
+ */
+
+rtems_device_driver console_write(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void                    * arg
+)
+{
+  return rtems_termios_write (arg);
+}
+
+/*PAGE
+ *
+ *  console_control
+ *
+ *  this routine uses the termios driver to process io
+ */
+
+rtems_device_driver console_control(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void                    * arg
+)
+{
+  return rtems_termios_ioctl (arg);
+}
+
+/*PAGE
+ *
+ *  console_initialize
+ *
+ *  Routine called to initialize the console device driver.
+ */
+
+rtems_device_driver console_initialize(
+  rtems_device_major_number  major,
+  rtems_device_minor_number  minor_arg,
+  void                      *arg
+)
+{
+  rtems_status_code          status;
+
+  /*
+   * initialize the termio interface.
+   */
+  rtems_termios_initialize();
+
+  /*
+   * register the SCI device name for termios
+   * do this over in the sci driver init routine?
+   */
+
+  status = rtems_io_register_name( "/dev/sci", major, 0 );
+
+  if (status != RTEMS_SUCCESSFUL)
+  {
+    rtems_fatal_error_occurred(status);
+  }
+
+  /*
+   * Link the uart device to the console device
+   */
+
+#if 1
+  status = rtems_io_register_name( "/dev/console", major, 0 );
+
+  if (status != RTEMS_SUCCESSFUL)
+  {
+    rtems_fatal_error_occurred(status);
+  }
+#else
+  if ( link( "/dev/sci", "/dev/console") < 0 )
+  {
+    rtems_fatal_error_occurred( RTEMS_IO_ERROR );
+  }
+#endif
+
+  /*
+   * Console Initialize Succesful
+   */
+
+  return RTEMS_SUCCESSFUL;
+}
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/.cvsignore
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/.cvsignore
@@ -0,0 +1,14 @@
+aclocal.m4
+autom4te*.cache
+config.cache
+config.guess
+config.log
+config.status
+config.sub
+configure
+depcomp
+install-sh
+Makefile
+Makefile.in
+missing
+mkinstalldirs
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/start/start.S
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/start/start.S
@@ -0,0 +1,150 @@
+/*
+ *  $Id
+ */
+
+#include "mrm332.h"
+#include <rtems/asm.h>
+#include <rtems/m68k/sim.h>
+
+BEGIN_CODE
+
+  /* Put the header necessary for the modified CPU32bug to automatically
+     start up rtems: */
+#if 0
+.long 0xbeefbeef ;
+#endif
+.long 0 ;
+.long start ;
+
+.global start
+	start:
+
+	oriw   #0x0700,sr
+	movel  #end, d0
+	addl   #_StackSize,d0
+	movel  d0,sp
+	movel  d0,a6
+
+  /* include in ram_init.S */
+  /*
+   * Initalize the SIM module.
+   * The stack pointer is not usable until the RAM chip select lines
+   * are configured. The following code must remain inline.
+   */
+
+  /* Module Configuration Register */
+  /*    see section(s) 3.1.3-3.1.6 of the SIM Reference Manual */
+	lea	SIMCR, a0
+	movew	#FRZSW,d0
+	oriw	#SAM(0,8,SHEN),d0
+	oriw	#(MM*SIM_MM),d0
+	oriw	#SAM(SIM_IARB,0,IARB),d0
+	movew	d0, a0@
+
+	jsr	start_c /* Jump to the C startup code */
+
+END_CODE
+
+#if 0
+
+  /* Synthesizer Control Register */
+  /*    see section(s) 4.8 */
+  /* end include in ram_init.S */
+  *SYNCR = (unsigned short int)
+    ( SAM(MRM_W,15,VCO) | SAM(0x0,14,PRESCALE) | SAM(MRM_Y,8,COUNTER) );
+  while (! (*SYNCR & SLOCK));	/* protect from clock overshoot */
+  /* include in ram_init.S */
+  *SYNCR = (unsigned short int)
+    ( SAM(MRM_W,15,VCO) | SAM(MRM_X,14,PRESCALE) | SAM(MRM_Y,8,COUNTER) );
+
+  /* System Protection Control Register */
+  /*    !!! can only write to once after reset !!! */
+  /*    see section 3.8.4 of the SIM Reference Manual */
+  *SYPCR = (unsigned char)( HME | BME );
+
+  /* Periodic Interrupr Control Register */
+  /*    see section 3.8.2 of the SIM Reference Manual */
+  *PICR = (unsigned short int)
+    ( SAM(0,8,PIRQL) | SAM(MRM_PIV,0,PIV) );
+  /*     ^^^ zero disables interrupt, don't enable here or ram_init will
+	 be wrong. It's enabled below. */
+
+  /* Periodic Interrupt Timer Register */
+  /*    see section 3.8.3 of the SIM Reference Manual */
+  *PITR = (unsigned short int)( SAM(0x09,0,PITM) );
+  /*    1.098mS interrupt, assuming 32.768 KHz input clock */
+
+  /* Port C Data */
+  /*    load values before enabled */
+  *PORTC = (unsigned char) 0x0;
+
+  /* Port E and F Data Register */
+  /*    see section 9 of the SIM Reference Manual */
+  *PORTE0 = (unsigned char) 0;
+  *PORTF0 = (unsigned char) 0;
+
+  /* Port E and F Data Direction Register */
+  /*    see section 9 of the SIM Reference Manual */
+  *DDRE = (unsigned char) 0xff;
+  *DDRF = (unsigned char) 0xfd;
+
+  /* Port E and F Pin Assignment Register */
+  /*    see section 9 of the SIM Reference Manual */
+  *PEPAR = (unsigned char) 0;
+  *PFPAR = (unsigned char) 0;
+
+  /* end of SIM initalization code */
+  /* end include in ram_init.S */
+
+  /*
+   * Initialize RAM by copying the .data section out of ROM (if
+   * needed) and "zero-ing" the .bss section.
+   */
+  {
+    register char *src = _etext;
+    register char *dst = _copy_start;
+
+    if (_copy_data_from_rom)
+      /* ROM has data at end of text; copy it. */
+      while (dst < _edata)
+	*dst++ = *src++;
+
+    /* Zero bss */
+    for (dst = _clear_start; dst< end; dst++)
+      {
+	*dst = 0;
+      }
+  }
+
+  /*
+   * Initialize vector table.
+   */
+  {
+    m68k_isr_entry *monitors_vector_table;
+
+    m68k_get_vbr(monitors_vector_table);
+
+    M68Kvec[  4 ] = monitors_vector_table[  4 ];   /* breakpoints vector */
+    M68Kvec[  9 ] = monitors_vector_table[  9 ];   /* trace vector */
+    M68Kvec[ 31 ] = monitors_vector_table[ 31 ];   /* level 7 interrupt */
+    M68Kvec[ 47 ] = monitors_vector_table[ 47 ];   /* system call vector */
+    M68Kvec[ 66 ] = monitors_vector_table[ 66 ];   /* user defined */
+
+    m68k_set_vbr(&M68Kvec);
+  }
+
+  /*
+   * Initalize the board.
+   */
+  Spurious_Initialize();
+  console_init();
+
+  /*
+   * Execute main with arguments argc and agrv.
+   */
+  boot_card(1,__argv);
+  reboot();
+
+}
+
+#endif
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/misc/dotests
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/misc/dotests
@@ -0,0 +1,15 @@
+#! /bin/bash
+#
+#  $Id: dotests,v 1.1 2001/05/25 16:28:46 joel Exp $
+#
+
+mkdir MyTests
+find -name MyTests -prune -or -name "*.nxe" -exec cp {} MyTests \;
+
+stty 1:0:80001cb2:0:3:1c:7f:15:4:5:1:0:11:13:1a:0:12:f:17:16:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0:0 </dev/ttyS1
+/bin/cp /dev/ttyS1 screen &
+cpJob=$!
+
+( cd MyTests; for f in *nxe; do m68k-elf-gdb ${f} </dev/null; done )
+
+kill -9 $cpJob
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/include/bsp.h
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/include/bsp.h
@@ -0,0 +1,140 @@
+/*  bsp.h
+ *
+ *  This include file contains all mrm board IO definitions.
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: bsp.h,v 1.13 2005/05/26 05:31:17 ralf Exp $
+ */
+
+#ifndef _BSP_H
+#define _BSP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <bspopts.h>
+
+#include <rtems.h>
+#include <rtems/bspIo.h>
+#include <rtems/clockdrv.h>
+#include <rtems/console.h>
+#include <rtems/iosupp.h>
+#include <mrm332.h>
+#include <rtems/m68k/sim.h>
+#include <rtems/m68k/qsm.h>
+
+/*
+ *  confdefs.h overrides for this BSP:
+ *   - number of termios serial ports (defaults to 1)
+ *   - Interrupt stack space is not minimum if defined.
+ */
+
+#define CONSOLE_SCI
+/* #define CONFIGURE_NUMBER_OF_TERMIOS_PORTS 2 */
+/* #define CONFIGURE_INTERRUPT_STACK_MEMORY  (TBD * 1024) */
+
+/*
+ *  Simple spin delay in microsecond units for device drivers.
+ *  This is very dependent on the clock speed of the target.
+ */
+
+#define rtems_bsp_delay( microseconds ) \
+  { register uint32_t         _delay=(microseconds); \
+    register uint32_t         _tmp=123; \
+    asm volatile( "0: \
+                     nbcd      %0 ; \
+                     nbcd      %0 ; \
+                     dbf       %1,0b" \
+                  : "=d" (_tmp), "=d" (_delay) \
+                  : "0"  (_tmp), "1"  (_delay) ); \
+  }
+
+/* externals */
+
+extern char _etext[];
+extern char _copy_start[];
+extern char _edata[];
+extern char _clear_start[];
+extern char end[];
+extern char _copy_data_from_rom[];
+
+/* constants */
+
+#ifdef __START_C__
+#define STACK_SIZE "#0x800"
+#else
+#define STACK_SIZE 0x800
+#endif
+
+/* macros */
+
+#define RAW_PUTS(str) \
+  { register char *ptr = str; \
+    while (*ptr) SCI_output_char(*ptr++); \
+  }
+
+#define RAW_PUTI(n) { \
+    register int i, j; \
+    \
+    RAW_PUTS("0x"); \
+    for (i=28;i>=0;i -= 4) { \
+      j = (n>>i) & 0xf; \
+      SCI_output_char( (j>9 ? j-10+'a' : j+'0') ); \
+    } \
+  }
+
+/* miscellaneous stuff assumed to exist */
+
+extern rtems_configuration_table BSP_Configuration;
+
+extern m68k_isr_entry M68Kvec[];   /* vector table address */
+
+extern int stack_size;
+
+extern int stack_start;
+
+/*
+ *  Device Driver Table Entries
+ */
+
+/*
+ * NOTE: Use the standard Console driver entry
+ */
+
+/*
+ * NOTE: Use the standard Clock driver entry
+ */
+
+/* functions */
+
+void bsp_cleanup( void );
+
+m68k_isr_entry set_vector(
+  rtems_isr_entry     handler,
+  rtems_vector_number vector,
+  int                 type
+);
+
+void console_init(void);
+
+void Spurious_Initialize(void);
+
+void _UART_flush(void);
+
+void Clock_exit(void);
+
+void outbyte(char);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+/* end of include file */
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/misc/interr.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/misc/interr.c
@@ -0,0 +1,99 @@
+/*
+ *  Internal Error Handler
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: interr.c,v 1.3 2004/03/31 04:37:05 ralf Exp $
+ */
+
+#include <rtems/system.h>
+#include <rtems/score/interr.h>
+#include <rtems/score/sysstate.h>
+#include <rtems/score/userext.h>
+
+/*PAGE
+ *
+ *  _Internal_error_Occurred
+ *
+ *  This routine will invoke the fatal error handler supplied by the user
+ *  followed by the the default one provided by the executive.  The default
+ *  error handler assumes no hardware is present to help inform the user
+ *  of the problem.  Halt stores the error code in a known register,
+ *  disables interrupts, and halts the CPU.  If the CPU does not have a
+ *  halt instruction, it will loop to itself.
+ *
+ *  Input parameters:
+ *    the_source  - what subsystem the error originated in
+ *    is_internal - if the error was internally generated
+ *    the_error   - fatal error status code
+ *
+ *  Output parameters:
+ *    As much information as possible is stored in a CPU dependent fashion.
+ *    See the CPU dependent code for more information.
+ *
+ *  NOTE: The the_error is not necessarily a directive status code.
+ */
+
+/*
+ * Ugly hack.... _CPU_Fatal_halt() disonnects the bdm. Without this
+ * change, the_error is only known only to the cpu :).
+ *
+ * From "bsp.h" which is not yet available in the arch tree during
+ * this phase of install. jsg
+ */
+void outbyte(char);
+void bsp_cleanup( void );
+
+#define RAW_PUTS(str) \
+  { register char *ptr = str; \
+    while (*ptr) outbyte(*ptr++); \
+  }
+
+#define RAW_PUTI(n) { \
+    register int i, j; \
+    \
+    RAW_PUTS("0x"); \
+    for (i=28;i>=0;i -= 4) { \
+      j = (n>>i) & 0xf; \
+      outbyte( (j>9 ? j-10+'a' : j+'0') ); \
+    } \
+  }
+
+void volatile _Internal_error_Occurred(
+  Internal_errors_Source  the_source,
+  boolean                 is_internal,
+  uint32_t                the_error
+)
+{
+
+  Internal_errors_What_happened.the_source  = the_source;
+  Internal_errors_What_happened.is_internal = is_internal;
+  Internal_errors_What_happened.the_error   = the_error;
+
+  _User_extensions_Fatal( the_source, is_internal, the_error );
+
+  _System_state_Set( SYSTEM_STATE_FAILED );
+
+  /* try to print error message to outbyte */
+  RAW_PUTS("\r\nRTEMS: A fatal error has occured.\r\n");
+  RAW_PUTS("RTEMS:    fatal error ");
+  RAW_PUTI( the_error );
+  RAW_PUTS(" (");
+  outbyte( (char)((the_error>>24) & 0xff) );
+  outbyte( (char)((the_error>>16) & 0xff) );
+  outbyte( (char)((the_error>>8) & 0xff) );
+  outbyte( (char)(the_error & 0xff) );
+  RAW_PUTS(").\r\n");
+
+  /* configure peripherals for a safe exit */
+  bsp_cleanup();
+
+  _CPU_Fatal_halt( the_error );
+
+  /* will not return from this routine */
+}
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/ChangeLog
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/ChangeLog
@@ -0,0 +1,428 @@
+2005-05-26	Ralf Corsepius <ralf.corsepius@rtems.org>
+
+	* include/bsp.h: New header guard.
+
+2005-01-07	Ralf Corsepius <ralf.corsepius@rtems.org>
+
+	* Makefile.am: Eliminate CFLAGS_OPTIMIZE_V.
+
+2005-01-05	Ralf Corsepius <ralf.corsepius@rtems.org>
+
+	* console/sci.c: Remove CVS Log.
+
+2005-01-04	Joel Sherrill <joel@OARcorp.com>
+
+	* console/sci.c: Remove warnings.
+
+2005-01-02	Ralf Corsepius <ralf.corsepius@rtems.org>
+
+	* Makefile.am: Remove build-variant support.
+
+2004-11-25	Joel Sherrill <joel@OARcorp.com>
+
+	* startup/linkcmds, startup/linkcmds_ROM: Add new bss sections .bss.*
+	and .gnu.linkonce.b*.
+
+2004-09-24	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	* configure.ac: Require automake > 1.9.
+
+2004-04-23	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	PR 610/bsps
+	* Makefile.am: Add include/tm27.h, Cosmetics.
+	* include/tm27.h: Final cosmetics.
+
+2004-04-22	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	* include/bsp.h: Split out tmtest27 support.
+	* include/tm27.h: New.
+
+2004-04-21	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	PR 613/bsps
+	* include/bsp.h: Remove MAX_LONG_TEST_DURATION.
+
+2004-04-21	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	PR 614/bsps
+	* include/bsp.h: Remove MAX_SHORT_TEST_DURATION (Unused).
+
+2004-04-03	Ralf Corsepiu <ralf_corsepiu@rtems.org>
+
+	* c/src/lib/libbsp/m68k/mrm332/include/bsp.h,
+	c/src/lib/libbsp/m68k/mrm332/start/start.S,
+	c/src/lib/libbsp/m68k/mrm332/startup/start_c.c: Include
+	<rtems/m68k/sim.h> instead of <sim.h>.
+	* c/src/lib/libbsp/m68k/mrm332/include/bsp.h: Include
+	<rtems/m68k/qsm.h> instead of <qsm.h>.
+
+2004-04-02	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	* start/start.S: Include <rtems/asm.h> instead of <asm.h>.
+
+2004-04-01	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	* include/bsp.h: Include <rtems/clockdrv.h> instead of <clockdrv.h>.
+	* include/bsp.h: Include <rtems/console.h> instead of <console.h>.
+	* include/bsp.h: Include <rtems/iosupp.h> instead of <iosupp.h>.
+
+2004-03-31	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	* clock/ckinit.c, console/sci.c, console/sci.h, include/bsp.h,
+	misc/interr.c, startup/bspstart.c, timer/timer.c: Convert to using
+	c99 fixed size types.
+
+2004-02-19	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: Reflect changes to bsp.am. 
+	Preinstall dist_project_lib*.
+
+2004-02-14	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: Reflect changes to bsp.am.
+
+2004-02-12	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: Use CPPASCOMPILE instead of CCASCOMPILE.
+
+2004-02-06	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: Pickup files from ../../m68k/shared instead of
+	../shared. Reformat.
+
+2004-01-28	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* configure.ac: Add nostdinc to AUTOMAKE_OPTIONS.
+
+2004-01-28	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: Don't include subdirs.am.
+
+2004-01-28	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: Fix typo.
+
+2004-01-28	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: Merge-in clock/Makefile.am, console/Makefile.am,
+	spurious/Makefile.am, startup/Makefile.am, timer/Makefile.am,
+	wrapup/Makefile.am.
+	Use automake compilation rules.
+	* clock/Makefile.am, console/Makefile.am, spurious/Makefile.am,
+	startup/Makefile.am, timer/Makefile.am, wrapup/Makefile.am:
+	Remove.
+	* configure.ac: Reflect changes above.
+
+2004-01-21	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: Add PREINSTALL_DIRS.
+	* wrapup/Makefile.am: Reflect changes to libcpu.
+
+2004-01-20	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* wrapup/Makefile.am: Reflect changes to libcpu.
+
+2004-01-14	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: Re-add dirstamps to PRE/TMPINSTALL_FILES.
+	Add PRE/TMPINSTALL_FILES to CLEANFILES.
+	* startup/Makefile.am: Ditto.
+
+2004-01-07	Joel Sherrill <joel@OARcorp.com>
+
+	* times, console/sci.c: Remove efi68k and efi332 references as they are
+	no longer in the tree.
+
+2004-01-07	Joel Sherrill <joel@OARcorp.com>
+
+	* timer/timer.c: Remove efi68k and efi332 references as they are no
+	longer in the tree.
+
+2004-01-07	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* start/Makefile.am: Remove.
+	* Makefile.am: Merge-in start/Makefile.am.
+	* configure.ac: Reflect changes above.
+
+2004-01-05	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* wrapup/Makefile.am: Eliminate $(LIB). 
+	Use noinst_DATA to trigger building libbsp.a.
+
+2003-12-13	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* start/Makefile.am: s,${PROJECT_RELEASE}/lib,$(PROJECT_LIB),g.
+	* startup/Makefile.am: s,${PROJECT_RELEASE}/lib,$(PROJECT_LIB),g.
+
+2003-12-12	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* start/Makefile.am: Use mkdir_p. Remove dirs from PRE/TMPINSTALL_FILES.
+	* startup/Makefile.am: Use mkdir_p. Remove dirs from PRE/TMPINSTALL_FILES.
+
+2003-12-12	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* configure.ac: Require automake >= 1.8, autoconf >= 2.59.
+
+2003-12-10	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* start/Makefile.am: Misc cleanups and fixes.
+	* startup/Makefile.am: Misc cleanups and fixes.
+	* wrapup/Makefile.am: Misc cleanups and fixes.
+
+2003-12-03	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: Add preinstallation dirstamp support.
+	* clock/Makefile.am: Cosmetics.
+	* console/Makefile.am: Cosmetics.
+	* spurious/Makefile.am: Cosmetics.
+	* startup/Makefile.am: Cosmetics.
+	* timer/Makefile.am: Cosmetics.
+	* wrapup/Makefile.am: Cosmetics.
+
+2003-12-02	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* clock/Makefile.am: Remove all-local: $(ARCH).
+	* console/Makefile.am: Remove all-local: $(ARCH).
+	* spurious/Makefile.am: Remove all-local: $(ARCH).
+	* start/Makefile.am: Remove all-local: $(ARCH).
+	* startup/Makefile.am: Remove all-local: $(ARCH).
+	* timer/Makefile.am: Remove all-local: $(ARCH).
+	* wrapup/Makefile.am: Remove all-local: $(ARCH).
+
+2003-09-29	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: Merge-in include/Makefile.am.
+	Reflect changes to bsp.am.
+	* include/Makefile.am: Remove.
+	* configure.ac: Reflect changes above.
+
+2003-09-19	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* bsp_specs: Remove *lib:.
+
+2003-09-15	Joel Sherrill <joel@OARcorp.com>
+
+	PR 483/bsps
+	* startup/bspstart.c, startup/start_c.c: Spurious interrupt handlers
+	cannot be installed until RTEMS has initialized the vector table.
+
+2003-09-04	Joel Sherrill <joel@OARcorp.com>
+
+	* clock/ckinit.c, console/console.c, include/bsp.h, misc/interr.c,
+	spurious/spinit.c, startup/bspclean.c, startup/bspstart.c,
+	timer/timer.c: URL for license changed.
+
+2003-08-20	Joel Sherrill <joel@OARcorp.com>
+
+	* console/console.c: Correct copyright statements.
+
+2003-08-18	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: Reflect having moved aclocal/.
+
+2003-08-16	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: Reflect having moved automake/.
+	* clock/Makefile.am: Reflect having moved automake/.
+	* console/Makefile.am: Reflect having moved automake/.
+	* include/Makefile.am: Reflect having moved automake/.
+	* spurious/Makefile.am: Reflect having moved automake/.
+	* start/Makefile.am: Reflect having moved automake/.
+	* startup/Makefile.am: Reflect having moved automake/.
+	* timer/Makefile.am: Reflect having moved automake/.
+	* wrapup/Makefile.am: Reflect having moved automake/.
+
+2003-08-11	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	PR 452/bsps
+	* startup/Makefile.am: Remove USE_INIT_FINI.
+
+2003-08-11	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* configure.ac: Use rtems-bugs@rtems.com as bug report email address.
+
+2003-08-06	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	PR 445/bsps
+	* bsp_specs: Remove -D__embedded__ -Asystem(embedded) from cpp.
+	Remove cpp, old_cpp (now unused).
+
+2003-03-06	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* configure.ac: Remove AC_CONFIG_AUX_DIR.
+
+2003-02-11	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* configure.ac: AM_INIT_AUTOMAKE([1.7.2]).
+
+2003-02-11	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* configure.ac: AC_PREREQ(2.57).
+
+2003-01-20	Duane Gustavus <duane@unt.edu>
+
+	* console/sci.c, include/mrm332.h, startup/linkcmds,
+	startup/linkcmds_ROM: Various updates to make this run properly
+	from ROM.
+
+2002-12-20	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* clock/Makefile.am: Don't include @RTEMS_BSP@.cfg.
+	* console/Makefile.am: Don't include @RTEMS_BSP@.cfg.
+	* spurious/Makefile.am: Don't include @RTEMS_BSP@.cfg.
+	* start/Makefile.am: Don't include @RTEMS_BSP@.cfg.
+	* startup/Makefile.am: Don't include @RTEMS_BSP@.cfg.
+	* timer/Makefile.am: Don't include @RTEMS_BSP@.cfg.
+
+2002-12-12	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* start/Makefile.am: Use install-data-local to install startfile.
+
+2002-12-10	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* wrapup/Makefile.am: Don't include @RTEMS_BSP@.cfg.
+
+2002-11-04	Joel Sherrill <joel@OARcorp.com>
+
+	* console/sci.c, spurious/spinit.c: Removed warnings.
+
+2002-10-21	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* .cvsignore: Reformat.
+	Add autom4te*cache.
+	Remove autom4te.cache.
+
+2002-09-08	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* Makefile.am: ACLOCAL_AMFLAGS = -I ../../../../../../aclocal.
+
+2002-08-21	Joel Sherrill <joel@OARcorp.com>
+
+	* wrapup/Makefile.am: PR217 required that the idle task be moved to
+	libcpu so it could be more acutely aware of the CPU model.  This
+	file was modified to pick up the idle task from there.
+
+2002-08-21	Joel Sherrill <joel@OARcorp.com>
+
+	* bsp_specs: Added support for -nostdlibs.
+
+2002-08-11	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* clock/Makefile.am: Use .$(OBJEXT) instead of .o.
+ 	* console/Makefile.am: Use .$(OBJEXT) instead of .o.
+ 	* spurious/Makefile.am: Use .$(OBJEXT) instead of .o.
+ 	* start/Makefile.am: Use .$(OBJEXT) instead of .o.
+ 	* startup/Makefile.am: Use .$(OBJEXT) instead of .o.
+ 	* timer/Makefile.am: Use .$(OBJEXT) instead of .o.
+ 	* wrapup/Makefile.am: Use .$(OBJEXT) instead of .o.
+
+2002-08-05	Joel Sherrill <joel@OARcorp.com>
+
+	* Per PR260 eliminate use of make-target-options.  This impacted
+	RTEMS allowing a distinction between the CPU32 and CPU32+ in the
+	SuperCore and required that the m68k optimized memcpy be moved
+	to libcpu.
+	* wrapup/Makefile.am: Pick up memcpy.o from libcpu.
+
+2002-07-21	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* start/Makefile.am: Eliminate PGM.
+	Add bsplib_DATA = $(PROJECT_RELEASE)/lib/start$(LIB_VARIANT).o.
+
+2002-07-19	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* startup/Makefile.am: Add bsplib_DATA = linkcmds linkcmds_ROM.
+
+2002-07-04	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* wrapup/Makefile.am: Eliminate TMPINSTALL_FILES.
+	Remove $(OBJS) from all-local.
+
+2002-06-29	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* wrapup/Makefile.am: Remove preinstallation of libbsp.a,
+
+2001-05-09	Joel Sherrill <joel@OARcorp.com>
+
+	* startup/linkcmds: In support of gcc 3.1, added one of more
+	of the sections .jcr, .rodata*, .data.*, .gnu.linkonce.s2.*,
+	.gnu.linkonce.sb2.*, and .gnu.linkonce.s.*.  Spacing corrections
+	and direction of segments to memory regions may also have been
+	addressed.  This was a sweep across all BSPs.
+ 
+2002-03-27	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* configure.ac:
+	AC_INIT(package,_RTEMS_VERSION,_RTEMS_BUGS).
+	AM_INIT_AUTOMAKE([no-define foreign 1.6]).
+	* clock/Makefile.am: Remove AUTOMAKE_OPTIONS.
+	* Makefile.am: Remove AUTOMAKE_OPTIONS.
+	* console/Makefile.am: Remove AUTOMAKE_OPTIONS.
+	* include/Makefile.am: Remove AUTOMAKE_OPTIONS.
+	* spurious/Makefile.am: Remove AUTOMAKE_OPTIONS.
+	* start/Makefile.am: Remove AUTOMAKE_OPTIONS.
+	* startup/Makefile.am: Remove AUTOMAKE_OPTIONS.
+	* timer/Makefile.am: Remove AUTOMAKE_OPTIONS.
+	* wrapup/Makefile.am: Remove AUTOMAKE_OPTIONS.
+
+2002-02-28	Mike Panetta <ahuitzot@mindspring.com>
+
+	* console/sci.c, console/sci.h, 
+	console/console.c: Added new SCI driver.
+	* start/start.c: Removed file.
+	* start/start.S: New file, the asm portion of the updated start code.
+	* start/configure.am: Added start.S, removed start.c
+	* startup/start_c.c: New file, the C portion of the updated start code. 	Contains most of the code that was in the old start.c. 
+	* startup/configure.am: Added start_c.c to C_FILES.
+	* include/bsp.h: Added include <rtems/bspIo.h>
+
+2001-11-30	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* configure.ac: Introduce RTEMS_BSP_CONFIGURE.
+
+2001-10-11	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* .cvsignore: Add autom4te.cache for autoconf > 2.52.
+	* configure.in: Remove.
+	* configure.ac: New file, generated from configure.in by autoupdate.
+
+2001-09-27	Joel Sherrill <joel@OARcorp.com>
+
+	* include/bsp.h: Renamed delay() to rtems_bsp_delay().
+
+2001-09-27	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* include/Makefile.am: Use 'TMPINSTALL_FILES ='.
+
+2001-05-26	Ralf Corsepius <corsepiu@faw.uni-ulm.de>
+
+	* configure.in: Add bspopts.h.
+	* include/.cvsignore: Add bspopts.h*, stamp-h*.
+	* include/Makefile.am: Use *_HEADERS instead of *H_FILES.
+	* include/bsp.h: Include bspopts.h.
+
+2001-05-25	Joel Sherrill <joel@OARcorp.com>
+
+ 	* clock/Makefile.am, console/Makefile.am, spurious/Makefile.am,
+	start/Makefile.am, startup/Makefile.am, timer/Makefile.am,
+	wrapup/Makefile.am: Modified to include compile.am.
+	* startup/bspstart.c: Removed include of <libcsupport.h>
+
+2000-05-25	Matt Cross <profesor@gweep.net>
+
+	* New MRM332 BSP for the Mini RoboMind board based
+	on the 68332 microcontroller designed and build by Mark
+	Castelluccio.  For details on the MRM see http://www.robominds.com.
+	* .cvsignore, ChangeLog Makefile.am, README, bsp_specs,
+	clock/.cvsignore, clock/Makefile.am, clock/ckinit.c, configure.in,
+	console/.cvsignore, console/Makefile.am, console/console.c,
+	include/.cvsignore, include/Makefile.am, include/bsp.h,
+	include/mrm332.h, misc/dotests, misc/gdbinit68, misc/interr.c,
+	spurious/.cvsignore, spurious/Makefile.am, spurious/spinit.c,
+	start/.cvsignore, start/Makefile.am, start/start.c, startup/.cvsignore,
+	startup/Makefile.am, startup/bspclean.c, startup/bspstart.c,
+	startup/except_vect_332_ROM.S, startup/linkcmds, startup/linkcmds_ROM,
+	timer/.cvsignore, timer/Makefile.am, timer/timer.c, times,
+	wrapup/.cvsignore, wrapup/Makefile.am: Initial files.
+
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/startup/bspclean.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/startup/bspclean.c
@@ -0,0 +1,27 @@
+/*  bsp_cleanup()
+ *
+ *  This routine cleans up in the sense that it places the board
+ *  in a safe state and flushes the I/O buffers before exiting.
+ *
+ *  INPUT:  NONE
+ *
+ *  OUTPUT: NONE
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: bspclean.c,v 1.4 2004/04/21 10:42:52 ralf Exp $
+ */
+
+#include <bsp.h>
+
+void bsp_cleanup(void)
+{
+    /* interrupt driven stdio must be flushed */
+    _CPU_ISR_Set_level( 7 );
+    //_UART_flush();
+}
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/timer/timer.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/timer/timer.c
@@ -0,0 +1,81 @@
+/*  Timer_init()
+ *
+ *  This routine is not implemented for this BSP.
+ *
+ *  Input parameters:  NONE
+ *
+ *  Output parameters:  NONE
+ *
+ *  NOTE: It is important that the timer start/stop overhead be
+ *        determined when porting or modifying this code.
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: timer.c,v 1.6 2004/04/21 16:01:35 ralf Exp $
+ */
+
+#include <bsp.h>
+
+rtems_boolean Timer_driver_Find_average_overhead;
+
+extern rtems_isr Clock_isr();
+
+void Timer_initialize( void )
+{
+}
+
+/*
+ *  The following controls the behavior of Read_timer().
+ *
+ *  FIND_AVG_OVERHEAD *  instructs the routine to return the "raw" count.
+ *
+ *  AVG_OVEREHAD is the overhead for starting and stopping the timer.  It
+ *  is usually deducted from the number returned.
+ *
+ *  LEAST_VALID is the lowest number this routine should trust.  Numbers
+ *  below this are "noise" and zero is returned.
+ */
+
+#define AVG_OVERHEAD      0  /* It typically takes X.X microseconds */
+                             /* (Y countdowns) to start/stop the timer. */
+                             /* This value is in microseconds. */
+#define LEAST_VALID       1  /* Don't trust a clicks value lower than this */
+
+/*
+ * Return timer value in 1/2-microsecond units
+ */
+int Read_timer( void )
+{
+  uint32_t         total;
+  total = 0;
+
+  if ( Timer_driver_Find_average_overhead == 1 )
+    return total;          /* in XXX microsecond units */
+
+  if ( total < LEAST_VALID )
+    return 0;            /* below timer resolution */
+
+  return (total - AVG_OVERHEAD);
+}
+
+/*
+ *  Empty function call used in loops to measure basic cost of looping
+ *  in Timing Test Suite.
+ */
+
+rtems_status_code Empty_function(void)
+{
+    return RTEMS_SUCCESSFUL;
+}
+
+void Set_find_average_overhead(
+  rtems_boolean find_flag
+)
+{
+  Timer_driver_Find_average_overhead = find_flag;
+}
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/clock/ckinit.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/clock/ckinit.c
@@ -0,0 +1,128 @@
+/*  Clock_init()
+ *
+ *  This routine initailizes the periodic interrupt timer on
+ *  the Motorola 68332.
+ *
+ *  Input parameters:  NONE
+ *
+ *  Output parameters:  NONE
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: ckinit.c,v 1.5 2004/04/21 10:42:52 ralf Exp $
+ */
+
+#include <stdlib.h>
+#include <bsp.h>
+#include <rtems/libio.h>
+#include <mrm332.h>
+
+#define CLOCK_VECTOR   MRM_PIV
+
+uint32_t         Clock_isrs;        /* ISRs until next tick */
+volatile uint32_t         Clock_driver_ticks;
+                                    /* ticks since initialization */
+rtems_isr_entry  Old_ticker;
+
+void Clock_exit( void );
+
+/*
+ * These are set by clock driver during its init
+ */
+
+rtems_device_major_number rtems_clock_major = ~0;
+rtems_device_minor_number rtems_clock_minor;
+
+rtems_isr Clock_isr(rtems_vector_number vector)
+{
+  Clock_driver_ticks += 1;
+
+  if ( Clock_isrs == 1 ) {
+    rtems_clock_tick();
+    Clock_isrs = BSP_Configuration.microseconds_per_tick / 1000;
+  }
+  else
+    Clock_isrs -= 1;
+}
+
+void Install_clock(
+  rtems_isr_entry clock_isr
+)
+{
+  Clock_driver_ticks = 0;
+  Clock_isrs = BSP_Configuration.microseconds_per_tick / 1000;
+
+  Old_ticker = (rtems_isr_entry) set_vector( clock_isr, CLOCK_VECTOR, 1 );
+
+  /* enable 1mS interrupts */
+  *PITR = (unsigned short int)( SAM(0x09,0,PITM) );/* load counter */
+  *PICR = (unsigned short int)                     /* enable interrupt */
+    ( SAM(ISRL_PIT,8,PIRQL) | SAM(CLOCK_VECTOR,0,PIV) );
+
+  atexit( Clock_exit );
+}
+
+void Clock_exit( void )
+{
+  /* shutdown the periodic interrupt */
+  *PICR = (unsigned short int)
+    ( SAM(0,8,PIRQL) | SAM(CLOCK_VECTOR,0,PIV) );
+  /*     ^^ zero disables interrupt */
+
+  /* do not restore old vector */
+}
+
+rtems_device_driver Clock_initialize(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void *pargp
+)
+{
+  Install_clock( Clock_isr );
+
+  /*
+   * make major/minor avail to others such as shared memory driver
+   */
+
+  rtems_clock_major = major;
+  rtems_clock_minor = minor;
+
+  return RTEMS_SUCCESSFUL;
+}
+
+rtems_device_driver Clock_control(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void *pargp
+)
+{
+    uint32_t         isrlevel;
+    rtems_libio_ioctl_args_t *args = pargp;
+
+    if (args == 0)
+        goto done;
+
+    /*
+     * This is hokey, but until we get a defined interface
+     * to do this, it will just be this simple...
+     */
+
+    if (args->command == rtems_build_name('I', 'S', 'R', ' '))
+    {
+        Clock_isr(CLOCK_VECTOR);
+    }
+    else if (args->command == rtems_build_name('N', 'E', 'W', ' '))
+    {
+      rtems_interrupt_disable( isrlevel );
+       (void) set_vector( args->buffer, CLOCK_VECTOR, 1 );
+      rtems_interrupt_enable( isrlevel );
+    }
+
+done:
+    return RTEMS_SUCCESSFUL;
+}
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/misc/gdbinit68
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/misc/gdbinit68
@@ -0,0 +1,16 @@
+#
+#  $Id: gdbinit68,v 1.1 2001/05/25 16:28:46 joel Exp $
+#
+echo Setting up the environment for mrm debuging.\n
+
+target bdm /dev/bdmcpu320
+bdm_setdelay 1000
+bdm_autoreset on
+set remotecache off
+bdm_timetocomeup 0
+bdm_init
+bdm_reset
+set $sfc=5
+set $dfc=5
+r
+q
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/configure.ac
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/configure.ac
@@ -0,0 +1,20 @@
+## Process this file with autoconf to produce a configure script.
+## 
+## $Id: configure.ac,v 1.14 2004/09/24 06:32:09 ralf Exp $
+
+AC_PREREQ(2.59)
+AC_INIT([rtems-c-src-lib-libbsp-m68k-mrm332],[_RTEMS_VERSION],[rtems-bugs@rtems.com])
+AC_CONFIG_SRCDIR([bsp_specs])
+RTEMS_TOP(../../../../../..)
+
+RTEMS_CANONICAL_TARGET_CPU
+AM_INIT_AUTOMAKE([no-define nostdinc foreign 1.9])
+RTEMS_BSP_CONFIGURE
+
+RTEMS_PROG_CC_FOR_TARGET
+RTEMS_CANONICALIZE_TOOLS
+RTEMS_PROG_CCAS
+
+# Explicitly list all Makefiles here
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/README
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/README
@@ -0,0 +1,24 @@
+#
+#  $Id: README,v 1.1 2001/05/25 16:28:46 joel Exp $
+#
+
+Description: mrm332
+============
+CPU: MC68332 @16 or 25MHz
+RAM: 32k or 512k
+ROM: 512k flash
+
+   The Mini RoboMind is a small board based on the 68332 microcontroller
+designed and build by Mark Castelluccio.  For details, see:
+
+        http://www.robominds.com
+
+   This BSP was ported from the efi332 BSP by Matt Cross (profesor@gweep.net),
+the efi332 BSP was written by John S Gwynne.
+
+TODO:
+=====
+- integrate the interrupt driven stdin/stdout into RTEMS to (a) reduce
+  the interrupt priority and (2) to prevent it from blocking.
+- add a timer driver for the tmtest set.
+
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/Makefile.am
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/Makefile.am
@@ -0,0 +1,124 @@
+##
+## $Id: Makefile.am,v 1.21 2005/01/07 06:54:44 ralf Exp $
+##
+
+ACLOCAL_AMFLAGS = -I ../../../../aclocal
+
+include $(top_srcdir)/../../../../automake/compile.am
+include $(top_srcdir)/../../bsp.am
+
+dist_project_lib_DATA = bsp_specs
+
+include_HEADERS = include/bsp.h
+include_HEADERS += include/tm27.h
+
+nodist_include_HEADERS = include/bspopts.h
+DISTCLEANFILES = include/bspopts.h
+
+noinst_PROGRAMS =
+
+include_HEADERS += include/mrm332.h
+nodist_include_HEADERS += ../../shared/include/coverhd.h
+
+EXTRA_DIST = times
+
+EXTRA_DIST += start/start.S
+start.$(OBJEXT): start/start.S
+	$(CPPASCOMPILE) -DASM -o $@ -c $<
+
+project_lib_DATA = start.$(OBJEXT)
+
+dist_project_lib_DATA += startup/linkcmds startup/linkcmds_ROM
+
+noinst_PROGRAMS += startup.rel
+startup_rel_SOURCES = startup/start_c.c ../../shared/bsplibc.c \
+    ../../shared/bsppost.c startup/bspstart.c startup/bspclean.c \
+    ../../shared/bootcard.c ../../m68k/shared/m68kpretaskinghook.c \
+    ../../shared/main.c ../../shared/sbrk.c ../../m68k/shared/setvec.c \
+    ../../shared/gnatinstallhandler.c startup/except_vect_332_ROM.S
+startup_rel_CPPFLAGS = $(AM_CPPFLAGS)
+startup_rel_LDFLAGS = $(RTEMS_RELLDFLAGS)
+
+noinst_PROGRAMS += clock.rel
+clock_rel_SOURCES = clock/ckinit.c
+clock_rel_CPPFLAGS = $(AM_CPPFLAGS)
+clock_rel_LDFLAGS = $(RTEMS_RELLDFLAGS)
+
+noinst_PROGRAMS += console.rel
+console_rel_SOURCES = console/console.c console/sci.c console/sci.h
+console_rel_CPPFLAGS = $(AM_CPPFLAGS)
+console_rel_LDFLAGS = $(RTEMS_RELLDFLAGS)
+
+noinst_PROGRAMS += spurious.rel
+spurious_rel_SOURCES = spurious/spinit.c
+spurious_rel_CPPFLAGS = $(AM_CPPFLAGS)
+spurious_rel_LDFLAGS = $(RTEMS_RELLDFLAGS)
+
+noinst_PROGRAMS += timer.rel
+timer_rel_SOURCES = timer/timer.c
+timer_rel_CPPFLAGS = $(AM_CPPFLAGS)
+timer_rel_LDFLAGS = $(RTEMS_RELLDFLAGS)
+
+noinst_LIBRARIES = libbsp.a
+libbsp_a_SOURCES =
+libbsp_a_LIBADD = startup.rel clock.rel console.rel spurious.rel timer.rel
+libbsp_a_LIBADD += ../../../libcpu/@RTEMS_CPU@/shared/cache.rel \
+    ../../../libcpu/@RTEMS_CPU@/shared/misc.rel
+
+all-local: $(PREINSTALL_FILES) $(TMPINSTALL_FILES)
+
+PREINSTALL_DIRS =
+PREINSTALL_FILES =
+TMPINSTALL_FILES =
+
+$(PROJECT_INCLUDE)/$(dirstamp):
+	@$(mkdir_p) $(PROJECT_INCLUDE)
+	@: > $(PROJECT_INCLUDE)/$(dirstamp)
+PREINSTALL_DIRS += $(PROJECT_INCLUDE)/$(dirstamp)
+
+$(PROJECT_LIB)/$(dirstamp):
+	@$(mkdir_p) $(PROJECT_LIB)
+	@: > $(PROJECT_LIB)/$(dirstamp)
+PREINSTALL_DIRS += $(PROJECT_LIB)/$(dirstamp)
+
+$(PROJECT_LIB)/bsp_specs: bsp_specs $(PROJECT_LIB)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_LIB)/bsp_specs
+PREINSTALL_FILES += $(PROJECT_LIB)/bsp_specs
+
+$(PROJECT_INCLUDE)/bsp.h: include/bsp.h $(PROJECT_INCLUDE)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/bsp.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/bsp.h
+
+$(PROJECT_INCLUDE)/tm27.h: include/tm27.h $(PROJECT_INCLUDE)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/tm27.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/tm27.h
+
+$(PROJECT_INCLUDE)/bspopts.h: include/bspopts.h $(PROJECT_INCLUDE)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/bspopts.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/bspopts.h
+
+$(PROJECT_INCLUDE)/mrm332.h: include/mrm332.h $(PROJECT_INCLUDE)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/mrm332.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/mrm332.h
+
+$(PROJECT_INCLUDE)/coverhd.h: ../../shared/include/coverhd.h $(PROJECT_INCLUDE)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/coverhd.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/coverhd.h
+
+$(PROJECT_LIB)/start.$(OBJEXT): start.$(OBJEXT) $(PROJECT_LIB)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_LIB)/start.$(OBJEXT)
+TMPINSTALL_FILES += $(PROJECT_LIB)/start.$(OBJEXT)
+
+$(PROJECT_LIB)/linkcmds: startup/linkcmds $(PROJECT_LIB)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_LIB)/linkcmds
+PREINSTALL_FILES += $(PROJECT_LIB)/linkcmds
+
+$(PROJECT_LIB)/linkcmds_ROM: startup/linkcmds_ROM $(PROJECT_LIB)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_LIB)/linkcmds_ROM
+PREINSTALL_FILES += $(PROJECT_LIB)/linkcmds_ROM
+
+CLEANFILES = $(PREINSTALL_FILES)
+DISTCLEANFILES += $(PREINSTALL_DIRS)
+CLEANFILES += $(TMPINSTALL_FILES)
+
+include $(top_srcdir)/../../../../automake/local.am
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/console/sci.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/console/sci.c
@@ -0,0 +1,1620 @@
+/*****************************************************************************
+* File:     sci.c
+*
+* Desc:     This file contains the console IO routines for the SCI port.
+*           There are two interfaces in this module. One is for the rtems
+*           termios/console code and the other is a device driver interface.
+*           This module works together with the termio module which is
+*           sometimes referred to as the "line disciplines" which implements
+*           terminal i/o processing like tabs, backspaces, and newlines.
+*           The rtems printf uses interrupt io and the rtems printk routine
+*           uses polled io which is better for debugging.
+*
+* Index:    Documentation
+*           Section A  - Include Files
+*           Section B  - Manifest Constants
+*           Section C  - External Data
+*           Section D  - External Functions
+*           Section E  - Local Functions
+*           Section F  - Local Variables
+*           Section G  - A circular data buffer for rcv chars
+*           Section H  - RTEMS termios callbacks for the interrupt api
+*           Section I  - RTEMS termios callbacks for the polled api
+
+*           Section 0  - Miscellaneous routines
+*           Section 1  - Routines to manipulate the circular buffer
+*           Section 2  - Interrupt based entry points for the termios module
+*           Section 3  - Polling based entry points for the termios module
+*           Section 4  - Device driver public api entry points
+*           Section 5  - Hardware level routines
+*           Section 6  - Testing and debugging code
+*
+* Refer:    Motorola QSM Reference Manual - Chapter 5 - SCI sub-module
+*
+* Note:     See bsp.h,confdefs.h,system.h for installing drivers into RTEMS.
+*
+* $Id: sci.c,v 1.10 2005/01/05 18:12:35 ralf Exp $
+*
+*****************************************************************************/
+
+
+/*****************************************************************************
+  Compiler Options for the incurably curious
+*****************************************************************************/
+
+/*
+/opt/rtems/bin/m68k-rtems-gcc
+    --pipe                                      # use pipes, not tmp files
+    -B../../../../../../../../opti/lib/         # where the library is
+    -specs bsp_specs                            # ???
+    -qrtems                                     # ???
+    -g                                          # add debugging info
+    -Wall                                       # issue all warnings
+    -fasm                                       # allow inline asm???
+    -DCONSOLE_SCI                               # for opti-r box/rev b proto
+    -mcpu32                                     # machine = motorola cpu 32
+    -c                                          # compile, don't link
+    -O4                                         # max optimization
+    -fomit-frame-pointer                        # stack frames are optional
+    -o o-optimize/sci.o                         # the object file
+    ../../../../../../../../../rtems/c/src/lib/libbsp/m68k/opti/console/sci.c
+*/
+
+
+/*****************************************************************************
+  Overview of serial port console terminal input/output
+*****************************************************************************/
+
+/*
+   +-----------+                               +---------+
+   |    app    |                               |   app   |
+   +-----------+                               +---------+
+         |                                          |
+         | (printf,scanf,etc.)                      |
+         v                                          |
+   +-----------+                                    |
+   |    libc   |                                    |
+   +-----------+                                    |
+         |                                          |
+         |                                          |
+         |     (open,close,read,write,ioctl)        |
+   ======|==========================================|========================
+         | /dev/console                             | /dev/sci
+         | (stdin,stdout,stderr)                    |
+   ======|==========================================|========================
+         |                                          |
+         |                                          |
+         v                                          v
+   +-----------+         +-----------+         +---------+
+   |  console  |  <--->  |  termios  |  <--->  |   sci   |
+   |  driver   |         |  module   |         |  driver |
+   +-----------+         +-----------+         +---------+
+                                                    |
+                                                    |
+                                                    v
+                                               +---------+
+                                               |         |
+                                               |  uart   |
+                                               |         |
+                                               +---------+
+*/
+
+
+/*****************************************************************************
+  Section A - Include Files
+*****************************************************************************/
+
+#include <rtems.h>
+#include <bsp.h>
+#include <rtems/bspIo.h>
+#include <stdio.h>
+#include <rtems/libio.h>
+#include <libchip/serial.h>
+#include <libchip/sersupp.h>
+#include "sci.h"
+//#include "../misc/include/cpu332.h"
+
+
+/*****************************************************************************
+  Section B - Manifest Constants
+*****************************************************************************/
+
+#define SCI_MINOR       0                   // minor device number
+
+// IMPORTANT - if the device driver api is opened, it means the sci is being
+// used for direct hardware access, so other users (like termios) get ignored
+
+#define DRIVER_CLOSED   0                   // the device driver api is closed
+#define DRIVER_OPENED   1                   // the device driver api is opened
+
+// system clock definitions, i dont have documentation on this...
+
+#if 0 // Not needed, this is provided in mrm332.h
+#define XTAL            32768.0		        // crystal frequency in Hz
+#define NUMB_W          0			        // system clock parameters
+#define NUMB_X          1
+//efine NUMB_Y          0x38		        // for 14.942 Mhz
+#define NUMB_Y          0x3F			    // for 16.777 Mhz
+
+#define SYS_CLOCK       (XTAL * 4.0 * (NUMB_Y+1) * (1 << (2 * NUMB_W + NUMB_X)))
+
+#endif
+
+
+/*****************************************************************************
+  Section C - External Data
+*****************************************************************************/
+
+
+
+/*****************************************************************************
+  Section D - External Functions
+*****************************************************************************/
+
+
+
+/*****************************************************************************
+  Section E - Local Functions
+*****************************************************************************/
+
+void SCI_output_char(char c);
+
+rtems_isr SciIsr( rtems_vector_number vector );         // interrupt handler
+
+const rtems_termios_callbacks * SciGetTermiosHandlers( int32_t   polled );
+
+rtems_device_driver SciInitialize ();                   // device driver api
+rtems_device_driver SciOpen ();                         // device driver api
+rtems_device_driver SciClose ();                        // device driver api
+rtems_device_driver SciRead ();                         // device driver api
+rtems_device_driver SciWrite ();                        // device driver api
+rtems_device_driver SciControl ();                      // device driver api
+
+int32_t   SciInterruptOpen();                            // termios api
+int32_t   SciInterruptClose();                           // termios api
+int32_t   SciInterruptWrite();                           // termios api
+
+int32_t   SciSetAttributes();                            // termios api
+
+int32_t   SciPolledOpen();                               // termios api
+int32_t   SciPolledClose();                              // termios api
+int32_t   SciPolledRead();                               // termios api
+int32_t   SciPolledWrite();                              // termios api
+
+static void SciSetBaud(uint32_t   rate);                // hardware routine
+static void SciSetDataBits(uint16_t   bits);            // hardware routine
+static void SciSetParity(uint16_t   parity);            // hardware routine
+
+static void inline SciDisableAllInterrupts( void );     // hardware routine
+static void inline SciDisableTransmitInterrupts( void );// hardware routine
+static void inline SciDisableReceiveInterrupts( void ); // hardware routine
+
+static void inline SciEnableTransmitInterrupts( void ); // hardware routine
+static void inline SciEnableReceiveInterrupts( void );  // hardware routine
+
+static void inline SciDisableReceiver( void );          // hardware routine
+static void inline SciDisableTransmitter( void );       // hardware routine
+
+static void inline SciEnableReceiver( void );           // hardware routine
+static void inline SciEnableTransmitter( void );        // hardware routine
+
+void SciWriteCharWait  ( uint8_t);                   // hardware routine
+void SciWriteCharNoWait( uint8_t);                   // hardware routine
+
+uint8_t   inline SciCharAvailable( void );              // hardware routine
+
+uint8_t   inline SciReadCharWait( void );               // hardware routine
+uint8_t   inline SciReadCharNoWait( void );             // hardware routine
+
+void SciSendBreak( void );                              // test routine
+
+static int8_t   SciRcvBufGetChar();                      // circular rcv buf
+static void    SciRcvBufPutChar( uint8_t);           // circular rcv buf
+//atic void    SciRcvBufFlush( void );                  // circular rcv buf
+
+void SciUnitTest();                                     // test routine
+void SciPrintStats();                                   // test routine
+
+
+/*****************************************************************************
+  Section F - Local Variables
+*****************************************************************************/
+
+static struct rtems_termios_tty *SciTermioTty;
+
+static uint8_t   SciInited = 0;             // has the driver been inited
+
+static uint8_t   SciOpened;                 // has the driver been opened
+
+static uint8_t   SciMajor;                  // major device number
+
+static uint16_t   SciBaud;                  // current value in baud register
+
+static uint32_t   SciBytesIn  = 0;          // bytes received
+static uint32_t   SciBytesOut = 0;          // bytes transmitted
+
+static uint32_t   SciErrorsParity  = 0;     // error counter
+static uint32_t   SciErrorsNoise   = 0;     // error counter
+static uint32_t   SciErrorsFraming = 0;     // error counter
+static uint32_t   SciErrorsOverrun = 0;     // error counter
+
+#if defined(CONSOLE_SCI)
+
+// this is what rtems printk uses to do polling based output
+
+BSP_output_char_function_type      BSP_output_char = SCI_output_char;
+BSP_polling_getchar_function_type  BSP_poll_char   = NULL;
+
+#endif
+
+// cvs id string so you can use the unix ident command on the object
+
+#ifdef ID_STRINGS
+static const char SciIdent[]="$Id: sci.c,v 1.10 2005/01/05 18:12:35 ralf Exp $";
+#endif
+
+
+/*****************************************************************************
+  Section G - A circular buffer for rcv chars when the driver interface is used.
+*****************************************************************************/
+
+// it is trivial to wrap your buffer pointers when size is a power of two
+
+#define SCI_RCV_BUF_SIZE        256         // must be a power of 2 !!!
+
+// if someone opens the sci device using the device driver interface,
+// then the receive data interrupt handler will put characters in this buffer
+// instead of sending them up to the termios module for the console
+
+static uint8_t   SciRcvBuffer[SCI_RCV_BUF_SIZE];
+
+static uint8_t   SciRcvBufPutIndex = 0;     // array index to put in next char
+
+static uint8_t   SciRcvBufGetIndex = 0;     // array index to take out next char
+
+static uint16_t  SciRcvBufCount = 0;        // how many bytes are in the buffer
+
+
+
+/*****************************************************************************
+  Section H - RTEMS termios callbacks for the interrupt version of the driver
+*****************************************************************************/
+
+static const rtems_termios_callbacks SciInterruptCallbacks =
+{
+    SciInterruptOpen,                       // first open
+    SciInterruptClose,                      // last close
+    NULL,                                   // polled read (not required)
+    SciInterruptWrite,                      // write
+    SciSetAttributes,                       // set attributes
+    NULL,                                   // stop remote xmit
+    NULL,                                   // start remote xmit
+    TRUE                                    // output uses interrupts
+};
+
+/*****************************************************************************
+  Section I - RTEMS termios callbacks for the polled version of the driver
+*****************************************************************************/
+
+static const rtems_termios_callbacks SciPolledCallbacks =
+{
+    SciPolledOpen,                          // first open
+    SciPolledClose,                         // last close
+    SciPolledRead,                          // polled read
+    SciPolledWrite,                         // write
+    SciSetAttributes,                       // set attributes
+    NULL,                                   // stop remote xmit
+    NULL,                                   // start remote xmit
+    FALSE                                   // output uses interrupts
+};
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+//                              SECTION 0
+//                        MISCELLANEOUS ROUTINES
+//
+/////////////////////////////////////////////////////////////////////////////
+
+/****************************************************************************
+* Func:     SCI_output_char
+* Desc:     used by rtems printk function to send a char to the uart
+* Inputs:   the character to transmit
+* Outputs:  none
+* Errors:   none
+* Scope:    public
+****************************************************************************/
+
+void SCI_output_char(char c)
+{
+//  ( minor device number, pointer to the character, length )
+
+    SciPolledWrite( SCI_MINOR, &c, 1);
+
+    return;
+}
+
+
+/****************************************************************************
+* Func:     SciGetTermiosHandlers
+* Desc:     returns a pointer to the table of serial io functions
+*           this is called from console_open with polled set to false
+* Inputs:   flag indicating whether we want polled or interrupt driven io
+* Outputs:  pointer to function table
+* Errors:   none
+* Scope:    public
+****************************************************************************/
+
+const rtems_termios_callbacks * SciGetTermiosHandlers( int32_t   polled )
+{
+    if ( polled )
+    {
+        return &SciPolledCallbacks;             // polling based
+    }
+    else
+    {
+        return &SciInterruptCallbacks;          // interrupt driven
+    }
+}
+
+
+/****************************************************************************
+* Func:     SciIsr
+* Desc:     interrupt handler for serial communications interface
+* Inputs:   vector number - unused
+* Outputs:  none
+* Errors:   none
+* Scope:    public API
+****************************************************************************/
+
+rtems_isr SciIsr( rtems_vector_number vector )
+{
+    uint8_t   ch;
+
+    if ( (*SCSR) & SCI_ERROR_PARITY  )   SciErrorsParity  ++;
+    if ( (*SCSR) & SCI_ERROR_FRAMING )   SciErrorsFraming ++;
+    if ( (*SCSR) & SCI_ERROR_NOISE   )   SciErrorsNoise   ++;
+    if ( (*SCSR) & SCI_ERROR_OVERRUN )   SciErrorsOverrun ++;
+
+    // see if it was a transmit interrupt
+
+    if ( (*SCSR) & SCI_XMTR_AVAILABLE )         // data reg empty, xmt complete
+    {
+        SciDisableTransmitInterrupts();
+
+        // tell termios module that the charcter was sent
+        // he will call us later to transmit more if there are any
+
+        if (rtems_termios_dequeue_characters( SciTermioTty, 1 ))
+        {
+            // there are more bytes to transmit so enable TX interrupt
+
+            SciEnableTransmitInterrupts();
+        }
+    }
+
+    // see if it was a receive interrupt
+    // on the sci uart we just get one character per interrupt
+
+    while (  SciCharAvailable() )               // char in data register?
+    {
+        ch = SciReadCharNoWait();               // get the char from the uart
+
+        // IMPORTANT!!!
+        // either send it to the termios module or keep it locally
+
+        if ( SciOpened == DRIVER_OPENED )       // the driver is open
+        {
+            SciRcvBufPutChar(ch);               // keep it locally
+        }
+        else                                    // put in termios buffer
+        {
+            rtems_termios_enqueue_raw_characters( SciTermioTty, &ch, 1 );
+        }
+
+        *SCSR &= SCI_CLEAR_RX_INT;              // clear the interrupt
+    }
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+//                              SECTION 1
+//                ROUTINES TO MANIPULATE THE CIRCULAR BUFFER
+//
+/////////////////////////////////////////////////////////////////////////////
+
+/****************************************************************************
+* Func:     SciRcvBufGetChar
+* Desc:     read a character from the circular buffer
+*           make sure there is data before you call this!
+* Inputs:   none
+* Outputs:  the character or -1
+* Errors:   none
+* Scope:    private
+****************************************************************************/
+
+static int8_t   SciRcvBufGetChar()
+{
+    rtems_interrupt_level level;
+    uint8_t   ch;
+
+    if ( SciRcvBufCount == 0 )
+    {
+        rtems_fatal_error_occurred(0xDEAD);     // check the count first!
+    }
+
+    rtems_interrupt_disable( level );           // disable interrupts
+
+    ch = SciRcvBuffer[SciRcvBufGetIndex];       // get next byte
+
+    SciRcvBufGetIndex++;                        // bump the index
+
+    SciRcvBufGetIndex &= SCI_RCV_BUF_SIZE - 1;  // and wrap it
+
+    SciRcvBufCount--;                           // decrement counter
+
+    rtems_interrupt_enable( level );            // restore interrupts
+
+    return ch;                                  // return the char
+}
+
+
+/****************************************************************************
+* Func:     SciRcvBufPutChar
+* Desc:     put a character into the rcv data circular buffer
+* Inputs:   the character
+* Outputs:  none
+* Errors:   none
+* Scope:    private
+****************************************************************************/
+
+static void SciRcvBufPutChar( uint8_t   ch )
+{
+    rtems_interrupt_level level;
+
+    if ( SciRcvBufCount == SCI_RCV_BUF_SIZE )   // is there room?
+    {
+        return;                                 // no, throw it away
+    }
+
+    rtems_interrupt_disable( level );           // disable interrupts
+
+    SciRcvBuffer[SciRcvBufPutIndex] = ch;       // put it in the buf
+
+    SciRcvBufPutIndex++;                        // bump the index
+
+    SciRcvBufPutIndex &= SCI_RCV_BUF_SIZE - 1;  // and wrap it
+
+    SciRcvBufCount++;                           // increment counter
+
+    rtems_interrupt_enable( level );            // restore interrupts
+
+    return;                                     // return
+}
+
+
+/****************************************************************************
+* Func:     SciRcvBufFlush
+* Desc:     completely reset and clear the rcv buffer
+* Inputs:   none
+* Outputs:  none
+* Errors:   none
+* Scope:    private
+****************************************************************************/
+
+#if 0                                           // prevents compiler warning
+static void SciRcvBufFlush( void )
+{
+    rtems_interrupt_level level;
+
+    rtems_interrupt_disable( level );           // disable interrupts
+
+    memset( SciRcvBuffer, 0, sizeof(SciRcvBuffer) );
+
+    SciRcvBufPutIndex = 0;                      // clear
+
+    SciRcvBufGetIndex = 0;                      // clear
+
+    SciRcvBufCount = 0;                         // clear
+
+    rtems_interrupt_enable( level );            // restore interrupts
+
+    return;                                     // return
+}
+#endif
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+//                              SECTION 2
+//            INTERRUPT BASED ENTRY POINTS FOR THE TERMIOS MODULE
+//
+/////////////////////////////////////////////////////////////////////////////
+
+/****************************************************************************
+* Func:     SciInterruptOpen
+* Desc:     open routine for the interrupt based device driver
+*           Default state is 9600 baud, 8 bits, No parity, and 1 stop bit. ??
+**CHANGED** Default baud rate is now 19200, 8N1
+*           called from rtems_termios_open which is called from console_open
+* Inputs:   major - device number
+*           minor - device number
+*           args - points to terminal info
+* Outputs:  success/fail
+* Errors:   none
+* Scope:    public API
+****************************************************************************/
+
+int32_t   SciInterruptOpen(
+    int32_t    major,
+    int32_t    minor,
+    void     *arg
+)
+{
+    rtems_libio_open_close_args_t * args = arg;
+    rtems_isr_entry old_vector;
+
+    if ( minor != SCI_MINOR )                   // check minor device num
+    {
+        return -1;
+    }
+
+    if ( !args )                                // must have args
+    {
+        return -1;
+    }
+
+    SciTermioTty = args->iop->data1;            // save address of struct
+
+    SciDisableAllInterrupts();                  // turn off sci interrupts
+
+    // THIS IS ACTUALLY A BAD THING - SETTING LINE PARAMETERS HERE
+    // IT SHOULD BE DONE THROUGH TCSETATTR() WHEN THE CONSOLE IS OPENED!!!
+
+//  SciSetBaud(115200);                         // set the baud rate
+//  SciSetBaud( 57600);                         // set the baud rate
+//  SciSetBaud( 38400);                         // set the baud rate
+SciSetBaud( 19200);                         // set the baud rate
+//    SciSetBaud(  9600);                         // set the baud rate
+
+    SciSetParity(SCI_PARITY_NONE);              // set parity to none
+
+    SciSetDataBits(SCI_8_DATA_BITS);            // set data bits to 8
+
+    // Install our interrupt handler into RTEMS, where does 66 come from?
+
+    rtems_interrupt_catch( SciIsr, 66, &old_vector );
+
+    *QIVR  = 66;
+    *QIVR &= 0xf8;
+    *QILR |= 0x06 & 0x07;
+
+    SciEnableTransmitter();                     // enable the transmitter
+
+    SciEnableReceiver();                        // enable the receiver
+
+    SciEnableReceiveInterrupts();               // enable rcv interrupts
+
+    return RTEMS_SUCCESSFUL;
+}
+
+
+/****************************************************************************
+* Func:     SciInterruptClose
+* Desc:     close routine called by the termios module
+* Inputs:   major - device number
+*           minor - device number
+*           args - unused
+* Outputs:  success/fail
+* Errors:   none
+* Scope:    public - termio entry point
+****************************************************************************/
+
+int32_t   SciInterruptClose(
+    int32_t    major,
+    int32_t    minor,
+    void     *arg
+)
+{
+    SciDisableAllInterrupts();
+
+    return RTEMS_SUCCESSFUL;
+}
+
+
+/****************************************************************************
+* Func:     SciInterruptWrite
+* Desc:     writes data to the uart using transmit interrupts
+* Inputs:   minor - device number
+*           buf - points to the data
+*           len - number of bytes to send
+* Outputs:  success/fail
+* Errors:   none
+* Scope:    public API
+****************************************************************************/
+
+int32_t   SciInterruptWrite(
+    int32_t      minor,
+    const char *buf,
+    int32_t      len
+)
+{
+    // We are using interrupt driven output so termios only sends us
+    // one character at a time. The sci does not have a fifo.
+
+    if ( !len )                                 // no data?
+    {
+        return 0;                               // return error
+    }
+
+    if ( minor != SCI_MINOR )                   // check the minor dev num
+    {
+        return 0;                               // return error
+    }
+
+    if ( SciOpened == DRIVER_OPENED )           // is the driver api open?
+    {
+        return 1;                               // yep, throw this away
+    }
+
+    SciWriteCharNoWait(*buf);                   // try to send a char
+
+    *SCSR &= SCI_CLEAR_TDRE;                    // clear tx data reg empty flag
+
+    SciEnableTransmitInterrupts();              // enable the tx interrupt
+
+    return 1;                                   // return success
+}
+
+
+/****************************************************************************
+* Func:     SciSetAttributes
+* Desc:     setup the uart based on the termios modules requests
+* Inputs:   minor - device number
+*           t - pointer to the termios info struct
+* Outputs:  none
+* Errors:   none
+* Scope:    public API
+****************************************************************************/
+
+int32_t   SciSetAttributes(
+    int32_t   minor,
+    const struct termios *t
+)
+{
+    uint32_t    baud_requested;
+    uint32_t    sci_rate = 0;
+    uint16_t    sci_parity = 0;
+    uint16_t    sci_databits = 0;
+
+    if ( minor != SCI_MINOR )                   // check the minor dev num
+    {
+        return -1;                              // return error
+    }
+
+    // if you look closely you will see this is the only thing we use
+    // set the baud rate
+
+    baud_requested = t->c_cflag & CBAUD;        // baud rate
+
+    if (!baud_requested)
+    {
+//        baud_requested = B9600;                 // default to 9600 baud
+        baud_requested = B19200;                 // default to 19200 baud
+    }
+
+    sci_rate = termios_baud_to_number( baud_requested );
+
+    // parity error detection
+
+    if (t->c_cflag & PARENB)                    // enable parity detection?
+    {
+        if (t->c_cflag & PARODD)
+        {
+            sci_parity = SCI_PARITY_ODD;        // select odd parity
+        }
+        else
+        {
+            sci_parity = SCI_PARITY_EVEN;       // select even parity
+        }
+    }
+    else
+    {
+        sci_parity = SCI_PARITY_NONE;           // no parity, most common
+    }
+
+    //  set the number of data bits, 8 is most common
+
+    if (t->c_cflag & CSIZE)                     // was it specified?
+    {
+        switch (t->c_cflag & CSIZE)
+        {
+            case CS8:   sci_databits = SCI_8_DATA_BITS;   break;
+            default :   sci_databits = SCI_9_DATA_BITS;   break;
+        }
+    }
+    else
+    {
+        sci_databits = SCI_8_DATA_BITS;         // default to 8 data bits
+    }
+
+    //  the number of stop bits; always 1 for SCI
+
+    if (t->c_cflag & CSTOPB)
+    {
+        // do nothing
+    }
+
+    // setup the hardware with these serial port parameters
+
+    SciSetBaud(sci_rate);                       // set the baud rate
+
+    SciSetParity(sci_parity);                   // set the parity type
+
+    SciSetDataBits(sci_databits);               // set the data bits
+
+    return RTEMS_SUCCESSFUL;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+//                              SECTION 3
+//            POLLING BASED ENTRY POINTS FOR THE TERMIOS MODULE
+//
+/////////////////////////////////////////////////////////////////////////////
+
+/****************************************************************************
+* Func:     SciPolledOpen
+* Desc:     open routine for the polled i/o version of the driver
+*           called from rtems_termios_open which is called from console_open
+* Inputs:   major - device number
+*           minor - device number
+*           args - points to terminal info struct
+* Outputs:  success/fail
+* Errors:   none
+* Scope:    public - termios entry point
+****************************************************************************/
+
+int32_t   SciPolledOpen(
+    int32_t   major,
+    int32_t   minor,
+    void    *arg
+)
+{
+    rtems_libio_open_close_args_t * args = arg;
+
+    if ( minor != SCI_MINOR )                   // check minor device num
+    {
+        return -1;
+    }
+
+    if ( !args )                                // must have args
+    {
+        return -1;
+    }
+
+    SciTermioTty = args->iop->data1;            // Store tty pointer
+
+    SciDisableAllInterrupts();                  // don't generate interrupts
+
+    // THIS IS ACTUALLY A BAD THING - SETTING LINE PARAMETERS HERE
+    // IT SHOULD BE DONE THROUGH TCSETATTR() WHEN THE CONSOLE IS OPENED!!!
+
+//  SciSetBaud(115200);                         // set the baud rate
+//  SciSetBaud( 57600);                         // set the baud rate
+//  SciSetBaud( 38400);                         // set the baud rate
+  SciSetBaud( 19200);                         // set the baud rate
+//  SciSetBaud(  9600);                         // set the baud rate
+
+    SciSetParity(SCI_PARITY_NONE);              // set no parity
+
+    SciSetDataBits(SCI_8_DATA_BITS);            // set 8 data bits
+
+    SciEnableTransmitter();                     // enable the xmitter
+
+    SciEnableReceiver();                        // enable the rcvr
+
+    return RTEMS_SUCCESSFUL;
+}
+
+
+/****************************************************************************
+* Func:     SciPolledClose
+* Desc:     close routine for the device driver, same for both
+* Inputs:   major - device number
+*           minor - device number
+*           args - unused
+* Outputs:  success/fail
+* Errors:   none
+* Scope:    public termios API
+****************************************************************************/
+
+int32_t   SciPolledClose(
+    int32_t    major,
+    int32_t    minor,
+    void     *arg
+)
+{
+    SciDisableAllInterrupts();
+
+    return RTEMS_SUCCESSFUL;
+}
+
+
+/****************************************************************************
+* Func:     SciPolledRead
+* Desc:     polling based read routine for the uart
+* Inputs:   minor - device number
+* Outputs:  error or the character read
+* Errors:   none
+* Scope:    public API
+****************************************************************************/
+
+int32_t   SciPolledRead(
+    int32_t   minor
+)
+{
+    if ( minor != SCI_MINOR )               // check the minor dev num
+    {
+        return -1;                          // return error
+    }
+
+    if ( SciCharAvailable() )               // if a char is available
+    {
+        return SciReadCharNoWait();         // read the rx data register
+    }
+
+    return -1;                              // return error
+}
+
+
+/****************************************************************************
+* Func:     SciPolledWrite
+* Desc:     writes out characters in polled mode, waiting for the uart
+*           check in console_open, but we only seem to use interrupt mode
+* Inputs:   minor - device number
+*           buf - points to the data
+*           len - how many bytes
+* Outputs:  error or number of bytes written
+* Errors:   none
+* Scope:    public termios API
+****************************************************************************/
+
+int32_t   SciPolledWrite(
+    int32_t        minor,
+    const char   *buf,
+    int32_t        len
+)
+{
+    int32_t   written = 0;
+
+    if ( minor != SCI_MINOR )                   // check minor device num
+    {
+        return -1;
+    }
+
+    if ( SciOpened == DRIVER_OPENED )           // is the driver api open?
+    {
+        return -1;                              // toss the data
+    }
+
+    // send each byte in the string out the port
+
+    while ( written < len )
+    {
+        SciWriteCharWait(*buf++);               // send a byte
+
+        written++;                              // increment counter
+    }
+
+    return written;                             // return count
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+//                              SECTION 4
+//                 DEVICE DRIVER PUBLIC API ENTRY POINTS
+//
+/////////////////////////////////////////////////////////////////////////////
+
+/****************************************************************************
+* Func:     SciInit
+* Desc:     Initialize the lasers device driver and hardware
+* Inputs:   major - the major device number which is assigned by rtems
+*           minor - the minor device number which is undefined at this point
+*           arg - ?????
+* Outputs:  RTEMS_SUCCESSFUL
+* Errors:   None.
+* Scope:    public API
+****************************************************************************/
+
+rtems_device_driver SciInitialize (
+    rtems_device_major_number major,
+    rtems_device_minor_number minor,
+    void * arg
+)
+{
+//     rtems_status_code status;
+
+//printk("%s\r\n", __FUNCTION__);
+
+    // register the SCI device name for termios console i/o
+    // this is done over in console.c which doesn't seem exactly right
+    // but there were problems doing it here...
+
+//  status = rtems_io_register_name( "/dev/sci", major, 0 );
+
+//  if (status != RTEMS_SUCCESSFUL)
+//      rtems_fatal_error_occurred(status);
+
+    SciMajor = major;                           // save the rtems major number
+
+    SciOpened = DRIVER_CLOSED;                  // initial state is closed
+
+    // if you have an interrupt handler, install it here
+
+    SciInited = 1;                              // set the inited flag
+
+    return RTEMS_SUCCESSFUL;
+}
+
+
+/****************************************************************************
+* Func:     SciOpen
+* Desc:     device driver open routine
+*           you must open a device before you can anything else
+*           only one process can have the device opened at a time
+*           you could look at the task id to restrict access if you want
+* Inputs:   major - the major device number assigned by rtems
+*           minor - the minor device number assigned by us
+*           arg - ?????
+* Outputs:  see below
+* Errors:   none
+* Scope:    public API
+****************************************************************************/
+
+rtems_device_driver SciOpen (
+    rtems_device_major_number major,
+    rtems_device_minor_number minor,
+    void * arg
+)
+{
+//printk("%s major=%d minor=%d\r\n", __FUNCTION__,major,minor);
+
+    if (SciInited == 0)                         // must be initialized first!
+    {
+        return RTEMS_NOT_CONFIGURED;
+    }
+
+    if (minor != SCI_MINOR)
+    {
+        return RTEMS_INVALID_NAME;              // verify minor number
+    }
+
+    if (SciOpened == DRIVER_OPENED)
+    {
+        return RTEMS_RESOURCE_IN_USE;           // already opened!
+    }
+
+    SciOpened = DRIVER_OPENED;                  // set the opened flag
+
+    return RTEMS_SUCCESSFUL;
+}
+
+
+/****************************************************************************
+* Func:     SciClose
+* Desc:     device driver close routine
+*           the device must be opened before you can close it
+*           the device must be closed before someone (else) can open it
+* Inputs:   major - the major device number
+*           minor - the minor device number
+*           arg - ?????
+* Outputs:  see below
+* Errors:   none
+* Scope:    public API
+****************************************************************************/
+
+rtems_device_driver SciClose (
+    rtems_device_major_number major,
+    rtems_device_minor_number minor,
+    void * arg
+)
+{
+//printk("%s major=%d minor=%d\r\n", __FUNCTION__,major,minor);
+
+    if (minor != SCI_MINOR)
+    {
+        return RTEMS_INVALID_NAME;              // check the minor number
+    }
+
+    if (SciOpened != DRIVER_OPENED)
+    {
+        return RTEMS_INCORRECT_STATE;           // must be opened first
+    }
+
+    SciOpened = DRIVER_CLOSED;                  // set the flag
+
+    return RTEMS_SUCCESSFUL;
+}
+
+
+/****************************************************************************
+* Func:     SciRead
+* Desc:     device driver read routine
+*           this function is not meaningful for the laser devices
+* Inputs:   major - the major device number
+*           minor - the minor device number
+*           arg - read/write arguments
+* Outputs:  see below
+* Errors:   none
+* Scope:    public API
+****************************************************************************/
+
+rtems_device_driver SciRead (
+    rtems_device_major_number major,
+    rtems_device_minor_number minor,
+    void *arg
+)
+{
+    rtems_libio_rw_args_t *rw_args;             // ptr to argument struct
+    uint8_t   *buffer;
+    uint16_t   length;
+
+    rw_args = (rtems_libio_rw_args_t *) arg;    // arguments to read()
+
+    if (minor != SCI_MINOR)
+    {
+        return RTEMS_INVALID_NAME;              // check the minor number
+    }
+
+    if (SciOpened == DRIVER_CLOSED)
+    {
+        return RTEMS_INCORRECT_STATE;           // must be opened first
+    }
+
+    buffer = rw_args->buffer;                   // points to user's buffer
+
+    length = rw_args->count;                    // how many bytes they want
+
+//  *buffer = SciReadCharWait();                // wait for a character
+
+    // if there isn't a character available, wait until one shows up
+    // or the timeout period expires, which ever happens first
+
+    if ( SciRcvBufCount == 0 )                  // no chars
+    {
+        // wait for someone to wake me up...
+        //rtems_task_wake_after(SciReadTimeout);
+    }
+
+    if ( SciRcvBufCount )                       // any characters locally?
+    {
+        *buffer = SciRcvBufGetChar();           // get the character
+
+        rw_args->bytes_moved = 1;               // how many we actually read
+    }
+
+    return RTEMS_SUCCESSFUL;
+}
+
+
+/****************************************************************************
+* Func:     SciWrite
+* Desc:     device driver write routine
+*           this function is not meaningful for the laser devices
+* Inputs:   major - the major device number
+*           minor - the minor device number
+*           arg - read/write arguments
+* Outputs:  see below
+* Errors:   non3
+* Scope:    public API
+****************************************************************************/
+
+rtems_device_driver SciWrite (
+    rtems_device_major_number major,
+    rtems_device_minor_number minor,
+    void * arg
+)
+{
+    rtems_libio_rw_args_t *rw_args;             // ptr to argument struct
+    uint8_t   *buffer;
+    uint16_t   length;
+
+    rw_args = (rtems_libio_rw_args_t *) arg;
+
+    if (minor != SCI_MINOR)
+    {
+        return RTEMS_INVALID_NAME;              // check the minor number
+    }
+
+    if (SciOpened == DRIVER_CLOSED)
+    {
+        return RTEMS_INCORRECT_STATE;           // must be opened first
+    }
+
+    buffer = (uint8_t*)rw_args->buffer;       // points to data
+
+    length = rw_args->count;                    // how many bytes
+
+    while (length--)
+    {
+        SciWriteCharWait(*buffer++);            // send the bytes out
+    }
+
+    rw_args->bytes_moved = rw_args->count;      // how many we wrote
+
+    return RTEMS_SUCCESSFUL;
+}
+
+
+/****************************************************************************
+* Func:     SciControl
+* Desc:     device driver control routine
+*           see below for an example of how to use the ioctl interface
+* Inputs:   major - the major device number
+*           minor - the minor device number
+*           arg - io control args
+* Outputs:  see below
+* Errors:   none
+* Scope:    public API
+****************************************************************************/
+
+rtems_device_driver SciControl (
+    rtems_device_major_number major,
+    rtems_device_minor_number minor,
+    void * arg
+)
+{
+    rtems_libio_ioctl_args_t *args = arg;       // rtems arg struct
+    uint16_t   command;                         // the cmd to execute
+    uint16_t   unused;                          // maybe later
+    uint16_t   *ptr;                            // ptr to user data
+
+//printk("%s major=%d minor=%d\r\n", __FUNCTION__,major,minor);
+
+    // do some sanity checking
+
+    if (minor != SCI_MINOR)
+    {
+        return RTEMS_INVALID_NAME;              // check the minor number
+    }
+
+    if (SciOpened == DRIVER_CLOSED)
+    {
+        return RTEMS_INCORRECT_STATE;           // must be open first
+    }
+
+    if (args == 0)
+    {
+        return RTEMS_INVALID_ADDRESS;           // must have args
+    }
+
+    args->ioctl_return = -1;                    // assume an error
+
+    command = args->command;                    // get the command
+    ptr     = args->buffer;                     // this is an address
+    unused  = *ptr;                             // brightness
+
+    if (command == SCI_SEND_BREAK)              // process the command
+    {
+        SciSendBreak();                         // send break char
+    }
+
+    args->ioctl_return = 0;                     // return status
+
+    return RTEMS_SUCCESSFUL;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+//                              SECTION 5
+//                       HARDWARE LEVEL ROUTINES
+//
+/////////////////////////////////////////////////////////////////////////////
+
+/****************************************************************************
+* Func:     SciSetBaud
+* Desc:     setup the uart based on the termios modules requests
+* Inputs:   baud rate
+* Outputs:  none
+* Errors:   none
+* Scope:    private
+****************************************************************************/
+
+static void SciSetBaud(uint32_t   rate)
+{
+    uint16_t   value;
+    uint16_t   save_sccr1;
+
+// when you open the console you need to set the termio struct baud rate
+// it has a default value of 9600, when someone calls tcsetattr it reverts!
+
+    SciBaud = rate;                             // save the rate
+
+    // calculate the register value as a float and convert to an int
+    // set baud rate - you must define the system clock constant
+    // see mrm332.h for an example
+
+    value = ( (uint16_t) ( SYS_CLOCK / rate / 32.0 + 0.5 ) & 0x1fff );
+
+    save_sccr1 = *SCCR1;                        // save register
+
+    // also turns off the xmtr and rcvr
+
+    *SCCR1 &= SCI_DISABLE_INT_ALL;              // disable interrupts
+
+    *SCCR0 = value;                             // write the register
+
+    *SCCR1 = save_sccr1;                        // restore register
+
+    return;
+}
+
+
+/****************************************************************************
+* Func:     SciSetParity
+* Desc:     setup the uart based on the termios modules requests
+* Inputs:   parity
+* Outputs:  none
+* Errors:   none
+* Scope:    private
+****************************************************************************/
+
+static void SciSetParity(uint16_t   parity)
+{
+    uint16_t   value;
+
+    value = *SCCR1;                             // get the register
+
+    if (parity == SCI_PARITY_ODD)
+    {
+        value |= SCI_PARITY_ENABLE;             // parity enabled
+        value |= SCI_PARITY_ODD;                // parity odd
+    }
+
+    else if (parity == SCI_PARITY_EVEN)
+    {
+        value |= SCI_PARITY_ENABLE;             // parity enabled
+        value &= ~SCI_PARITY_ODD;               // parity even
+    }
+
+    else if (parity == SCI_PARITY_NONE)
+    {
+        value &= ~SCI_PARITY_ENABLE;            // disabled, most common
+    }
+
+    /* else no changes */
+
+    *SCCR1 = value;                             // write the register
+
+    return;
+}
+
+
+/****************************************************************************
+* Func:     SciSetDataBits
+* Desc:     setup the uart based on the termios modules requests
+* Inputs:   data bits
+* Outputs:  none
+* Errors:   none
+* Scope:    private
+****************************************************************************/
+
+static void SciSetDataBits(uint16_t   bits)
+{
+    uint16_t   value;
+
+    value = *SCCR1;                             // get the register
+
+    /* note - the parity setting affects the number of data bits */
+
+    if (bits == SCI_9_DATA_BITS)
+    {
+        value |= SCI_9_DATA_BITS;               // 9 data bits
+    }
+
+    else if (bits == SCI_8_DATA_BITS)
+    {
+        value &= SCI_8_DATA_BITS;               // 8 data bits
+    }
+
+    /* else no changes */
+
+    *SCCR1 = value;                             // write the register
+
+    return;
+}
+
+
+/****************************************************************************
+* Func:     SciDisableAllInterrupts
+* Func:     SciEnableTransmitInterrupts
+* Func:     SciEnableReceiveInterrupts
+* Desc:     handles generation of interrupts by the sci module
+* Inputs:   none
+* Outputs:  none
+* Errors:   none
+* Scope:    private
+****************************************************************************/
+
+static void inline SciDisableAllInterrupts( void )
+{
+    // this also turns off the xmtr and rcvr
+
+    *SCCR1 &= SCI_DISABLE_INT_ALL;
+}
+
+static void inline SciEnableReceiveInterrupts( void )
+{
+    *SCCR1 |= SCI_ENABLE_INT_RX;
+}
+
+static void inline SciDisableReceiveInterrupts( void )
+{
+    *SCCR1 &= SCI_DISABLE_INT_RX;
+}
+
+static void inline SciEnableTransmitInterrupts( void )
+{
+    *SCCR1 |= SCI_ENABLE_INT_TX;
+}
+
+static void inline SciDisableTransmitInterrupts( void )
+{
+    *SCCR1 &= SCI_DISABLE_INT_TX;
+}
+
+
+/****************************************************************************
+* Func:     SciEnableTransmitter, SciDisableTransmitter
+* Func:     SciEnableReceiver,    SciDisableReceiver
+* Desc:     turns the transmitter and receiver on and off
+* Inputs:   none
+* Outputs:  none
+* Errors:   none
+* Scope:    private
+****************************************************************************/
+
+static void inline SciEnableTransmitter( void )
+{
+    *SCCR1 |= SCI_ENABLE_XMTR;
+}
+
+static void inline SciDisableTransmitter( void )
+{
+    *SCCR1 &= SCI_DISABLE_XMTR;
+}
+
+static void inline SciEnableReceiver( void )
+{
+    *SCCR1 |= SCI_ENABLE_RCVR;
+}
+
+static void inline SciDisableReceiver( void )
+{
+    *SCCR1 &= SCI_DISABLE_RCVR;
+}
+
+
+/****************************************************************************
+* Func:     SciWriteCharWait
+* Desc:     wait for room in the fifo and then put a char in
+* Inputs:   a byte to send
+* Outputs:  none
+* Errors:   none
+* Scope:    public
+****************************************************************************/
+
+void SciWriteCharWait(uint8_t   c)
+{
+    // poll the fifo, waiting for room for another character
+
+    while ( ( *SCSR & SCI_XMTR_AVAILABLE ) == 0 )
+    {
+        /* Either we are writing to the fifo faster than
+         * the uart can clock bytes out onto the cable,
+         * or we are in flow control (actually no, we
+         * are ignoring flow control from the other end).
+         * In the first case, higher baud rates will help.
+         */
+      /* relinquish processor while waiting */
+      rtems_task_wake_after(RTEMS_YIELD_PROCESSOR);
+    }
+
+    *SCDR = c;                                  // send the charcter
+
+    SciBytesOut++;                              // increment the counter
+
+    return;
+}
+
+/****************************************************************************
+* Func:     SciWriteCharNoWait
+* Desc:     if no room in the fifo throw the char on the floor
+* Inputs:   a byte to send
+* Outputs:  none
+* Errors:   none
+* Scope:    public
+****************************************************************************/
+
+void SciWriteCharNoWait(uint8_t   c)
+{
+    if ( ( *SCSR & SCI_XMTR_AVAILABLE ) == 0 )
+    {
+        return;                                 // no room, throw it away
+    }
+
+    *SCDR = c;                                  // put the char in the fifo
+
+    SciBytesOut++;                              // increment the counter
+
+    return;
+}
+
+
+/****************************************************************************
+* Func:     SciReadCharWait
+* Desc:     read a character, waiting for one to show up, if need be
+* Inputs:   none
+* Outputs:  a character
+* Errors:   none
+* Scope:    public
+****************************************************************************/
+
+uint8_t   inline SciReadCharWait( void )
+{
+    uint8_t   ch;
+
+    while ( SciCharAvailable() == 0 )           // anything there?
+    {
+      /* relinquish processor while waiting */
+      rtems_task_wake_after(RTEMS_YIELD_PROCESSOR);
+    }
+
+    // if you have rcv ints enabled, then the isr will probably
+    // get the character before you will unless you turn off ints
+    // ie polling and ints don't mix that well
+
+    ch = *SCDR;                                 // get the charcter
+
+    SciBytesIn++;                               // increment the counter
+
+    return ch;                                  // return the char
+}
+
+/****************************************************************************
+* Func:     SciReadCharNoWait
+* Desc:     try to get a char but dont wait for one
+* Inputs:   none
+* Outputs:  a character or -1 if none
+* Errors:   none
+* Scope:    public
+****************************************************************************/
+
+uint8_t   inline SciReadCharNoWait( void )
+{
+    uint8_t   ch;
+
+    if ( SciCharAvailable() == 0 )              // anything there?
+        return -1;
+
+    ch = *SCDR;                                 // get the character
+
+    SciBytesIn++;                               // increment the count
+
+    return ch;                                  // return the char
+}
+
+
+/****************************************************************************
+* Func:     SciCharAvailable
+* Desc:     is there a receive character in the data register
+* Inputs:   none
+* Outputs:  false if no char available, else true
+* Errors:   none
+* Scope:    public
+****************************************************************************/
+
+uint8_t   inline SciCharAvailable( void )
+{
+    return ( *SCSR & SCI_RCVR_READY );          // char in data register?
+}
+
+
+/****************************************************************************
+* Func:     SciSendBreak
+* Desc:     send 1 or tow breaks (all zero bits)
+* Inputs:   none
+* Outputs:  none
+* Errors:   none
+* Scope:    public
+****************************************************************************/
+
+void SciSendBreak( void )
+{
+    // From the Motorola QSM reference manual -
+
+    // "if SBK is toggled by writing it first to a one and then immediately
+    // to a zero (in less than one serial frame interval), the transmitter
+    // sends only one or two break frames before reverting to mark (idle)
+    // or before commencing to send more data"
+
+    *SCCR1 |=  SCI_SEND_BREAK;                  // set the bit
+
+    *SCCR1 &= ~SCI_SEND_BREAK;                  // clear the bit
+
+    return;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+//                             SECTION 6
+//                             TEST CODE
+//
+/////////////////////////////////////////////////////////////////////////////
+
+/****************************************************************************
+* Func:     SciUnitTest
+* Desc:     test the device driver
+* Inputs:   nothing
+* Outputs:  nothing
+* Scope:    public
+****************************************************************************/
+
+#if 0
+#define O_RDWR LIBIO_FLAGS_READ_WRITE           // dont like this but...
+
+void SciUnitTest()
+{
+    uint8_t   byte;                             // a character
+    uint16_t   fd;                              // file descriptor for device
+    uint16_t   result;                          // result of ioctl
+
+    fd = open("/dev/sci",O_RDWR);               // open the device
+
+printk("SCI open fd=%d\r\n",fd);
+
+    result = write(fd, "abcd\r\n", 6);          // send a string
+
+printk("SCI write result=%d\r\n",result);
+
+    result = read(fd, &byte, 1);                // read a byte
+
+printk("SCI read result=%d,byte=%x\r\n",result,byte);
+
+    return;
+}
+#endif
+
+
+/****************************************************************************
+* Func:     SciPrintStats
+* Desc:     print out some driver information
+* Inputs:   nothing
+* Outputs:  nothing
+* Scope:    public
+****************************************************************************/
+
+void SciPrintStats ( void )
+{
+    printk("\r\n");
+
+    printk( "SYS_CLOCK is %2.6f Mhz\r\n\n", SYS_CLOCK / 1000000.0 );
+
+    printk( "Current baud rate is %d bps or %d cps\r\n\n", SciBaud, SciBaud / 10 );
+
+    printk( "SCI Uart chars in       %8d\r\n", SciBytesIn       );
+    printk( "SCI Uart chars out      %8d\r\n", SciBytesOut      );
+    printk( "SCI Uart framing errors %8d\r\n", SciErrorsFraming );
+    printk( "SCI Uart parity  errors %8d\r\n", SciErrorsParity  );
+    printk( "SCI Uart overrun errors %8d\r\n", SciErrorsOverrun );
+    printk( "SCI Uart noise   errors %8d\r\n", SciErrorsNoise   );
+
+    return;
+}
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/startup/bspstart.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/startup/bspstart.c
@@ -0,0 +1,82 @@
+/*
+ *  This routine starts the application.  It includes application,
+ *  board, and monitor specific initialization and configuration.
+ *  The generic CPU dependent initialization has been performed
+ *  before this routine is invoked.
+ *
+ *  COPYRIGHT (c) 1989-1999.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: bspstart.c,v 1.7 2004/04/21 10:42:52 ralf Exp $
+ */
+
+#include <bsp.h>
+#include <rtems/libio.h>
+
+#include <string.h>
+
+/*
+ *  The original table from the application and our copy of it with
+ *  some changes.
+ */
+
+extern rtems_configuration_table  Configuration;
+rtems_configuration_table         BSP_Configuration;
+
+rtems_cpu_table Cpu_table;
+
+char *rtems_progname;
+
+/*
+ *  Use the shared implementations of the following routines
+ */
+
+void bsp_postdriver_hook(void);
+void bsp_libc_init( void *, uint32_t, int );
+void bsp_pretasking_hook(void);               /* m68k version */
+
+/*
+ *  Call Spurious_Initialize in bsp_predriver_hook because
+ *  bsp_predriver_hook is call after the _ISR_Vector_Table allocation
+ */
+
+void bsp_predriver_hook(void)
+{
+  void Spurious_Initialize();
+  Spurious_Initialize();
+}
+
+/*
+ *  bsp_start
+ *
+ *  This routine does the bulk of the system initialization.
+ */
+
+void bsp_start( void )
+{
+  void           *vbr;
+  extern void    *_WorkspaceBase;
+  extern void    *_RamSize;
+  extern unsigned long _M68k_Ramsize;
+
+  _M68k_Ramsize = (unsigned long)&_RamSize;		/* RAM size set in linker script */
+
+  /*
+   *  we only use a hook to get the C library initialized.
+   */
+
+  Cpu_table.pretasking_hook = bsp_pretasking_hook;
+  Cpu_table.predriver_hook  = bsp_predriver_hook;
+  Cpu_table.postdriver_hook = bsp_postdriver_hook;
+
+  m68k_get_vbr( vbr );
+  Cpu_table.interrupt_vector_table = vbr;
+
+  BSP_Configuration.work_space_start = (void *) &_WorkspaceBase;
+
+  /* Clock_exit is done as an atexit() function */
+}
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/startup/start_c.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/startup/start_c.c
@@ -0,0 +1,125 @@
+/*
+ *  $Id
+ */
+
+#include <mrm332.h>
+#include <rtems/m68k/sim.h>
+#define __START_C__
+#include "bsp.h"
+
+m68k_isr_entry M68Kvec[256];
+m68k_isr_entry vectors[256];
+char * const __argv[]= {"main", ""};
+
+void  boot_card(int argc, char * const argv[]);
+
+/*
+ *  This prototype really should have the noreturn attribute but
+ *  that causes a warning. Not sure how to fix that.
+ */
+/* void dumby_start ()  __attribute__ ((noreturn)); */
+void start_c ();
+
+void  start_c() {
+
+  /* Synthesizer Control Register */
+  /*    see section(s) 4.8 */
+  /* end include in ram_init.S */
+  *SYNCR = (unsigned short int)
+    ( SAM(MRM_W,15,VCO) | SAM(0x0,14,PRESCALE) | SAM(MRM_Y,8,COUNTER) );
+  while (! (*SYNCR & SLOCK));	/* protect from clock overshoot */
+  /* include in ram_init.S */
+  *SYNCR = (unsigned short int)
+    ( SAM(MRM_W,15,VCO) | SAM(MRM_X,14,PRESCALE) | SAM(MRM_Y,8,COUNTER) );
+
+  /* System Protection Control Register */
+  /*    !!! can only write to once after reset !!! */
+  /*    see section 3.8.4 of the SIM Reference Manual */
+  *SYPCR = (unsigned char)( HME | BME );
+
+  /* Periodic Interrupr Control Register */
+  /*    see section 3.8.2 of the SIM Reference Manual */
+  *PICR = (unsigned short int)
+    ( SAM(0,8,PIRQL) | SAM(MRM_PIV,0,PIV) );
+  /*     ^^^ zero disables interrupt, don't enable here or ram_init will
+	 be wrong. It's enabled below. */
+
+  /* Periodic Interrupt Timer Register */
+  /*    see section 3.8.3 of the SIM Reference Manual */
+  *PITR = (unsigned short int)( SAM(0x09,0,PITM) );
+  /*    1.098mS interrupt, assuming 32.768 KHz input clock */
+
+  /* Port C Data */
+  /*    load values before enabled */
+  *PORTC = (unsigned char) 0x0;
+
+  /* Port E and F Data Register */
+  /*    see section 9 of the SIM Reference Manual */
+  *PORTE0 = (unsigned char) 0;
+  *PORTF0 = (unsigned char) 0;
+
+  /* Port E and F Data Direction Register */
+  /*    see section 9 of the SIM Reference Manual */
+  *DDRE = (unsigned char) 0xff;
+  *DDRF = (unsigned char) 0xfd;
+
+  /* Port E and F Pin Assignment Register */
+  /*    see section 9 of the SIM Reference Manual */
+  *PEPAR = (unsigned char) 0;
+  *PFPAR = (unsigned char) 0;
+
+  /* end of SIM initalization code */
+  /* end include in ram_init.S */
+
+  /*
+   * Initialize RAM by copying the .data section out of ROM (if
+   * needed) and "zero-ing" the .bss section.
+   */
+  {
+    register char *src = _etext;
+    register char *dst = _copy_start;
+
+    if (_copy_data_from_rom)
+      /* ROM has data at end of text; copy it. */
+      while (dst < _edata)
+	*dst++ = *src++;
+
+    /* Zero bss */
+    for (dst = _clear_start; dst< end; dst++)
+      {
+	*dst = 0;
+      }
+  }
+
+  /*
+   * Initialize vector table.
+   */
+  {
+    m68k_isr_entry *monitors_vector_table;
+
+    m68k_get_vbr(monitors_vector_table);
+
+    M68Kvec[  4 ] = monitors_vector_table[  4 ];   /* breakpoints vector */
+    M68Kvec[  9 ] = monitors_vector_table[  9 ];   /* trace vector */
+    M68Kvec[ 31 ] = monitors_vector_table[ 31 ];   /* level 7 interrupt */
+    M68Kvec[ 47 ] = monitors_vector_table[ 47 ];   /* system call vector */
+    M68Kvec[ 66 ] = monitors_vector_table[ 66 ];   /* user defined */
+
+    m68k_set_vbr(&M68Kvec);
+  }
+
+  /*
+   * Initalize the board.
+   */
+
+  /* Spurious should be called in the predriver hook */
+  /* Spurious_Initialize(); */
+  //console_init();
+
+  /*
+   * Execute main with arguments argc and agrv.
+   */
+  boot_card(1,__argv);
+  reboot();
+
+}
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/include/tm27.h
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/include/tm27.h
@@ -0,0 +1,34 @@
+/*
+ *  tm27.h
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: tm27.h,v 1.2 2004/04/23 04:47:36 ralf Exp $
+ */
+
+#ifndef _RTEMS_TMTEST27
+#error "This is an RTEMS internal file you must not include directly."
+#endif
+
+#ifndef __tm27_h
+#define __tm27_h
+
+/*
+ *  Define the interrupt mechanism for Time Test 27
+ */
+
+/* XXX - JRS - I want to compile the tmtests */
+
+#define MUST_WAIT_FOR_INTERRUPT 1
+
+#define Install_tm27_vector( handler ) /* empty */
+
+#define Cause_tm27_intr() /* empty */
+
+#define Clear_tm27_intr() /* empty */
+
+#define Lower_tm27_intr() /* empty */
+
+#endif
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/times
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/times
@@ -0,0 +1,195 @@
+#
+#  Timing Test Suite Results for the MRM332 BSP
+#
+#  $Id: times,v 1.2 2004/01/07 21:13:50 joel Exp $
+#
+
+NOTE:  This BSP is user submitted and no information is currently available. 
+
+TBD: MATT - update this with real times!
+
+Board:                MRM332 
+CPU:                  68332
+Clock Speed:          20 Mhz
+Memory Configuration: SRAM, DRAM, cache, etc
+Wait States:          
+
+Times Reported in:    cycles, microseconds, etc
+Timer Source:         Count Down Timer, on-CPU cycle counter, etc
+
+Column A:             unused
+Column B:             unused
+
+#                          DESCRIPTION                                 A    B
+== =================================================================  ==== ====
+ 1 rtems_semaphore_create                                               20
+   rtems_semaphore_delete                                               21
+   rtems_semaphore_obtain: available                                    15
+   rtems_semaphore_obtain: not available -- NO_WAIT                     15
+   rtems_semaphore_release: no waiting tasks                            16
+
+ 2 rtems_semaphore_obtain: not available -- caller blocks               62
+
+ 3 rtems_semaphore_release: task readied -- preempts caller             55
+
+ 4 rtems_task_restart: blocked task -- preempts caller                  77
+   rtems_task_restart: ready task -- preempts caller                    70
+   rtems_semaphore_release: task readied -- returns to caller           25
+   rtems_task_create                                                    57
+   rtems_task_start                                                     31
+   rtems_task_restart: suspended task -- returns to caller              36
+   rtems_task_delete: suspended task                                    47
+   rtems_task_restart: ready task -- returns to caller                  37
+   rtems_task_restart: blocked task -- returns to caller                46
+   rtems_task_delete: blocked task                                      50
+
+ 5 rtems_task_suspend: calling task                                     51
+   rtems_task_resume: task readied -- preempts caller                   49
+
+ 6 rtems_task_restart: calling task                                     59
+   rtems_task_suspend: returns to caller                                18
+   rtems_task_resume: task readied -- returns to caller                 19
+   rtems_task_delete: ready task                                        50
+
+ 7 rtems_task_restart: suspended task -- preempts caller                70
+
+ 8 rtems_task_set_priority: obtain current priority                     12
+   rtems_task_set_priority: returns to caller                           27
+   rtems_task_mode: obtain current mode                                  5
+   rtems_task_mode: no reschedule                                        5
+   rtems_task_mode: reschedule -- returns to caller                      8
+   rtems_task_mode: reschedule -- preempts caller                       39
+   rtems_task_set_note                                                  13
+   rtems_task_get_note                                                  13
+   rtems_clock_set                                                      33
+   rtems_clock_get                                                       3
+
+ 9 rtems_message_queue_create                                          110
+   rtems_message_queue_send: no waiting tasks                           37
+   rtems_message_queue_urgent: no waiting tasks                         37
+   rtems_message_queue_receive: available                               31
+   rtems_message_queue_flush: no messages flushed                       12
+   rtems_message_queue_flush: messages flushed                          16
+   rtems_message_queue_delete                                           26
+
+10 rtems_message_queue_receive: not available -- NO_WAIT                15
+   rtems_message_queue_receive: not available -- caller blocks          62
+
+11 rtems_message_queue_send: task readied -- preempts caller            72
+
+12 rtems_message_queue_send: task readied -- returns to caller          39
+
+13 rtems_message_queue_urgent: task readied -- preempts caller          72
+
+14 rtems_message_queue_urgent: task readied -- returns to caller        39
+
+15 rtems_event_receive: obtain current events                            1
+   rtems_event_receive: not available -- NO_WAIT                        12
+   rtems_event_receive: not available -- caller blocks                  56
+   rtems_event_send: no task readied                                    12
+   rtems_event_receive: available                                       12
+   rtems_event_send: task readied -- returns to caller                  24
+
+16 rtems_event_send: task readied -- preempts caller                    55
+
+17 rtems_task_set_priority: preempts caller                             62
+
+18 rtems_task_delete: calling task                                      83
+
+19 rtems_signal_catch                                                    9
+   rtems_signal_send: returns to caller                                 15
+   rtems_signal_send: signal to self                                    18
+   exit ASR overhead: returns to calling task                           22
+   exit ASR overhead: returns to preempting task                        49
+
+20 rtems_partition_create                                               35
+   rtems_region_create                                                  23
+   rtems_partition_get_buffer: available                                15
+   rtems_partition_get_buffer: not available                            13
+   rtems_partition_return_buffer                                        18
+   rtems_partition_delete                                               16
+   rtems_region_get_segment: available                                  22
+   rtems_region_get_segment: not available -- NO_WAIT                   21
+   rtems_region_return_segment: no waiting tasks                        19
+   rtems_region_get_segment: not available -- caller blocks             64
+   rtems_region_return_segment: task readied -- preempts caller         74
+   rtems_region_return_segment: task readied -- returns to caller       44
+   rtems_region_delete                                                  16
+   rtems_io_initialize                                                   2
+   rtems_io_open                                                         1
+   rtems_io_close                                                        1
+   rtems_io_read                                                         1
+   rtems_io_write                                                        1
+   rtems_io_control                                                      1
+
+21 rtems_task_ident                                                    149
+   rtems_message_queue_ident                                           145
+   rtems_semaphore_ident                                               156
+   rtems_partition_ident                                               145
+   rtems_region_ident                                                  148
+   rtems_port_ident                                                    145
+   rtems_timer_ident                                                   145
+   rtems_rate_monotonic_ident                                          145
+
+22 rtems_message_queue_broadcast: task readied -- returns to caller     42
+   rtems_message_queue_broadcast: no waiting tasks                      17
+   rtems_message_queue_broadcast: task readied -- preempts caller       78
+
+23 rtems_timer_create                                                   14
+   rtems_timer_fire_after: inactive                                     22
+   rtems_timer_fire_after: active                                       24
+   rtems_timer_cancel: active                                           15
+   rtems_timer_cancel: inactive                                         13
+   rtems_timer_reset: inactive                                          21
+   rtems_timer_reset: active                                            23
+   rtems_timer_fire_when: inactive                                      34
+   rtems_timer_fire_when: active                                        34
+   rtems_timer_delete: active                                           19
+   rtems_timer_delete: inactive                                         17
+   rtems_task_wake_when                                                 69
+
+24 rtems_task_wake_after: yield -- returns to caller                     9
+   rtems_task_wake_after: yields -- preempts caller                     45
+
+25 rtems_clock_tick                                                      4
+
+26 _ISR_Disable                                                          0
+   _ISR_Flash                                                            1
+   _ISR_Enable                                                           1
+   _Thread_Disable_dispatch                                              0
+   _Thread_Enable_dispatch                                               7
+   _Thread_Set_state                                                    11
+   _Thread_Disptach (NO FP)                                             31
+   context switch: no floating point contexts                           21
+   context switch: self                                                 10
+   context switch: to another task                                      10
+   context switch: restore 1st FP task                                  25
+   fp context switch: save idle, restore idle                           31
+   fp context switch: save idle, restore initialized                    19
+   fp context switch: save initialized, restore initialized             20
+   _Thread_Resume                                                        7
+   _Thread_Unblock                                                       7
+   _Thread_Ready                                                         9
+   _Thread_Get                                                           4
+   _Semaphore_Get                                                        2
+   _Thread_Get: invalid id                                               0
+
+27 interrupt entry overhead: returns to interrupted task                 6
+   interrupt exit overhead: returns to interrupted task                  6
+   interrupt entry overhead: returns to nested interrupt                 6
+   interrupt exit overhead: returns to nested interrupt                  5
+   interrupt entry overhead: returns to preempting task                  7
+   interrupt exit overhead: returns to preempting task                  36
+
+28 rtems_port_create                                                    16
+   rtems_port_external_to_internal                                      11
+   rtems_port_internal_to_external                                      11
+   rtems_port_delete                                                    16
+
+29 rtems_rate_monotonic_create                                          15
+   rtems_rate_monotonic_period: initiate period -- returns to caller    21
+   rtems_rate_monotonic_period: obtain status                           13
+   rtems_rate_monotonic_cancel                                          16
+   rtems_rate_monotonic_delete: inactive                                18
+   rtems_rate_monotonic_delete: active                                  20
+   rtems_rate_monotonic_period: conclude periods -- caller blocks       53
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/include/mrm332.h
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/include/mrm332.h
@@ -0,0 +1,70 @@
+/*  mrm332.h
+ *
+ *  $Id: mrm332.h,v 1.5 2004/04/21 16:01:35 ralf Exp $
+ */
+
+#ifndef _MRM332_H_
+#define _MRM332_H_
+
+/* SIM_MM (SIM Module Mapping) determines the location of the control
+   register block. When MM=0, register addresses range fom 0x7ff000 to
+   0x7FFFFF. When MM=1, register addresses range from 0xfff000 to
+   0xffffff. */
+#define SIM_MM 1
+
+/* Interrupt related definitions */
+#define SIM_IARB 15
+#define QSM_IARB 10
+
+#define MRM_PIV 64
+#define ISRL_PIT 4		/* zero disables PIT */
+
+#define EFI_QIVR 66		/* 66=>SCI and 67=>QSPI interrupt */
+#define ISRL_QSPI 0
+
+#define EFI_SPINT 24		/* spurious interrupt */
+#define EFI_INT1 25		/* CTS interrupt */
+#define ISRL_SCI 6
+
+/* System Clock definitions */
+#define XTAL 32768.0		/* crystal frequency in Hz */
+
+#if 0
+/* Default MRM clock rate (8.388688 MHz) set by CPU32: */
+#define MRM_W 0			/* system clock parameters */
+#define MRM_X 0
+#define MRM_Y 0x3f
+#endif
+
+#if 1
+/* 16.77722 MHz: */
+#define MRM_W 1			/* system clock parameters */
+#define MRM_X 1
+#define MRM_Y 0x0f
+#endif
+
+#if 0
+/* 25.16582 MHz: */
+#define MRM_W 1			/* system clock parameters */
+#define MRM_X 1
+#define MRM_Y 0x17
+#endif
+
+#define SYS_CLOCK (XTAL*4.0*(MRM_Y+1)*(1 << (2*MRM_W+MRM_X)))
+#define SCI_BAUD 19200		/* RS232 Baud Rate */
+
+/* macros/functions */
+
+#ifndef ASM
+
+/*
+ *  This prototype really should have the noreturn attribute but
+ *  that causes a warning. Not sure how to fix that.
+ */
+/*   static void reboot(void) __attribute__ ((noreturn)); */
+static void reboot(void);
+__inline__ static void reboot() {asm("trap #15; .word 0x0063");}
+
+#endif /* ASM */
+
+#endif /* _MRM_H_ */
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/include/bspopts.h.in
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/include/bspopts.h.in
@@ -0,0 +1,16 @@
+/* include/bspopts.h.in.  Generated from configure.ac by autoheader.  */
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/spurious/spinit.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/spurious/spinit.c
@@ -0,0 +1,105 @@
+/*  Spurious_driver
+ *
+ *  This routine installs spurious interrupt handlers for the mrm.
+ *
+ *  Input parameters:  NONE
+ *
+ *  Output parameters:  NONE
+ *
+ *  COPYRIGHT (c) 1989, 1990, 1991, 1992, 1993.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: spinit.c,v 1.5 2004/04/21 10:42:52 ralf Exp $
+ */
+
+#include <bsp.h>
+#include <stdio.h>
+
+const char * const _Spurious_Error_[] = {"Reset","Bus Error","Address Error",
+   "Illegal Instruction","Zero Division","CHK, CHK2 Instruction",
+   "TRAPcc, TRAPV Instruction","Privilege Violation","Trace",
+   "Line 1010 Emulation","Line 1111 Emulation","Hardware Breakpoint",
+   "Coprocessor Protocal Violation",
+   "Format Error ans Uninitialized Interrupt","Unassigned",
+   "Spurious Interrupt","AVec1","AVec2","AVec3","AVec4","AVec5","AVec6",
+   "AVec7","Trap Instruction","Debug","Reboot","Reserved Coprocessor",
+   "Reserved Unassigned","User Defined"};
+
+rtems_isr Spurious_Isr(
+  rtems_vector_number vector
+)
+{
+  //int sp = 0;
+#if 0
+  const char * const VectDescrip[] = {
+    _Spurious_Error_[0],   _Spurious_Error_[0],  _Spurious_Error_[1],
+    _Spurious_Error_[2],   _Spurious_Error_[3],  _Spurious_Error_[4],
+    _Spurious_Error_[5],   _Spurious_Error_[6],  _Spurious_Error_[7],
+    _Spurious_Error_[8],   _Spurious_Error_[9], _Spurious_Error_[10],
+    _Spurious_Error_[11], _Spurious_Error_[12], _Spurious_Error_[13],
+    _Spurious_Error_[13], _Spurious_Error_[14], _Spurious_Error_[14],
+    _Spurious_Error_[14], _Spurious_Error_[14], _Spurious_Error_[14],
+    _Spurious_Error_[14], _Spurious_Error_[14], _Spurious_Error_[14],
+    _Spurious_Error_[15], _Spurious_Error_[16], _Spurious_Error_[17],
+    _Spurious_Error_[18], _Spurious_Error_[19], _Spurious_Error_[20],
+    _Spurious_Error_[21], _Spurious_Error_[22], _Spurious_Error_[23],
+    _Spurious_Error_[24], _Spurious_Error_[23], _Spurious_Error_[23],
+    _Spurious_Error_[23], _Spurious_Error_[23], _Spurious_Error_[23],
+    _Spurious_Error_[23], _Spurious_Error_[23], _Spurious_Error_[23],
+    _Spurious_Error_[23], _Spurious_Error_[23], _Spurious_Error_[23],
+    _Spurious_Error_[23], _Spurious_Error_[23], _Spurious_Error_[25],
+    _Spurious_Error_[26], _Spurious_Error_[26], _Spurious_Error_[26],
+    _Spurious_Error_[26], _Spurious_Error_[26], _Spurious_Error_[26],
+    _Spurious_Error_[26], _Spurious_Error_[26], _Spurious_Error_[26],
+    _Spurious_Error_[26], _Spurious_Error_[26], _Spurious_Error_[27],
+    _Spurious_Error_[27], _Spurious_Error_[27], _Spurious_Error_[27],
+    _Spurious_Error_[27], _Spurious_Error_[28]};
+#endif
+
+  //asm volatile ( "movea.l   %%sp,%0 " : "=a" (sp) : "0" (sp) );
+
+  _CPU_ISR_Set_level( 7 );
+  //_UART_flush();
+#if 0
+  RAW_PUTS("\n\rRTEMS: Spurious interrupt: ");
+  RAW_PUTS((char *)VectDescrip[( (vector>64) ? 64 : vector )]);
+  RAW_PUTS("\n\rRTEMS:    Vector: ");
+  RAW_PUTI(vector);
+  RAW_PUTS(" sp: ");
+  RAW_PUTI(sp);
+  RAW_PUTS("\n\r");
+#endif
+  bsp_cleanup();
+
+  /* BDM SIGEMT */
+  asm("  .word  0x4afa");
+
+  for(;;);
+}
+
+void Spurious_Initialize(void)
+{
+  rtems_vector_number vector;
+
+  for ( vector = 0x0 ; vector <= 0xFF ; vector++ )
+    {
+      switch (vector)
+	{
+	case 4:
+	case 9:
+	case 31:
+	case 47:
+	case 66:
+	  /* These vectors used by CPU32bug - don't overwrite them. */
+	  break;
+
+	default:
+	  (void) set_vector( Spurious_Isr, vector, 1 );
+	  break;
+	}
+    }
+}
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/startup/linkcmds
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/startup/linkcmds
@@ -0,0 +1,164 @@
+/*  linkcmds
+ *
+ *  $Id: linkcmds,v 1.5 2004/11/26 01:54:51 joel Exp $
+ */
+
+OUTPUT_ARCH(m68k)
+__DYNAMIC  =  0;
+
+/*
+ * The memory map looks like this:
+ * +--------------------+ <- low memory
+ * | .text              |
+ * |        etext       |
+ * |        ctor list   | the ctor and dtor lists are for
+ * |        dtor list   | C++ support
+ * |        _endtext    |
+ * +--------------------+
+ * | .data              | initialized data goes here
+ * |        _sdata      |
+ * |        _edata      |
+ * +--------------------+
+ * | .bss               |
+ * |        _clear_start| start of bss, cleared by crt0
+ * |        _end        | start of heap, used by sbrk()
+ * +--------------------+
+ * |    heap space      |
+ * |        _ENDHEAP    |
+ * |    stack space     | 
+ * |        __stack     | top of stack
+ * +--------------------+ <- high memory
+ */
+
+/*
+ * Declare some sizes.
+ */
+_RamBase = DEFINED(_RamBase) ? _RamBase : 0x10000;
+_RamSize = DEFINED(_RamSize) ? _RamSize : 0x70000;
+_RamEnd = _RamBase + _RamSize;
+_HeapSize = DEFINED(_HeapSize) ? _HeapSize : 0x10000;
+_StackSize = DEFINED(_StackSize) ? _StackSize : 0x2000;
+
+MEMORY
+{
+  ram     : ORIGIN = 0x10000, LENGTH = 0x70000
+}
+
+_copy_data_from_rom = 0;
+
+/*
+ * stick everything in ram (of course)
+ */
+SECTIONS
+{
+	ram : {
+		. = .;
+	} >ram
+
+        /*
+         * Text, data and bss segments
+         */
+        .text : {
+                *(.text)
+
+		/*
+		 * C++ constructors/destructors
+		 */
+		*(.gnu.linkonce.t.*)
+
+		/*
+		 * Initialization and finalization code.
+     		 *
+     		 * Various files can provide initialization and finalization
+		 * functions.  crtbegin.o and crtend.o are two instances. The
+		 * body of these functions are in .init and .fini sections. We
+		 * accumulate the bodies here, and prepend function prologues
+		 * from crti.o and function epilogues from crtn.o. crti.o must
+		 * be linked first; crtn.o must be linked last.  Because these
+		 * are wildcards, it doesn't matter if the user does not
+		 * actually link against crti.o and crtn.o; the linker won't
+		 * look for a file to match a wildcard.  The wildcard also
+		 * means that it doesn't matter which directory crti.o and
+		 * crtn.o are in. 
+		 */
+		PROVIDE (_init = .);
+		*crti.o(.init)
+		*(.init)
+		*crtn.o(.init)
+		PROVIDE (_fini = .);
+		*crti.o(.fini)
+		*(.fini)
+		*crtn.o(.fini)
+
+		/*
+		 * Special FreeBSD sysctl sections.
+		 */
+		. = ALIGN (16);
+		__start_set_sysctl_set = .;
+		*(set_sysctl_*);
+		__stop_set_sysctl_set = ABSOLUTE(.);
+		*(set_domain_*);
+		*(set_pseudo_*);
+
+		/*
+		 * C++ constructors/destructors
+     		 *
+     		 * gcc uses crtbegin.o to find the start of the constructors
+		 * and destructors so we make sure it is first.  Because this
+		 * is a wildcard, it doesn't matter if the user does not
+		 * actually link against crtbegin.o; the linker won't look for
+		 * a file to match a wildcard.  The wildcard also means that
+		 * it doesn't matter which directory crtbegin.o is in. The
+		 * constructor and destructor list are terminated in
+		 * crtend.o.  The same comments apply to it.
+		 */
+		. = ALIGN (16);
+		*crtbegin.o(.ctors)
+		*(.ctors)
+		*crtend.o(.ctors)
+		*crtbegin.o(.dtors)
+		*(.dtors)
+		*crtend.o(.dtors)
+
+		/*
+		 * Exception frame info
+		 */
+		. = ALIGN (16);
+		*(.eh_frame)
+
+		/*
+		 * Read-only data
+		 */
+		. = ALIGN (16);
+		_rodata_start = .;
+		*(.rodata*)
+		*(.gnu.linkonce.r*)
+
+                 . = ALIGN (16);
+                PROVIDE (_etext = .);
+        } >ram
+        .data : {
+                PROVIDE (_copy_start = .);
+                *(.data)
+		*(.gnu.linkonce.d*)
+		*(.gcc_except_table)
+		*(.jcr)
+                . = ALIGN (16);
+                PROVIDE (_edata = .);
+                PROVIDE (_copy_end = .);
+        } >ram
+        .bss : {
+                _clear_start = .;
+                *(.dynbss)
+                *(.bss .bss.* .gnu.linkonce.b.*)
+                *(COMMON)
+                . = ALIGN (16);
+                PROVIDE (end = .);
+                . += _StackSize;
+                . = ALIGN (16);
+                _stack_init = .;
+                _clear_end = .;
+
+                _WorkspaceBase = .;
+        } >ram
+}
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/bsp_specs
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/bsp_specs
@@ -0,0 +1,16 @@
+%rename endfile old_endfile
+%rename startfile old_startfile
+%rename link old_link
+
+*startfile:
+%{!qrtems: %(old_startfile)} %{!nostdlib: %{qrtems: \
+%{!qrtems_debug: start.o%s} \
+%{qrtems_debug: start_g.o%s} \
+crti.o%s crtbegin.o%s}}
+
+*link:
+%{!qrtems: %(old_link)} %{qrtems: -dc -dp -N -e start}
+
+*endfile:
+%{!qrtems: %(old_endfile)} %{qrtems: crtend.o%s crtn.o%s}
+
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/include/.cvsignore
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/include/.cvsignore
@@ -0,0 +1,5 @@
+bspopts.h
+bspopts.h.in
+coverhd.h
+stamp-h
+stamp-h.in
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/aclocal.m4
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/aclocal.m4
@@ -0,0 +1,896 @@
+# generated automatically by aclocal 1.9.5 -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+# 2005  Free Software Foundation, Inc.
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+# Copyright (C) 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_AUTOMAKE_VERSION(VERSION)
+# ----------------------------
+# Automake X.Y traces this macro to ensure aclocal.m4 has been
+# generated from the m4 files accompanying Automake X.Y.
+AC_DEFUN([AM_AUTOMAKE_VERSION], [am__api_version="1.9"])
+
+# AM_SET_CURRENT_AUTOMAKE_VERSION
+# -------------------------------
+# Call AM_AUTOMAKE_VERSION so it can be traced.
+# This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
+AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
+	 [AM_AUTOMAKE_VERSION([1.9.5])])
+
+# AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
+# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
+# `$srcdir', `$srcdir/..', or `$srcdir/../..'.
+#
+# Of course, Automake must honor this variable whenever it calls a
+# tool from the auxiliary directory.  The problem is that $srcdir (and
+# therefore $ac_aux_dir as well) can be either absolute or relative,
+# depending on how configure is run.  This is pretty annoying, since
+# it makes $ac_aux_dir quite unusable in subdirectories: in the top
+# source directory, any form will work fine, but in subdirectories a
+# relative path needs to be adjusted first.
+#
+# $ac_aux_dir/missing
+#    fails when called from a subdirectory if $ac_aux_dir is relative
+# $top_srcdir/$ac_aux_dir/missing
+#    fails if $ac_aux_dir is absolute,
+#    fails when called from a subdirectory in a VPATH build with
+#          a relative $ac_aux_dir
+#
+# The reason of the latter failure is that $top_srcdir and $ac_aux_dir
+# are both prefixed by $srcdir.  In an in-source build this is usually
+# harmless because $srcdir is `.', but things will broke when you
+# start a VPATH build or use an absolute $srcdir.
+#
+# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
+# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:
+#   am_aux_dir='\$(top_srcdir)/'`expr "$ac_aux_dir" : "$srcdir//*\(.*\)"`
+# and then we would define $MISSING as
+#   MISSING="\${SHELL} $am_aux_dir/missing"
+# This will work as long as MISSING is not called from configure, because
+# unfortunately $(top_srcdir) has no meaning in configure.
+# However there are other variables, like CC, which are often used in
+# configure, and could therefore not use this "fixed" $ac_aux_dir.
+#
+# Another solution, used here, is to always expand $ac_aux_dir to an
+# absolute PATH.  The drawback is that using absolute paths prevent a
+# configured tree to be moved without reconfiguration.
+
+AC_DEFUN([AM_AUX_DIR_EXPAND],
+[dnl Rely on autoconf to set up CDPATH properly.
+AC_PREREQ([2.50])dnl
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+])
+
+# AM_CONDITIONAL                                            -*- Autoconf -*-
+
+# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 7
+
+# AM_CONDITIONAL(NAME, SHELL-CONDITION)
+# -------------------------------------
+# Define a conditional.
+AC_DEFUN([AM_CONDITIONAL],
+[AC_PREREQ(2.52)dnl
+ ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
+	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
+AC_SUBST([$1_TRUE])
+AC_SUBST([$1_FALSE])
+if $2; then
+  $1_TRUE=
+  $1_FALSE='#'
+else
+  $1_TRUE='#'
+  $1_FALSE=
+fi
+AC_CONFIG_COMMANDS_PRE(
+[if test -z "${$1_TRUE}" && test -z "${$1_FALSE}"; then
+  AC_MSG_ERROR([[conditional "$1" was never defined.
+Usually this means the macro was only invoked conditionally.]])
+fi])])
+
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 8
+
+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
+# written in clear, in which case automake, when reading aclocal.m4,
+# will think it sees a *use*, and therefore will trigger all it's
+# C support machinery.  Also note that it means that autoscan, seeing
+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...
+
+
+# _AM_DEPENDENCIES(NAME)
+# ----------------------
+# See how the compiler implements dependency checking.
+# NAME is "CC", "CXX", "GCJ", or "OBJC".
+# We try a few techniques and use that to set a single cache variable.
+#
+# We don't AC_REQUIRE the corresponding AC_PROG_CC since the latter was
+# modified to invoke _AM_DEPENDENCIES(CC); we would have a circular
+# dependency, and given that the user is not expected to run this macro,
+# just rely on AC_PROG_CC.
+AC_DEFUN([_AM_DEPENDENCIES],
+[AC_REQUIRE([AM_SET_DEPDIR])dnl
+AC_REQUIRE([AM_OUTPUT_DEPENDENCY_COMMANDS])dnl
+AC_REQUIRE([AM_MAKE_INCLUDE])dnl
+AC_REQUIRE([AM_DEP_TRACK])dnl
+
+ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
+       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
+       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
+       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
+                   [depcc="$$1"   am_compiler_list=])
+
+AC_CACHE_CHECK([dependency style of $depcc],
+               [am_cv_$1_dependencies_compiler_type],
+[if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_$1_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
+  fi
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    case $depmode in
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    none) break ;;
+    esac
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.
+    if depmode=$depmode \
+       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_$1_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_$1_dependencies_compiler_type=none
+fi
+])
+AC_SUBST([$1DEPMODE], [depmode=$am_cv_$1_dependencies_compiler_type])
+AM_CONDITIONAL([am__fastdep$1], [
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_$1_dependencies_compiler_type" = gcc3])
+])
+
+
+# AM_SET_DEPDIR
+# -------------
+# Choose a directory name for dependency files.
+# This macro is AC_REQUIREd in _AM_DEPENDENCIES
+AC_DEFUN([AM_SET_DEPDIR],
+[AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
+])
+
+
+# AM_DEP_TRACK
+# ------------
+AC_DEFUN([AM_DEP_TRACK],
+[AC_ARG_ENABLE(dependency-tracking,
+[  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors])
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+fi
+AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
+AC_SUBST([AMDEPBACKSLASH])
+])
+
+# Generate code to set up dependency tracking.              -*- Autoconf -*-
+
+# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+#serial 3
+
+# _AM_OUTPUT_DEPENDENCY_COMMANDS
+# ------------------------------
+AC_DEFUN([_AM_OUTPUT_DEPENDENCY_COMMANDS],
+[for mf in $CONFIG_FILES; do
+  # Strip MF so we end up with the name of the file.
+  mf=`echo "$mf" | sed -e 's/:.*$//'`
+  # Check whether this is an Automake generated Makefile or not.
+  # We used to match only the files named `Makefile.in', but
+  # some people rename them; so instead we look at the file content.
+  # Grep'ing the first line is not enough: some people post-process
+  # each Makefile.in and add a new line on top of each file to say so.
+  # So let's grep whole file.
+  if grep '^#.*generated by automake' $mf > /dev/null 2>&1; then
+    dirpart=`AS_DIRNAME("$mf")`
+  else
+    continue
+  fi
+  # Extract the definition of DEPDIR, am__include, and am__quote
+  # from the Makefile without running `make'.
+  DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+  test -z "$DEPDIR" && continue
+  am__include=`sed -n 's/^am__include = //p' < "$mf"`
+  test -z "am__include" && continue
+  am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+  # When using ansi2knr, U may be empty or an underscore; expand it
+  U=`sed -n 's/^U = //p' < "$mf"`
+  # Find all dependency output files, they are included files with
+  # $(DEPDIR) in their names.  We invoke sed twice because it is the
+  # simplest approach to changing $(DEPDIR) to its actual value in the
+  # expansion.
+  for file in `sed -n "
+    s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+       sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+    # Make sure the directory exists.
+    test -f "$dirpart/$file" && continue
+    fdir=`AS_DIRNAME(["$file"])`
+    AS_MKDIR_P([$dirpart/$fdir])
+    # echo "creating $dirpart/$file"
+    echo '# dummy' > "$dirpart/$file"
+  done
+done
+])# _AM_OUTPUT_DEPENDENCY_COMMANDS
+
+
+# AM_OUTPUT_DEPENDENCY_COMMANDS
+# -----------------------------
+# This macro should only be invoked once -- use via AC_REQUIRE.
+#
+# This code is only required when automatic dependency tracking
+# is enabled.  FIXME.  This creates each `.P' file that we will
+# need in order to bootstrap the dependency handling code.
+AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
+[AC_CONFIG_COMMANDS([depfiles],
+     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
+     [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
+])
+
+# Do all the work for Automake.                             -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 12
+
+# This macro actually does too much.  Some checks are only needed if
+# your package does certain things.  But this isn't really a big deal.
+
+# AM_INIT_AUTOMAKE(PACKAGE, VERSION, [NO-DEFINE])
+# AM_INIT_AUTOMAKE([OPTIONS])
+# -----------------------------------------------
+# The call with PACKAGE and VERSION arguments is the old style
+# call (pre autoconf-2.50), which is being phased out.  PACKAGE
+# and VERSION should now be passed to AC_INIT and removed from
+# the call to AM_INIT_AUTOMAKE.
+# We support both call styles for the transition.  After
+# the next Automake release, Autoconf can make the AC_INIT
+# arguments mandatory, and then we can depend on a new Autoconf
+# release and drop the old call support.
+AC_DEFUN([AM_INIT_AUTOMAKE],
+[AC_PREREQ([2.58])dnl
+dnl Autoconf wants to disallow AM_ names.  We explicitly allow
+dnl the ones we care about.
+m4_pattern_allow([^AM_[A-Z]+FLAGS$])dnl
+AC_REQUIRE([AM_SET_CURRENT_AUTOMAKE_VERSION])dnl
+AC_REQUIRE([AC_PROG_INSTALL])dnl
+# test to see if srcdir already configured
+if test "`cd $srcdir && pwd`" != "`pwd`" &&
+   test -f $srcdir/config.status; then
+  AC_MSG_ERROR([source directory already configured; run "make distclean" there first])
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+AC_SUBST([CYGPATH_W])
+
+# Define the identity of the package.
+dnl Distinguish between old-style and new-style calls.
+m4_ifval([$2],
+[m4_ifval([$3], [_AM_SET_OPTION([no-define])])dnl
+ AC_SUBST([PACKAGE], [$1])dnl
+ AC_SUBST([VERSION], [$2])],
+[_AM_SET_OPTIONS([$1])dnl
+ AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
+ AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
+
+_AM_IF_OPTION([no-define],,
+[AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
+ AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
+
+# Some tools Automake needs.
+AC_REQUIRE([AM_SANITY_CHECK])dnl
+AC_REQUIRE([AC_ARG_PROGRAM])dnl
+AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
+AM_MISSING_PROG(AUTOCONF, autoconf)
+AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
+AM_MISSING_PROG(AUTOHEADER, autoheader)
+AM_MISSING_PROG(MAKEINFO, makeinfo)
+AM_PROG_INSTALL_SH
+AM_PROG_INSTALL_STRIP
+AC_REQUIRE([AM_PROG_MKDIR_P])dnl
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+AC_REQUIRE([AC_PROG_AWK])dnl
+AC_REQUIRE([AC_PROG_MAKE_SET])dnl
+AC_REQUIRE([AM_SET_LEADING_DOT])dnl
+_AM_IF_OPTION([tar-ustar], [_AM_PROG_TAR([ustar])],
+              [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],
+	      		     [_AM_PROG_TAR([v7])])])
+_AM_IF_OPTION([no-dependencies],,
+[AC_PROVIDE_IFELSE([AC_PROG_CC],
+                  [_AM_DEPENDENCIES(CC)],
+                  [define([AC_PROG_CC],
+                          defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
+AC_PROVIDE_IFELSE([AC_PROG_CXX],
+                  [_AM_DEPENDENCIES(CXX)],
+                  [define([AC_PROG_CXX],
+                          defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
+])
+])
+
+
+# When config.status generates a header, we must update the stamp-h file.
+# This file resides in the same directory as the config header
+# that is generated.  The stamp files are numbered to have different names.
+
+# Autoconf calls _AC_AM_CONFIG_HEADER_HOOK (when defined) in the
+# loop where config.status creates the headers, so we can generate
+# our stamp files there.
+AC_DEFUN([_AC_AM_CONFIG_HEADER_HOOK],
+[# Compute $1's index in $config_headers.
+_am_stamp_count=1
+for _am_header in $config_headers :; do
+  case $_am_header in
+    $1 | $1:* )
+      break ;;
+    * )
+      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
+  esac
+done
+echo "timestamp for $1" >`AS_DIRNAME([$1])`/stamp-h[]$_am_stamp_count])
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_SH
+# ------------------
+# Define $install_sh.
+AC_DEFUN([AM_PROG_INSTALL_SH],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+install_sh=${install_sh-"$am_aux_dir/install-sh"}
+AC_SUBST(install_sh)])
+
+# Copyright (C) 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# Check whether the underlying file-system supports filenames
+# with a leading dot.  For instance MS-DOS doesn't.
+AC_DEFUN([AM_SET_LEADING_DOT],
+[rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+AC_SUBST([am__leading_dot])])
+
+# Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
+# From Jim Meyering
+
+# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+AC_DEFUN([AM_MAINTAINER_MODE],
+[AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
+  dnl maintainer-mode is disabled by default
+  AC_ARG_ENABLE(maintainer-mode,
+[  --enable-maintainer-mode  enable make rules and dependencies not useful
+			  (and sometimes confusing) to the casual installer],
+      USE_MAINTAINER_MODE=$enableval,
+      USE_MAINTAINER_MODE=no)
+  AC_MSG_RESULT([$USE_MAINTAINER_MODE])
+  AM_CONDITIONAL(MAINTAINER_MODE, [test $USE_MAINTAINER_MODE = yes])
+  MAINT=$MAINTAINER_MODE_TRUE
+  AC_SUBST(MAINT)dnl
+]
+)
+
+AU_DEFUN([jm_MAINTAINER_MODE], [AM_MAINTAINER_MODE])
+
+# Check to see how 'make' treats includes.	            -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 3
+
+# AM_MAKE_INCLUDE()
+# -----------------
+# Check to see how make treats includes.
+AC_DEFUN([AM_MAKE_INCLUDE],
+[am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo done
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+AC_MSG_CHECKING([for style of include used by $am_make])
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# We grep out `Entering directory' and `Leaving directory'
+# messages which can occur if `w' ends up in MAKEFLAGS.
+# In particular we don't look at `^make:' because GNU make might
+# be invoked under some other name (usually "gmake"), in which
+# case it prints its new name instead of `make'.
+if test "`$am_make -s -f confmf 2> /dev/null | grep -v 'ing directory'`" = "done"; then
+   am__include=include
+   am__quote=
+   _am_result=GNU
+fi
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   if test "`$am_make -s -f confmf 2> /dev/null`" = "done"; then
+      am__include=.include
+      am__quote="\""
+      _am_result=BSD
+   fi
+fi
+AC_SUBST([am__include])
+AC_SUBST([am__quote])
+AC_MSG_RESULT([$_am_result])
+rm -f confinc confmf
+])
+
+# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
+
+# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# AM_MISSING_PROG(NAME, PROGRAM)
+# ------------------------------
+AC_DEFUN([AM_MISSING_PROG],
+[AC_REQUIRE([AM_MISSING_HAS_RUN])
+$1=${$1-"${am_missing_run}$2"}
+AC_SUBST($1)])
+
+
+# AM_MISSING_HAS_RUN
+# ------------------
+# Define MISSING if not defined so far and test if it supports --run.
+# If it does, set am_missing_run to use it, otherwise, to nothing.
+AC_DEFUN([AM_MISSING_HAS_RUN],
+[AC_REQUIRE([AM_AUX_DIR_EXPAND])dnl
+test x"${MISSING+set}" = xset || MISSING="\${SHELL} $am_aux_dir/missing"
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  AC_MSG_WARN([`missing' script is too old or missing])
+fi
+])
+
+# Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_MKDIR_P
+# ---------------
+# Check whether `mkdir -p' is supported, fallback to mkinstalldirs otherwise.
+#
+# Automake 1.8 used `mkdir -m 0755 -p --' to ensure that directories
+# created by `make install' are always world readable, even if the
+# installer happens to have an overly restrictive umask (e.g. 077).
+# This was a mistake.  There are at least two reasons why we must not
+# use `-m 0755':
+#   - it causes special bits like SGID to be ignored,
+#   - it may be too restrictive (some setups expect 775 directories).
+#
+# Do not use -m 0755 and let people choose whatever they expect by
+# setting umask.
+#
+# We cannot accept any implementation of `mkdir' that recognizes `-p'.
+# Some implementations (such as Solaris 8's) are not thread-safe: if a
+# parallel make tries to run `mkdir -p a/b' and `mkdir -p a/c'
+# concurrently, both version can detect that a/ is missing, but only
+# one can create it and the other will error out.  Consequently we
+# restrict ourselves to GNU make (using the --version option ensures
+# this.)
+AC_DEFUN([AM_PROG_MKDIR_P],
+[if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
+  # We used to keeping the `.' as first argument, in order to
+  # allow $(mkdir_p) to be used without argument.  As in
+  #   $(mkdir_p) $(somedir)
+  # where $(somedir) is conditionally defined.  However this is wrong
+  # for two reasons:
+  #  1. if the package is installed by a user who cannot write `.'
+  #     make install will fail,
+  #  2. the above comment should most certainly read
+  #     $(mkdir_p) $(DESTDIR)$(somedir)
+  #     so it does not work when $(somedir) is undefined and
+  #     $(DESTDIR) is not.
+  #  To support the latter case, we have to write
+  #     test -z "$(somedir)" || $(mkdir_p) $(DESTDIR)$(somedir),
+  #  so the `.' trick is pointless.
+  mkdir_p='mkdir -p --'
+else
+  # On NextStep and OpenStep, the `mkdir' command does not
+  # recognize any option.  It will interpret all options as
+  # directories to create, and then abort because `.' already
+  # exists.
+  for d in ./-p ./--version;
+  do
+    test -d $d && rmdir $d
+  done
+  # $(mkinstalldirs) is defined by Automake if mkinstalldirs exists.
+  if test -f "$ac_aux_dir/mkinstalldirs"; then
+    mkdir_p='$(mkinstalldirs)'
+  else
+    mkdir_p='$(install_sh) -d'
+  fi
+fi
+AC_SUBST([mkdir_p])])
+
+# Helper functions for option handling.                     -*- Autoconf -*-
+
+# Copyright (C) 2001, 2002, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 3
+
+# _AM_MANGLE_OPTION(NAME)
+# -----------------------
+AC_DEFUN([_AM_MANGLE_OPTION],
+[[_AM_OPTION_]m4_bpatsubst($1, [[^a-zA-Z0-9_]], [_])])
+
+# _AM_SET_OPTION(NAME)
+# ------------------------------
+# Set option NAME.  Presently that only means defining a flag for this option.
+AC_DEFUN([_AM_SET_OPTION],
+[m4_define(_AM_MANGLE_OPTION([$1]), 1)])
+
+# _AM_SET_OPTIONS(OPTIONS)
+# ----------------------------------
+# OPTIONS is a space-separated list of Automake options.
+AC_DEFUN([_AM_SET_OPTIONS],
+[AC_FOREACH([_AM_Option], [$1], [_AM_SET_OPTION(_AM_Option)])])
+
+# _AM_IF_OPTION(OPTION, IF-SET, [IF-NOT-SET])
+# -------------------------------------------
+# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
+AC_DEFUN([_AM_IF_OPTION],
+[m4_ifset(_AM_MANGLE_OPTION([$1]), [$2], [$3])])
+
+# Check to make sure that the build environment is sane.    -*- Autoconf -*-
+
+# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005
+# Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 4
+
+# AM_SANITY_CHECK
+# ---------------
+AC_DEFUN([AM_SANITY_CHECK],
+[AC_MSG_CHECKING([whether build environment is sane])
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt $srcdir/configure conftest.file 2> /dev/null`
+   if test "$[*]" = "X"; then
+      # -L didn't work.
+      set X `ls -t $srcdir/configure conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$[*]" != "X $srcdir/configure conftest.file" \
+      && test "$[*]" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+alias in your environment])
+   fi
+
+   test "$[2]" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   AC_MSG_ERROR([newly created file is older than distributed files!
+Check your system clock])
+fi
+AC_MSG_RESULT(yes)])
+
+# Copyright (C) 2001, 2003, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# AM_PROG_INSTALL_STRIP
+# ---------------------
+# One issue with vendor `install' (even GNU) is that you can't
+# specify the program used to strip binaries.  This is especially
+# annoying in cross-compiling environments, where the build's strip
+# is unlikely to handle the host's binaries.
+# Fortunately install-sh will honor a STRIPPROG variable, so we
+# always use install-sh in `make install-strip', and initialize
+# STRIPPROG with the value of the STRIP variable (set by the user).
+AC_DEFUN([AM_PROG_INSTALL_STRIP],
+[AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
+if test "$cross_compiling" != no; then
+  AC_CHECK_TOOL([STRIP], [strip], :)
+fi
+INSTALL_STRIP_PROGRAM="\${SHELL} \$(install_sh) -c -s"
+AC_SUBST([INSTALL_STRIP_PROGRAM])])
+
+# Check how to create a tarball.                            -*- Autoconf -*-
+
+# Copyright (C) 2004, 2005  Free Software Foundation, Inc.
+#
+# This file is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# serial 2
+
+# _AM_PROG_TAR(FORMAT)
+# --------------------
+# Check how to create a tarball in format FORMAT.
+# FORMAT should be one of `v7', `ustar', or `pax'.
+#
+# Substitute a variable $(am__tar) that is a command
+# writing to stdout a FORMAT-tarball containing the directory
+# $tardir.
+#     tardir=directory && $(am__tar) > result.tar
+#
+# Substitute a variable $(am__untar) that extract such
+# a tarball read from stdin.
+#     $(am__untar) < result.tar
+AC_DEFUN([_AM_PROG_TAR],
+[# Always define AMTAR for backward compatibility.
+AM_MISSING_PROG([AMTAR], [tar])
+m4_if([$1], [v7],
+     [am__tar='${AMTAR} chof - "$$tardir"'; am__untar='${AMTAR} xf -'],
+     [m4_case([$1], [ustar],, [pax],,
+              [m4_fatal([Unknown tar format])])
+AC_MSG_CHECKING([how to create a $1 tar archive])
+# Loop over all known methods to create a tar archive until one works.
+_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
+_am_tools=${am_cv_prog_tar_$1-$_am_tools}
+# Do not fold the above two line into one, because Tru64 sh and
+# Solaris sh will not grok spaces in the rhs of `-'.
+for _am_tool in $_am_tools
+do
+  case $_am_tool in
+  gnutar)
+    for _am_tar in tar gnutar gtar;
+    do
+      AM_RUN_LOG([$_am_tar --version]) && break
+    done
+    am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
+    am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
+    am__untar="$_am_tar -xf -"
+    ;;
+  plaintar)
+    # Must skip GNU tar: if it does not support --format= it doesn't create
+    # ustar tarball either.
+    (tar --version) >/dev/null 2>&1 && continue
+    am__tar='tar chf - "$$tardir"'
+    am__tar_='tar chf - "$tardir"'
+    am__untar='tar xf -'
+    ;;
+  pax)
+    am__tar='pax -L -x $1 -w "$$tardir"'
+    am__tar_='pax -L -x $1 -w "$tardir"'
+    am__untar='pax -r'
+    ;;
+  cpio)
+    am__tar='find "$$tardir" -print | cpio -o -H $1 -L'
+    am__tar_='find "$tardir" -print | cpio -o -H $1 -L'
+    am__untar='cpio -i -H $1 -d'
+    ;;
+  none)
+    am__tar=false
+    am__tar_=false
+    am__untar=false
+    ;;
+  esac
+
+  # If the value was cached, stop now.  We just wanted to have am__tar
+  # and am__untar set.
+  test -n "${am_cv_prog_tar_$1}" && break
+
+  # tar/untar a dummy directory, and stop if the command works
+  rm -rf conftest.dir
+  mkdir conftest.dir
+  echo GrepMe > conftest.dir/file
+  AM_RUN_LOG([tardir=conftest.dir && eval $am__tar_ >conftest.tar])
+  rm -rf conftest.dir
+  if test -s conftest.tar; then
+    AM_RUN_LOG([$am__untar <conftest.tar])
+    grep GrepMe conftest.dir/file >/dev/null 2>&1 && break
+  fi
+done
+rm -rf conftest.dir
+
+AC_CACHE_VAL([am_cv_prog_tar_$1], [am_cv_prog_tar_$1=$_am_tool])
+AC_MSG_RESULT([$am_cv_prog_tar_$1])])
+AC_SUBST([am__tar])
+AC_SUBST([am__untar])
+]) # _AM_PROG_TAR
+
+m4_include([../../../../aclocal/bsp-configure.m4])
+m4_include([../../../../aclocal/canonical-target-name.m4])
+m4_include([../../../../aclocal/canonicalize-tools.m4])
+m4_include([../../../../aclocal/check-custom-bsp.m4])
+m4_include([../../../../aclocal/check-multiprocessing.m4])
+m4_include([../../../../aclocal/check-tool.m4])
+m4_include([../../../../aclocal/enable-multiprocessing.m4])
+m4_include([../../../../aclocal/env-rtemsbsp.m4])
+m4_include([../../../../aclocal/gcc-isystem.m4])
+m4_include([../../../../aclocal/gcc-pipe.m4])
+m4_include([../../../../aclocal/gcc-specs.m4])
+m4_include([../../../../aclocal/multilib.m4])
+m4_include([../../../../aclocal/prog-cc.m4])
+m4_include([../../../../aclocal/prog-ccas.m4])
+m4_include([../../../../aclocal/project-root.m4])
+m4_include([../../../../aclocal/rtems-top.m4])
+m4_include([../../../../aclocal/version.m4])
Index: rtems-051009/c/src/lib/libbsp/m68k/mo376/wrapup/.keep
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/m68k/mo376/wrapup/.keep
@@ -0,0 +1 @@
+
