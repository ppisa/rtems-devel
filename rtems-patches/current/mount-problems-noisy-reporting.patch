Index: rtems-051009/cpukit/libcsupport/src/mount.c
===================================================================
--- rtems-051009.orig/cpukit/libcsupport/src/mount.c
+++ rtems-051009/cpukit/libcsupport/src/mount.c
@@ -85,9 +85,9 @@ int mount(
   /*
    *  Is there a file system operations table?
    */
-
   if ( fs_ops == NULL ) {
     errno = EINVAL;
+    printk("mount: fs_ops cannot be zero\n",mount_point);
     return -1;
   }
 
@@ -98,12 +98,14 @@ int mount(
   if ( options != RTEMS_FILESYSTEM_READ_ONLY &&
        options != RTEMS_FILESYSTEM_READ_WRITE ) {
     errno = EINVAL;
+    printk("mount: bad options\n");
     return -1;
   }
 
   /* Do they support being mounted at all ? */
   if ( !fs_ops->fsmount_me_h ) {
     errno = ENOTSUP;
+    printk("mount: mounting not supported for this fs\n");
     goto cleanup_and_bail;
   }
 
@@ -118,6 +120,7 @@ int mount(
    temp_mt_entry = malloc( size );
 
    if ( !temp_mt_entry ) {
+     printk("mount: cannot allocate memory for temp_mt_entry\n");
      errno = ENOMEM;
      return -1;
    }
@@ -139,8 +142,10 @@ int mount(
   if ( mount_point ) {
 
     if ( rtems_filesystem_evaluate_path(
-            mount_point, RTEMS_LIBIO_PERMS_RWX, &loc, TRUE ) == -1 )
+            mount_point, RTEMS_LIBIO_PERMS_RWX, &loc, TRUE ) == -1 ){
+      printk("mount: evaluate mount point path \"%s\" failed\n",mount_point);
       goto cleanup_and_bail;
+    }
 
     loc_to_free = &loc;
 
@@ -150,6 +155,7 @@ int mount(
 
     if (!loc.ops->node_type_h) {
       errno =  ENOTSUP;
+      printk("mount: mount point \"%s\" has no node_type_h\n",mount_point);
       goto cleanup_and_bail;
     }
 
@@ -159,6 +165,7 @@ int mount(
 
     if ( loc.ops->node_type_h( &loc ) != RTEMS_FILESYSTEM_DIRECTORY ) {
       errno = ENOTDIR;
+      printk("mount: mount point \"%s\" is not a directory\n",mount_point);
       goto cleanup_and_bail;
     }
 
@@ -168,6 +175,7 @@ int mount(
 
     if ( Is_node_fs_root(  &loc ) ){
       errno = EBUSY;
+      printk("mount: mount point \"%s\" Is_node_fs_root\n",mount_point);
       goto cleanup_and_bail;
     }
 
@@ -191,10 +199,12 @@ int mount(
 
     if ( !loc.ops->mount_h ){
       errno = ENOTSUP;
+      printk("mount: mount point \"%s\" does not support mount_h\n",mount_point);
       goto cleanup_and_bail;
     }
 
     if ( loc.ops->mount_h( temp_mt_entry ) ) {
+      printk("mount: mount_h at mount point \"%s\" failed\n",mount_point);
       goto cleanup_and_bail;
     }
   } else {
@@ -220,6 +230,7 @@ int mount(
 	if ( loc.ops->unmount_h ) {
 		loc.ops->unmount_h( temp_mt_entry );
     }
+    printk("mount: unmounting because problem arose\n",mount_point);
     goto cleanup_and_bail;
   }
 
@@ -240,6 +251,7 @@ cleanup_and_bail:
   if ( loc_to_free )
     rtems_filesystem_freenode( loc_to_free );
 
+  printk("mount: bailing out\n");
   return -1;
 }
 
Index: rtems-051009/cpukit/libmisc/fsmount/fsmount.c
===================================================================
--- rtems-051009.orig/cpukit/libmisc/fsmount/fsmount.c
+++ rtems-051009/cpukit/libmisc/fsmount/fsmount.c
@@ -160,13 +160,15 @@ int rtems_fsmount
 		     fstab_ptr->mount_options,
 		     fstab_ptr->dev,
 		     fstab_ptr->mount_point);
+      
       if (tmp_rc != RTEMS_SUCCESSFUL) {
 	if (0 != (fstab_ptr->report_reasons & FSMOUNT_MNT_FAILED)) {
 	  fprintf(stdout,"fsmount: mounting of \"%s\" to"
-		 " \"%s\" failed: %s\n",
+		 " \"%s\" failed: %s , tmp_rc=%d\n",
 		 fstab_ptr->dev,
 		 fstab_ptr->mount_point,
-		 strerror(errno));
+		 strerror(errno),
+		 tmp_rc);
 	}
 	if (0 != (fstab_ptr->abort_reasons & FSMOUNT_MNT_FAILED)) {
 	  terminate = TRUE;
Index: rtems-051009/cpukit/libfs/src/dosfs/msdos_initsupp.c
===================================================================
--- rtems-051009.orig/cpukit/libfs/src/dosfs/msdos_initsupp.c
+++ rtems-051009/cpukit/libfs/src/dosfs/msdos_initsupp.c
@@ -69,6 +69,7 @@ msdos_initialize_support(
     if (rc != RC_OK)
     {
         free(fs_info);
+	printk("msdos_initialize_support: fat_init_volume_info failed\n");
         return rc;
     }
 
@@ -84,6 +85,7 @@ msdos_initialize_support(
     {
         fat_shutdown_drive(temp_mt_entry);
         free(fs_info);
+	printk("msdos_initialize_support: fat_file_open\n");
         return rc;
     }
 
@@ -104,6 +106,7 @@ msdos_initialize_support(
         cl_buf_size = (fs_info->fat.vol.bpc > fs_info->fat.vol.rdir_size) ?
                       fs_info->fat.vol.bpc                                :
                       fs_info->fat.vol.rdir_size;
+	printk("msdos_initialize_support: FAT12/16\n");
     }
     else
     {
@@ -113,9 +116,11 @@ msdos_initialize_support(
             fat_file_close(temp_mt_entry, fat_fd);
             fat_shutdown_drive(temp_mt_entry);
             free(fs_info);
+	    printk("msdos_initialize_support: fat_file_size\n");
             return rc;
         }
         cl_buf_size = fs_info->fat.vol.bpc;
+	printk("msdos_initialize_support: FAT32\n");
     }
 
     fs_info->cl_buf = (uint8_t *)calloc(cl_buf_size, sizeof(char));
@@ -124,6 +129,7 @@ msdos_initialize_support(
         fat_file_close(temp_mt_entry, fat_fd);
         fat_shutdown_drive(temp_mt_entry);
         free(fs_info);
+        printk("msdos_initialize_support: alloc fs_info->cl_buf\n");
         set_errno_and_return_minus_one(ENOMEM);
     }
 
@@ -138,6 +144,7 @@ msdos_initialize_support(
         fat_shutdown_drive(temp_mt_entry);
         free(fs_info->cl_buf);
         free(fs_info);
+        printk("msdos_initialize_support: semaphore\n");
         set_errno_and_return_minus_one( EIO );
     }
 
Index: rtems-051009/cpukit/libfs/src/dosfs/fat.c
===================================================================
--- rtems-051009.orig/cpukit/libfs/src/dosfs/fat.c
+++ rtems-051009/cpukit/libfs/src/dosfs/fat.c
@@ -217,17 +217,23 @@ fat_init_volume_info(rtems_filesystem_mo
     int                 i = 0;
 
     rc = stat(mt_entry->dev, &stat_buf);
-    if (rc == -1)
+    if (rc == -1){
+        printk("fat_init_volume_info: stat\n");
         return rc;
+    }
 
     /* rtmes feature: no block devices, all are character devices */
-    if (!S_ISCHR(stat_buf.st_mode))
+    if (!S_ISCHR(stat_buf.st_mode)){
+        printk("fat_init_volume_info: S_ISCHR\n");
         set_errno_and_return_minus_one(ENOTBLK);
+    }
 
     /* check that  device is registred as block device and lock it */
     vol->dd = rtems_disk_lookup(stat_buf.st_dev);
-    if (vol->dd == NULL)
+    if (vol->dd == NULL){
+        printk("fat_init_volume_info: vol->dd == NULL\n");
         set_errno_and_return_minus_one(ENOTBLK);
+    }
 
     vol->dev = stat_buf.st_dev;
 
@@ -235,6 +241,7 @@ fat_init_volume_info(rtems_filesystem_mo
     if (fd == -1)
     {
         rtems_disk_release(vol->dd);
+        printk("fat_init_volume_info: open\n");
         return -1;
     }
 
@@ -243,6 +250,7 @@ fat_init_volume_info(rtems_filesystem_mo
     {
         close(fd);
         rtems_disk_release(vol->dd);
+        printk("fat_init_volume_info: read BPB\n");
         set_errno_and_return_minus_one( EIO );
     }
     close(fd);
@@ -255,6 +263,7 @@ fat_init_volume_info(rtems_filesystem_mo
          (vol->bps != 4096))
     {
         rtems_disk_release(vol->dd);
+        printk("fat_init_volume_info: vol->bps %d\n",vol->bps);
         set_errno_and_return_minus_one( EINVAL );
     }
 
@@ -271,6 +280,7 @@ fat_init_volume_info(rtems_filesystem_mo
     if (vol->spc == 0)
     {
         rtems_disk_release(vol->dd);
+        printk("fat_init_volume_info: vol->spc == 0\n");
         set_errno_and_return_minus_one(EINVAL);
     }
 
@@ -283,6 +293,7 @@ fat_init_volume_info(rtems_filesystem_mo
     if ((vol->bpc = vol->bps << vol->spc_log2) > MS_BYTES_PER_CLUSTER_LIMIT)
     {
         rtems_disk_release(vol->dd);
+        printk("fat_init_volume_info: bytes per cluster value greater than 32K is invalid\n");
         set_errno_and_return_minus_one(EINVAL);
     }
 
@@ -357,6 +368,7 @@ fat_init_volume_info(rtems_filesystem_mo
         if( vol->info_sec == 0 )
         {
             rtems_disk_release(vol->dd);
+            printk("fat_init_volume_info: FAT_GET_BR_FAT32_FS_INFO_SECTOR\n");
             set_errno_and_return_minus_one( EINVAL );
         }
         else
@@ -366,6 +378,7 @@ fat_init_volume_info(rtems_filesystem_mo
             if ( ret < 0 )
             {
                 rtems_disk_release(vol->dd);
+                printk("fat_init_volume_info: _fat_block_read 0\n");
                 return -1;
             }    
       
@@ -373,6 +386,7 @@ fat_init_volume_info(rtems_filesystem_mo
                 FAT_FSINFO_LEAD_SIGNATURE_VALUE)
             {
                 rtems_disk_release(vol->dd);
+                printk("fat_init_volume_info: FAT_GET_FSINFO_LEAD_SIGNATURE\n");
                 set_errno_and_return_minus_one( EINVAL );
             }
             else
@@ -382,6 +396,7 @@ fat_init_volume_info(rtems_filesystem_mo
                 if ( ret < 0 )
                 {
                     rtems_disk_release(vol->dd);
+                    printk("fat_init_volume_info: _fat_block_read FAT_FSI_INFO\n");
                     return -1;
                 }    
                     
@@ -392,6 +407,7 @@ fat_init_volume_info(rtems_filesystem_mo
                 if ( rc != RC_OK )
                 {
                     rtems_disk_release(vol->dd);
+                    printk("fat_init_volume_info: fat_fat32_update_fsinfo_sector\n");
                     return rc;
                 }
             }
@@ -412,6 +428,7 @@ fat_init_volume_info(rtems_filesystem_mo
     if ( fs_info->vhash == NULL )
     {
         rtems_disk_release(vol->dd);
+        printk("fat_init_volume_info: fs_info->vhash == NULL\n");
         set_errno_and_return_minus_one( ENOMEM );
     }
 
@@ -423,6 +440,7 @@ fat_init_volume_info(rtems_filesystem_mo
     {
         rtems_disk_release(vol->dd);
         free(fs_info->vhash);
+        printk("fat_init_volume_info: fs_info->rhash == NULL\n");
         set_errno_and_return_minus_one( ENOMEM );
     }
     for (i = 0; i < FAT_HASH_SIZE; i++)
@@ -437,6 +455,7 @@ fat_init_volume_info(rtems_filesystem_mo
         rtems_disk_release(vol->dd);
         free(fs_info->vhash);
         free(fs_info->rhash);
+        printk("fat_init_volume_info: fs_info->uino == NULL\n");
         set_errno_and_return_minus_one( ENOMEM );
     }
     fs_info->sec_buf = (uint8_t *)calloc(vol->bps, sizeof(uint8_t));
@@ -446,6 +465,7 @@ fat_init_volume_info(rtems_filesystem_mo
         free(fs_info->vhash);
         free(fs_info->rhash);
         free(fs_info->uino);
+        printk("fat_init_volume_info: fs_info->sec_buf\n");
         set_errno_and_return_minus_one( ENOMEM );
     }
 
