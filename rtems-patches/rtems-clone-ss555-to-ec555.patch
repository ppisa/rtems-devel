Index: rtems/c/src/lib/libbsp/powerpc/ec555/.cvsignore
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/.cvsignore
@@ -0,0 +1,14 @@
+aclocal.m4
+autom4te*.cache
+config.cache
+config.guess
+config.log
+config.status
+config.sub
+configure
+depcomp
+install-sh
+Makefile
+Makefile.in
+missing
+mkinstalldirs
Index: rtems/c/src/lib/libbsp/powerpc/ec555/ChangeLog
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/ChangeLog
@@ -0,0 +1,97 @@
+2005-05-26	Ralf Corsepius <ralf.corsepius@rtems.org>
+
+	* include/bsp.h: New header guard.
+
+2005-05-10	Ralf Corsepius <ralf.corsepius@rtems.org>
+
+	* console/console.c: Eliminate unsigned8.
+
+2005-04-26	Joel Sherrill <joel@OARcorp.com>
+
+	* startup/bspstart.c: Eliminate warnings.
+
+2005-04-25      Jennifer Averett <jennifer.averett@oarcorp.com>
+
+        PR 779/bsp
+        * clock/p_clock.c: Add parameter to powerpc exception handler routines
+
+2005-02-17	Ralf Corsepius <ralf.corsepius@rtems.org>
+
+	* startup/bspstart.c: include <rtems/powerpc/powerpc.h>.
+	Use PPC_MINIMUM_STACK_FRAME_SIZE instead of
+	CPU_MINIMUM_STACK_FRAME_SIZE.
+
+2005-02-16	Ralf Corsepius <ralf.corsepius@rtems.org>
+
+	* configure.ac: Remove argument from RTEMS_PPC_EXCEPTIONS.
+
+2005-02-11	Ralf Corsepius <ralf.corsepius@rtems.org>
+
+	* Makefile.am: Merge-in wrapup/Makefile.am.
+	* wrapup/Makefile.am: Remove.
+	* configure.ac: Reflect changes above.
+
+2005-01-07	Ralf Corsepius <ralf.corsepius@rtems.org>
+
+	* Makefile.am: Eliminate CFLAGS_OPTIMIZE_V.
+
+2005-01-02	Ralf Corsepius <ralf.corsepius@rtems.org>
+
+	* Makefile.am, wrapup/Makefile.am: Remove build-variant support.
+
+2004-10-20	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	* console/console.c, include/bsp.h, startup/bspstart.c,
+	startup/iss555.c: Use POSIX fixed size types.
+
+2004-09-24	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	* configure.ac: Require automake > 1.9.
+
+2004-04-23	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	PR 610/bsps
+	* Makefile.am: Add include/tm27.h, Cosmetics.
+	* include/tm27.h: Final cosmetics.
+
+2004-04-22	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	* include/bsp.h: Split out tmtest27 support.
+	* include/tm27.h: New.
+
+2004-04-21	Joel Sherrill <joel@OARcorp.com>
+
+	PR 611/bsps
+	* Makefile.am, include/bsp.h, wrapup/Makefile.am: Follow conventions
+	for tm27 and do not add another macro definition.
+	* startup/tm27supp.c: New file.
+
+2004-04-21	Joel Sherrill <joel@OARcorp.com>
+
+	PR 611/bsps
+	* Makefile.am, include/bsp.h, wrapup/Makefile.am: Follow conventions
+	for tm27 and do not add another macro definition.
+	* startup/tm27supp.c: New file.
+
+2004-04-21	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	PR 613/bsps
+	* include/bsp.h: Remove MAX_LONG_TEST_DURATION.
+
+2004-04-21	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	PR 614/bsps
+	* include/bsp.h: Remove MAX_SHORT_TEST_DURATION (Unused).
+
+2004-04-13	Ralf Corsepius <ralf_corsepius@rtems.org>
+
+	* include/bsp.h, startup/start.S: Reflect new locations of cpukit headers.
+
+2004-04-12	David Querbach <querbach@realtime.bc.ca>
+
+	* .cvsignore, ChangeLog, Makefile.am, README, bsp_specs, configure.ac,
+	times, clock/p_clock.c, console/console.c, include/.cvsignore,
+	include/bsp.h, include/coverhd.h, irq/irq.h, startup/bspstart.c,
+	startup/iss555.c, startup/linkcmds, startup/start.S,
+	wrapup/.cvsignore, wrapup/Makefile.am: New files.
+
Index: rtems/c/src/lib/libbsp/powerpc/ec555/Makefile.am
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/Makefile.am
@@ -0,0 +1,116 @@
+##
+## $Id: Makefile.am,v 1.6 2005/02/12 03:31:07 ralf Exp $
+##
+
+ACLOCAL_AMFLAGS = -I ../../../../aclocal
+
+include $(top_srcdir)/../../../../automake/compile.am
+include $(top_srcdir)/../../bsp.am
+
+dist_project_lib_DATA = bsp_specs
+
+include_HEADERS = include/bsp.h
+include_HEADERS += include/tm27.h
+
+nodist_include_HEADERS = include/bspopts.h
+DISTCLEANFILES = include/bspopts.h
+
+noinst_PROGRAMS =
+
+include_bspdir = $(includedir)/bsp
+
+include_HEADERS += include/coverhd.h
+include_bsp_HEADERS = irq/irq.h
+
+EXTRA_DIST = times
+
+dist_project_lib_DATA += startup/linkcmds
+
+noinst_PROGRAMS += pclock.rel
+pclock_rel_SOURCES = clock/p_clock.c
+pclock_rel_CPPFLAGS = $(AM_CPPFLAGS)
+pclock_rel_LDFLAGS = $(RTEMS_RELLDFLAGS)
+
+noinst_PROGRAMS += console.rel
+console_rel_SOURCES = console/console.c
+console_rel_CPPFLAGS = $(AM_CPPFLAGS)
+console_rel_LDFLAGS = $(RTEMS_RELLDFLAGS)
+
+noinst_PROGRAMS += startup.rel
+startup_rel_SOURCES = ../../shared/bspclean.c ../../shared/bsplibc.c \
+    ../../shared/bsppost.c startup/bspstart.c ../../shared/bootcard.c \
+    startup/iss555.c ../../shared/main.c ../../shared/sbrk.c \
+    ../../shared/gnatinstallhandler.c startup/start.S
+startup_rel_CPPFLAGS = $(AM_CPPFLAGS)
+startup_rel_LDFLAGS = $(RTEMS_RELLDFLAGS)
+
+noinst_PROGRAMS += tm27supp.rel
+tm27supp_rel_SOURCES = startup/tm27supp.c
+tm27supp_rel_CPPFLAGS = $(AM_CPPFLAGS)
+tm27supp_rel_LDFLAGS = $(RTEMS_RELLDFLAGS)
+
+noinst_LIBRARIES = libbsp.a
+libbsp_a_SOURCES =
+libbsp_a_LIBADD = pclock.rel console.rel startup.rel tm27supp.rel
+libbsp_a_LIBADD += ../../../libcpu/@RTEMS_CPU@/shared/cpuIdent.rel \
+    ../../../libcpu/@RTEMS_CPU@/@exceptions@/rtems-cpu.rel \
+    ../../../libcpu/@RTEMS_CPU@/mpc5xx/clock.rel \
+    ../../../libcpu/@RTEMS_CPU@/mpc5xx/console-generic.rel \
+    ../../../libcpu/@RTEMS_CPU@/mpc5xx/exceptions.rel \
+    ../../../libcpu/@RTEMS_CPU@/mpc5xx/irq.rel \
+    ../../../libcpu/@RTEMS_CPU@/mpc5xx/timer.rel \
+    ../../../libcpu/@RTEMS_CPU@/mpc5xx/vectors.rel
+
+all-local: $(PREINSTALL_FILES) $(TMPINSTALL_FILES)
+
+PREINSTALL_DIRS =
+PREINSTALL_FILES =
+
+$(PROJECT_INCLUDE)/$(dirstamp):
+	@$(mkdir_p) $(PROJECT_INCLUDE)
+	@: > $(PROJECT_INCLUDE)/$(dirstamp)
+PREINSTALL_DIRS += $(PROJECT_INCLUDE)/$(dirstamp)
+
+$(PROJECT_LIB)/$(dirstamp):
+	@$(mkdir_p) $(PROJECT_LIB)
+	@: > $(PROJECT_LIB)/$(dirstamp)
+PREINSTALL_DIRS += $(PROJECT_LIB)/$(dirstamp)
+
+$(PROJECT_LIB)/bsp_specs: bsp_specs $(PROJECT_LIB)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_LIB)/bsp_specs
+PREINSTALL_FILES += $(PROJECT_LIB)/bsp_specs
+
+$(PROJECT_INCLUDE)/bsp.h: include/bsp.h $(PROJECT_INCLUDE)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/bsp.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/bsp.h
+
+$(PROJECT_INCLUDE)/tm27.h: include/tm27.h $(PROJECT_INCLUDE)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/tm27.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/tm27.h
+
+$(PROJECT_INCLUDE)/bspopts.h: include/bspopts.h $(PROJECT_INCLUDE)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/bspopts.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/bspopts.h
+
+$(PROJECT_INCLUDE)/bsp/$(dirstamp):
+	@$(mkdir_p) $(PROJECT_INCLUDE)/bsp
+	@: > $(PROJECT_INCLUDE)/bsp/$(dirstamp)
+PREINSTALL_DIRS += $(PROJECT_INCLUDE)/bsp/$(dirstamp)
+
+$(PROJECT_INCLUDE)/coverhd.h: include/coverhd.h $(PROJECT_INCLUDE)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/coverhd.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/coverhd.h
+
+$(PROJECT_INCLUDE)/bsp/irq.h: irq/irq.h $(PROJECT_INCLUDE)/bsp/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_INCLUDE)/bsp/irq.h
+PREINSTALL_FILES += $(PROJECT_INCLUDE)/bsp/irq.h
+
+$(PROJECT_LIB)/linkcmds: startup/linkcmds $(PROJECT_LIB)/$(dirstamp)
+	$(INSTALL_DATA) $< $(PROJECT_LIB)/linkcmds
+PREINSTALL_FILES += $(PROJECT_LIB)/linkcmds
+
+CLEANFILES = $(PREINSTALL_FILES)
+DISTCLEANFILES += $(PREINSTALL_DIRS)
+
+include $(top_srcdir)/../../../../automake/subdirs.am
+include $(top_srcdir)/../../../../automake/local.am
Index: rtems/c/src/lib/libbsp/powerpc/ec555/README
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/README
@@ -0,0 +1,262 @@
+#
+#  $Id: README,v 1.1 2004/04/12 21:52:13 joel Exp $
+#
+
+This is a README file for the Intec SS555 of RTEMS 4.6.0
+
+The SS555 port was sponsored by Defence Research and Development 
+Canada - Suffield, and is Copyright (C) 2004, Real-Time Systems Inc.
+
+Please send any comments, improvements, or bug reports to:
+
+David Querbach
+querbach@realtime.bc.ca
+
+
+Summary
+-------
+
+BSP NAME:           ss555
+BOARD:              Intec Automation Inc. SS555
+BUS:                None 
+CPU FAMILY:         PowerPC
+CPU:                PowerPC MPC555
+COPROCESSORS:       Built-in Motorola TPU
+MODE:               32 bit mode
+
+DEBUG MONITOR:      None
+
+PERIPHERALS
+===========
+TIMERS:             PIT / Timebase
+  RESOLUTION:       1 microsecond (4 MHz crystal / 4)
+SERIAL PORTS:       2 SCI
+REAL-TIME CLOCK:    On-chip.
+DMA:                None.
+VIDEO:              None.
+SCSI:               None.
+NETWORKING:         None.
+		   
+
+DRIVER INFORMATION
+==================
+CLOCK DRIVER:       yes
+CONSOLE DRIVER:     yes
+SHMSUPP:            N/A
+TIMER DRIVER:       yes
+NETWORK DRIVER:	    no
+
+NOTES
+=====
+On-chip resources:
+	SCI1		serial port
+	SCI2		serial port (console)
+	PIT		clock
+	TB		timing test support
+	DEC
+	SWT		watchdog timer -- enable in startup/iss555.c
+	*CS0		external 512k 2-1-1-1 Burst SRAM
+	*CS1
+	*CS2
+	*CS3		CPLD
+	IRQ0
+	IRQ1
+	IRQ2		
+	IRQ3		
+	IRQ4		
+	IRQ5	
+	IRQ6
+	IRQ7
+	IRQ_LVL0	
+	IRQ_LVL1
+	IRQ_LVL2
+	IRQ_LVL3
+	IRQ_LVL4
+	IRQ_LVL5	SCI
+	IRQ_LVL6	PIT
+	IRQ_LVL7
+	
+
+Board description
+-----------------
+Clock rate:     40 MHz development/embeddable board
+Bus width:      32-bit on-board RAM, 16-bit off-board I/O
+FLASH:	        512k on-chip
+RAM:            512k 2-1-1-1 burst SRAM
+
+
+Installation
+------------
+
+The ss555 port uses the Intec SS555's external RAM in two different ways,
+depending on whether or not it is built for debugging by giving the
+VARIANT=DEBUG switch to make:
+
+	make VARIANT=DEBUG all
+
+1.  In the debugging case, the linker script concanttenates the .text,
+.data, and .bss sections starting at location zero, so they all can be
+loaded into the external RAM for debugging.  We assume that the debugger
+disables the internal Flash ROM and enables the external RAM before loading
+the code into the external RAM.
+
+2.  In the normal (non-debugging) case, the linker script still places the
+.text section near zero, but places the start of the .data and .bss sections
+at the start location of the MPC555's internal RAM.  The system startup code
+then configures the external RAM just after the internal RAM in memory,
+forming one large block from the two RAM devices.
+
+
+Console driver
+---------------
+
+This BSP includes an termios-capable asynchronous serial line driver that
+supports SCI1 and SCI2. The RTEMS console is selected at configuration time
+with the CONSOLE_MINOR variable (see .../ss555/configure.ac).  We default to
+SCI2 for the console, since SCI1 has some extra features which may be
+desired for application use.
+
+The BSP console supports three different modes of operation:
+
+  1. polled I/O done with termios support,
+  2. polled I/O done without termios support,
+  3. interrupt-driven I/O with termios support.
+     
+The mode of operation of the serial driver is determined at configure time in
+part by the value of the UARTS_IO_MODE variable (see .../ss555/configure.ac).
+
+  0 - polled I/O.
+  1 - interrupt-driven I/O.
+  
+Also, set the value of UARTS_USE_TERMIOS to select whether termios should be
+used to perform buffering and input/output processing. Without termios
+support, input processing is limited to the substitution of LF for a
+received CR, and output processing is limited to the transmission of a CR
+following the transmission of a LF. The choices for UARTS_USE_TERMIOS are:
+
+  0 - do not use termios
+  1 - use termios
+
+In most real-time applications, the driver should be configured to use
+termios and interrupt-driven I/O. Special requirements may dictate otherwise.
+
+Polled I/O must be used when running the timing tests. It must also be used
+to run some other tests and some samples, such as the cdtest. Some tests
+change the interrupt mask and will hang interrupt-driven I/O indefinitely.
+Others, such as cdtest, perform console output from the static constructors
+before the console is opened, causing the test to hang. Still other tests
+produce output that is supposed to be in some specific order. For these
+tests, termios should not be used, as termios buffers output and the
+transmission of the buffers occur at somewhat unpredictable times.
+
+The real solution is to fix the tests so that they work with interrupt-driven
+I/O and termios.
+
+
+printk() and debug output
+-----------------------
+
+The implementation of printk() in RTEMS is mostly independent of most system
+services. The printk() function can therefore be used to print messages to a
+debug console, particularly when debugging startup code or device drivers,
+i.e. code that runs before the console driver is opened or that runs with
+interrupts disabled.
+
+Support is provided to send printk output to either port. Specify the
+desired port at configure time by setting the value of PRINTK_MINOR to one
+of SCI1_MINOR or SCI2_MINOR.
+
+printk() always uses polled I/O, and never uses termios.
+
+If the printk() port is opened by RTEMS, then UARTS_IO_MODE must be set for
+polled I/O, otherwise the I/O functions will be in conflict.  Using printk()
+before the port is initialized is, of course, not possible.  This
+initialization occurs in console_initialize(), which is called by
+rtems_initialize_executive_early().
+
+
+Watchdog Timer
+--------------
+
+The MPC555 watchdog timer can be enabled at configuration time by defining
+the WATCHDOG_TIMEOUT variable.  This variable sets the watchdog timeout
+period in steps of
+
+	  2048          2048
+	---------  =  ---------  =  51.2 usec
+	 Fsystem       40 MHz
+
+or about 1/20 msec.  When WATCHDOG_TIMEOUT is left undefined, the watchdog
+timer is disabled.
+
+
+Miscellaneous
+-------------
+
+Most code came from the mbx8xx port, except for the floating-point handling
+which came from the mpc8260ads.
+
+
+Host System
+-----------
+
+The port was developed on an x86 box running Debian 3.0.  The toolchain was
+built from the sources at rtems.org, except for the autotools which came
+from the Debian distribution.
+
+
+Test Configuration
+------------------
+
+Board:                Intec SS555 v1.1
+CPU:                  Motorola MPC555LFMZP40, mask 1K83H
+Clock Speed:          Crystal 4.0 MHz, CPU 40.0 MHz
+RAM:                  512K bytes of 2-1-1-1 Burst SRAM
+Times Reported in:    Microseconds
+Timer Source:         Timebase clock
+GCC Flags:            -O4 -fno-keep-inline-functions -mcpu=(821/860) 
+Console:              Operates in polled mode on SMC2. No I/O through EPPC-Bug.    
+
+
+Test Results
+------------
+
+Single processor tests:  
+  All tests passed, except that:
+    - sp09 aborts due to memory shortage
+    - sp20 needs to be run with output buffering enabled (see
+      buffer_test_io.h)
+
+Multi-processor tests:  
+  Not applicable.
+
+Library tests:
+  All tests passed.  Note that the termios test only works if the system is
+  rebuilt with termios enabled.                         
+
+Posix tests:
+  All tests passed, except that:
+    - the message queue test failed with "errno (91 - File or path name too
+      long)"
+
+Timing tests:
+  Due to memory limitations, many of the tests will not run unless you set
+  OPERATION_COUNT=20 at configuration time.
+
+  To run tm27 (the interrupt latency timer test), short CN5-48 to CN5-50 on
+  the SS555 board.
+
+  All tests run cleanly, except for tm26, which gives a "PANIC 12" after it
+  exits.  This doesn't seem to cause a problem otherwise.
+
+  See the times file for the results of the timing tests.
+
+Network tests:  
+  Not applicable.
+
+Sample programs:
+  These run correctly, except that:
+    - The "minimum" sample is not designed to run properly on any system.
+    - The loopback, fileio, unilimited, and pppd tests fail due to memory
+      limitations.
+    - The paranoia program dies on a floating-point assist exception.
Index: rtems/c/src/lib/libbsp/powerpc/ec555/bsp_specs
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/bsp_specs
@@ -0,0 +1,20 @@
+%rename lib old_lib
+%rename endfile old_endfile
+%rename startfile old_startfile
+%rename link old_link
+
+*lib:
+%{!qrtems: %(old_lib)} %{!nostdlib: %{qrtems: --start-group \
+%{!qrtems_debug: -lrtemsbsp -lrtemscpu} %{qrtems_debug: -lrtemsbsp_g -lrtemscpu_g} \
+%{qjava: -lffi -lgcjgc -lzgcj -lgcj} %{qc++: -lstdc++} -lc -lgcc --end-group \
+%{!qnolinkcmds: %{qrtems_debug: --defsym RTEMS_DEBUG=1} -T linkcmds%s -Map %b.map}}}
+
+*startfile:
+%{!qrtems: %(old_startfile)} %{!nostdlib: %{qrtems: ecrti%O%s}}
+
+*endfile:
+%{!qrtems: %(old_endfile)} %{qrtems: ecrtn%O%s}
+
+*link:
+%{!qrtems: %(old_link)} %{qrtems: -dc -dp -u __vectors -N -u start -e start}
+
Index: rtems/c/src/lib/libbsp/powerpc/ec555/clock/p_clock.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/clock/p_clock.c
@@ -0,0 +1,69 @@
+/*
+ *  Clock Tick interrupt conexion code.
+ *
+ *  COPYRIGHT (c) 1989-1997.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may in
+ *  the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  SS555 port sponsored by Defence Research and Development Canada - Suffield
+ *  Copyright (C) 2004, Real-Time Systems Inc. (querbach@realtime.bc.ca)
+ *
+ *  Derived from c/src/lib/libbsp/powerpc/mbx8xx/clock/p_clock.c:
+ *
+ *  Modified to support the MPC750.
+ *  Modifications Copyright (c) 1999 Eric Valette valette@crf.canon.fr
+ *
+ *  $Id: p_clock.c,v 1.3 2005/04/25 14:46:37 jennifer Exp $
+ */
+
+#include <bsp.h>
+#include <bsp/irq.h>
+#include <rtems/bspIo.h>
+
+extern void clockOn(void*);
+extern void clockOff (void*);
+extern int clockIsOn(void*);
+extern void Clock_isr(void *);
+
+static rtems_irq_connect_data clockIrqData = {
+  CPU_PERIODIC_TIMER,
+  (rtems_irq_hdl)Clock_isr,
+  NULL,
+  (rtems_irq_enable)clockOn,
+  (rtems_irq_disable)clockOff,
+  (rtems_irq_is_enabled)clockIsOn
+};
+
+int BSP_disconnect_clock_handler (void)
+{
+  if (!BSP_get_current_rtems_irq_handler(&clockIrqData)) {
+     printk("Unable to stop system clock\n");
+    rtems_fatal_error_occurred(1);
+  }
+  return BSP_remove_rtems_irq_handler (&clockIrqData);
+}
+
+int BSP_connect_clock_handler (rtems_irq_hdl hdl)
+{
+  if (!BSP_get_current_rtems_irq_handler(&clockIrqData)) {
+     printk("Unable to get system clock handler\n");
+    rtems_fatal_error_occurred(1);
+  }
+  if (!BSP_remove_rtems_irq_handler (&clockIrqData)) {
+   printk("Unable to remove current system clock handler\n");
+    rtems_fatal_error_occurred(1);
+  }
+  /*
+   * Reinit structure
+   */
+  clockIrqData.name = CPU_PERIODIC_TIMER;
+  clockIrqData.hdl = (rtems_irq_hdl) hdl;
+  clockIrqData.on = (rtems_irq_enable)clockOn;
+  clockIrqData.off = (rtems_irq_enable)clockOff;
+  clockIrqData.isOn = (rtems_irq_is_enabled)clockIsOn;
+
+  return BSP_install_rtems_irq_handler (&clockIrqData);
+}
Index: rtems/c/src/lib/libbsp/powerpc/ec555/configure.ac
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/configure.ac
@@ -0,0 +1,52 @@
+## Process this file with autoconf to produce a configure script.
+## 
+## $Id: configure.ac,v 1.5 2005/02/16 10:13:09 ralf Exp $
+
+AC_PREREQ(2.59)
+AC_INIT([rtems-c-src-lib-libbsp-powerpc-mbx5xx],[_RTEMS_VERSION],[rtems-bugs@rtems.com])
+AC_CONFIG_SRCDIR([bsp_specs])
+RTEMS_TOP(../../../../../..)
+
+RTEMS_CANONICAL_TARGET_CPU
+AM_INIT_AUTOMAKE([no-define nostdinc foreign 1.9])
+RTEMS_BSP_CONFIGURE
+
+RTEMS_PROG_CC_FOR_TARGET([-ansi -fasm])
+RTEMS_CANONICALIZE_TOOLS
+RTEMS_PROG_CCAS
+
+RTEMS_CHECK_NETWORKING
+AM_CONDITIONAL(HAS_NETWORKING,test "$HAS_NETWORKING" = "yes")
+
+RTEMS_BSPOPTS_SET([WATCHDOG_TIMEOUT],[*],[0xFFFF])
+RTEMS_BSPOPTS_HELP([WATCHDOG_TIMEOUT], 
+[Define to the desired timeout (in steps of 1/20 msec) to enable the
+ watchdog.  Default is to disable the watchdog entirely.])
+
+RTEMS_BSPOPTS_SET([UARTS_USE_TERMIOS],[*],[0])
+RTEMS_BSPOPTS_HELP([UARTS_USE_TERMIOS],
+[Define to 1 if you want termios support for every port.
+ Termios support is independent of the choice of UART I/O mode.])
+
+RTEMS_BSPOPTS_SET([CONSOLE_MINOR],[*],[SCI2_MINOR])
+RTEMS_BSPOPTS_HELP([CONSOLE_MINOR],
+[Must be defined to be one of SCI1_MINOR or SCI2_MINOR.  Determines which
+ device will be registered as /dev/console.])
+
+RTEMS_BSPOPTS_SET([UARTS_IO_MODE],[*],[0])
+RTEMS_BSPOPTS_HELP([UARTS_IO_MODE],
+[Define to 1 if you want interrupt-driven I/O for the SCI ports.])
+
+RTEMS_BSPOPTS_SET([PRINTK_MINOR],[*],[SCI2_MINOR])
+RTEMS_BSPOPTS_HELP([PRINTK_MINOR],
+[Must be defined to be one of SCI1_MINOR or SCI2_MINOR.  Determines which
+ device is used for output by printk().  The printk port always uses polled
+ I/O.  Don't open the printk port from RTEMS unless also using polled I/O
+ for the SCI ports.])
+
+# Explicitly list a Makefile here 
+AC_CONFIG_FILES([Makefile])
+
+RTEMS_PPC_EXCEPTIONS
+
+AC_OUTPUT
Index: rtems/c/src/lib/libbsp/powerpc/ec555/console/console.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/console/console.c
@@ -0,0 +1,368 @@
+/*
+ *  console.c
+ *
+ *  This file contains the Intec SS555 termios serial I/O package.
+ *
+ *  The SCI channels are assigned as follows
+ *
+ *   Channel     Device      Minor
+ *    SCI1      /dev/tty0      0
+ *    SCI2      /dev/tty1      1
+ *
+ *  All ports support termios. The use of termios is recommended for real-time
+ *  applications. Termios provides buffering and input processing. When not
+ *  using termios, processing is limited to the substitution of LF for CR on
+ *  input, and the output of a CR following the output of a LF character.
+ *  Note that the terminal should not send CR/LF pairs when the return key
+ *  is pressed, and that output lines are terminated with LF/CR, not CR/LF
+ *  (although that would be easy to change).
+ *
+ *  I/O may be interrupt-driven (recommended for real-time applications) or
+ *  polled.
+ *
+ *  LIMITATIONS:
+ *
+ *  It is not possible to use different I/O modes on the different ports. The
+ *  exception is with printk. The printk port can use a different mode from
+ *  the other ports. If this is done, it is important not to open the printk
+ *  port from an RTEMS application.
+ *
+ *  Currently, the I/O modes are determined at build time. It would be much
+ *  better to have the mode selected at boot time based on parameters in
+ *  NVRAM.
+ *
+ *  Interrupt-driven I/O requires termios.
+ *
+ *  TESTS:
+ *
+ *  TO RUN THE TESTS, USE POLLED I/O WITHOUT TERMIOS SUPPORT. Some tests
+ *  play with the interrupt masks and turn off I/O. Those tests will hang
+ *  when interrupt-driven I/O is used. Other tests, such as cdtest, do I/O
+ *  from the static constructors before the console is open. This test
+ *  will not work with interrupt-driven I/O. Because of the buffering
+ *  performed in termios, test output may not be in sequence.The tests
+ *  should all be fixed to work with interrupt-driven I/O and to
+ *  produce output in the expected sequence. Obviously, the termios test
+ *  requires termios support in the driver.
+ *
+ *  Set CONSOLE_MINOR to the appropriate device minor number in the
+ *  config file. This allows the RTEMS application console to be different
+ *  from the GDB port.
+ *
+ *  This driver handles both available serial ports: it distinguishes
+ *  the sub-devices using minor device numbers. It is not possible to have
+ *  other protocols running on the other ports when this driver is used as
+ *  currently written.
+ *
+ *
+ *  SS555 port sponsored by Defence Research and Development Canada - Suffield
+ *  Copyright (C) 2004, Real-Time Systems Inc. (querbach@realtime.bc.ca)
+ *
+ *  Derived from c/src/lib/libbsp/powerpc/mbx8xx/console/console.c:
+ *
+ *  Based on code (alloc860.c in eth_comm port) by
+ *  Jay Monkman (jmonkman@frasca.com),
+ *  Copyright (C) 1998 by Frasca International, Inc.
+ *
+ *  Modifications by Darlene Stewart <Darlene.Stewart@iit.nrc.ca>
+ *  and Charles-Antoine Gauthier <charles.gauthier@iit.nrc.ca>.
+ *  Copyright (c) 2000, National Research Council of Canada
+ *
+ */
+#include <stdarg.h>
+#include <stdio.h>
+#include <bsp.h>                /* Must be before libio.h */
+#include <rtems/bspIo.h>
+#include <rtems/libio.h>
+#include <termios.h>
+
+static void _BSP_output_char( char c );
+static rtems_status_code do_poll_read( rtems_device_major_number major, rtems_device_minor_number minor, void * arg);
+static rtems_status_code do_poll_write( rtems_device_major_number major, rtems_device_minor_number minor, void * arg);
+
+static void _BSP_null_char( char c ) {return;}
+
+BSP_output_char_function_type BSP_output_char = _BSP_null_char;
+
+/*
+ *  do_poll_read
+ *
+ *  Input characters through polled I/O. Returns as soon as a character has
+ *  been received. Otherwise, if we wait for the number of requested
+ *  characters, we could be here forever!
+ *
+ *  CR is converted to LF on input. The terminal should not send a CR/LF pair
+ *  when the return or enter key is pressed.
+ *
+ *  Input parameters:
+ *    major - ignored. Should be the major number for this driver.
+ *    minor - selected channel.
+ *    arg->buffer - where to put the received characters.
+ *    arg->count  - number of characters to receive before returning--Ignored.
+ *
+ *  Output parameters:
+ *    arg->bytes_moved - the number of characters read. Always 1.
+ *
+ *  Return value: RTEMS_SUCCESSFUL
+ *
+ *  CANNOT BE COMBINED WITH INTERRUPT DRIVEN I/O!
+ */
+static rtems_status_code do_poll_read(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void                    * arg
+)
+{
+  rtems_libio_rw_args_t *rw_args = arg;
+  int c;
+
+  while( (c = m5xx_uart_pollRead(minor)) == -1 );
+  rw_args->buffer[0] = (uint8_t)c;
+  if( rw_args->buffer[0] == '\r' )
+      rw_args->buffer[0] = '\n';
+  rw_args->bytes_moved = 1;
+
+  return RTEMS_SUCCESSFUL;
+}
+
+/*
+ *  do_poll_write
+ *
+ *  Output characters through polled I/O. Returns only once every character has
+ *  been sent.
+ *
+ *  CR is transmitted AFTER a LF on output.
+ *
+ *  Input parameters:
+ *    major - ignored. Should be the major number for this driver.
+ *    minor - selected channel
+ *    arg->buffer - where to get the characters to transmit.
+ *    arg->count  - the number of characters to transmit before returning.
+ *
+ *  Output parameters:
+ *    arg->bytes_moved - the number of characters read
+ *
+ *  Return value: RTEMS_SUCCESSFUL
+ *
+ *  CANNOT BE COMBINED WITH INTERRUPT DRIVEN I/O!
+ */
+static rtems_status_code do_poll_write(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void                    * arg
+)
+{
+  rtems_libio_rw_args_t *rw_args = arg;
+  uint32_t i;
+  char cr ='\r';
+
+  for( i = 0; i < rw_args->count; i++ ) {
+    m5xx_uart_pollWrite(minor, &(rw_args->buffer[i]), 1);
+    if ( rw_args->buffer[i] == '\n' )
+      m5xx_uart_pollWrite(minor, &cr, 1);
+  }
+  rw_args->bytes_moved = i;
+
+  return RTEMS_SUCCESSFUL;
+}
+
+/*
+ *  Print functions prototyped in bspIo.h
+ */
+
+static void _BSP_output_char( char c )
+{
+  char cr = '\r';
+
+  /*
+   *  Can't rely on console_initialize having been called before this
+   *  function is used, so it may fail.
+   */
+
+  m5xx_uart_pollWrite( PRINTK_MINOR, &c, 1 );
+  if( c == '\n' )
+    m5xx_uart_pollWrite( PRINTK_MINOR, &cr, 1 );
+}
+
+/*
+ ***************
+ * BOILERPLATE *
+ ***************
+ *
+ *  All these functions are prototyped in rtems/c/src/lib/include/console.h.
+ */
+
+/*
+ * Initialize and register the device
+ */
+rtems_device_driver console_initialize(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void *arg
+)
+{
+  rtems_status_code status;
+
+  /*
+   * Set up TERMIOS if needed
+   */
+  #if UARTS_USE_TERMIOS == 1
+    rtems_termios_initialize ();
+  #endif /* UARTS_USE_TERMIOS */
+
+  /*
+   * Do device-specific initialization
+   */
+  BSP_output_char = _BSP_output_char;
+
+  m5xx_uart_initialize(SCI1_MINOR);
+  status = rtems_io_register_name ("/dev/tty0", major, SCI1_MINOR);
+  if (status != RTEMS_SUCCESSFUL)
+    rtems_fatal_error_occurred (status);
+
+  m5xx_uart_initialize(SCI2_MINOR);
+  status = rtems_io_register_name ("/dev/tty1", major, SCI2_MINOR);
+  if (status != RTEMS_SUCCESSFUL)
+    rtems_fatal_error_occurred (status);
+
+  /* Now register the RTEMS console */
+  status = rtems_io_register_name ("/dev/console", major, CONSOLE_MINOR);
+  if (status != RTEMS_SUCCESSFUL)
+    rtems_fatal_error_occurred (status);
+
+  return RTEMS_SUCCESSFUL;
+}
+
+/*
+ * Open the device
+ */
+rtems_device_driver console_open(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void *arg
+)
+{
+  rtems_status_code sc;
+
+  if ( minor > NUM_PORTS - 1 )
+    return RTEMS_INVALID_NUMBER;
+
+  #if (UARTS_USE_TERMIOS == 1)
+  {
+    #if (UARTS_IO_MODE == 1)    /* RTEMS interrupt-driven I/O with termios */
+
+      static const rtems_termios_callbacks callbacks = {
+        m5xx_uart_firstOpen,           	/* firstOpen */
+        m5xx_uart_lastClose,           	/* lastClose */
+        NULL,                           /* pollRead */
+        m5xx_uart_write,       	        /* write */
+        m5xx_uart_setAttributes,    	/* setAttributes */
+        NULL,                       	/* stopRemoteTx */
+        NULL,                       	/* startRemoteTx */
+        TERMIOS_IRQ_DRIVEN           	/* outputUsesInterrupts */
+      };
+      sc = rtems_termios_open( major, minor, arg, &callbacks );
+
+    #else /* UARTS_IO_MODE != 1	*/	/* RTEMS polled I/O with termios */
+
+      static const rtems_termios_callbacks callbacks = {
+        m5xx_uart_firstOpen,           	/* firstOpen */
+        m5xx_uart_lastClose,           	/* lastClose */
+        m5xx_uart_pollRead,             /* pollRead */
+        m5xx_uart_pollWrite,            /* write */
+        m5xx_uart_setAttributes,        /* setAttributes */
+        NULL,                           /* stopRemoteTx */
+        NULL,                       	/* startRemoteTx */
+        TERMIOS_POLLED                 	/* outputUsesInterrupts */
+      };
+      sc = rtems_termios_open( major, minor, arg, &callbacks );
+
+    #endif
+
+    return sc;
+  }
+
+  #else		/* no termios -- default to polled I/O */
+  {
+    sc = RTEMS_SUCCESSFUL;
+  }
+  #endif
+
+  return sc;
+}
+
+/*
+ * Close the device
+ */
+rtems_device_driver console_close(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void *arg
+)
+{
+  if ( minor > NUM_PORTS-1 )
+    return RTEMS_INVALID_NUMBER;
+
+  #if UARTS_USE_TERMIOS == 1
+    return rtems_termios_close( arg );
+  #else
+    return RTEMS_SUCCESSFUL;
+  #endif
+}
+
+/*
+ * Read from the device
+ */
+rtems_device_driver console_read(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void *arg
+)
+{
+  if ( minor > NUM_PORTS-1 )
+    return RTEMS_INVALID_NUMBER;
+
+  #if UARTS_USE_TERMIOS == 1
+    return rtems_termios_read( arg );
+  #else
+    return do_poll_read( major, minor, arg );
+  #endif
+}
+
+/*
+ * Write to the device
+ */
+rtems_device_driver console_write(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void *arg
+)
+{
+  if ( minor > NUM_PORTS-1 )
+    return RTEMS_INVALID_NUMBER;
+
+  #if UARTS_USE_TERMIOS == 1
+    return rtems_termios_write( arg );
+  #else
+    return do_poll_write( major, minor, arg );
+  #endif
+}
+
+/*
+ * Handle ioctl request.
+ */
+rtems_device_driver console_control(
+  rtems_device_major_number major,
+  rtems_device_minor_number minor,
+  void *arg
+)
+{
+  if ( minor > NUM_PORTS-1 )
+    return RTEMS_INVALID_NUMBER;
+
+  #if UARTS_USE_TERMIOS == 1
+    return rtems_termios_ioctl( arg );
+  #else
+    return RTEMS_SUCCESSFUL;
+  #endif
+}
Index: rtems/c/src/lib/libbsp/powerpc/ec555/include/.cvsignore
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/include/.cvsignore
@@ -0,0 +1,4 @@
+bspopts.h
+bspopts.h.in
+stamp-h
+stamp-h.in
Index: rtems/c/src/lib/libbsp/powerpc/ec555/include/bsp.h
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/include/bsp.h
@@ -0,0 +1,115 @@
+/*  bsp.h
+ *
+ *  This include file contains all board IO definitions.
+ *
+ *  This file includes definitions for the Intec SS555.
+ *
+ *
+ *  SS555 port sponsored by Defence Research and Development Canada - Suffield
+ *  Copyright (C) 2004, Real-Time Systems Inc. (querbach@realtime.bc.ca)
+ *
+ *  Derived from c/src/lib/libbsp/powerpc/mbx8xx/include/bsp.h:
+ *
+ *  COPYRIGHT (c) 1989-1998.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: bsp.h,v 1.9 2005/05/26 05:36:48 ralf Exp $
+ */
+
+#ifndef _BSP_H
+#define _BSP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <bspopts.h>
+
+#include <rtems.h>
+#include <rtems/console.h>
+#include <rtems/clockdrv.h>
+#include <mpc5xx.h>
+#include <mpc5xx/console.h>
+#include <libcpu/vectors.h>
+#include <bsp/irq.h>
+
+/*
+ * Clock definitions
+ */
+
+#define BSP_CRYSTAL_HZ 	 4000000	/* crystal frequency, Hz */
+#define BSP_CLOCK_HZ	40000000	/* CPU clock frequency, Hz
+
+/*
+ * I/O definitions
+ *
+ * The SS555 board includes a CPLD to control on-board features and
+ * off-board devices.
+ */
+typedef struct cpld_ {
+  uint8_t	cs3a[32];		/* Chip select 3A */
+  uint8_t	pad0[0x200000 - 0x000020];
+
+  uint8_t	cs3b[32];		/* Chip select 3B */
+  uint8_t	pad2[0x400000 - 0x200020];
+
+  uint8_t	cs3c[32];		/* Chip select 3C */
+  uint8_t	pad4[0x600000 - 0x400020];
+
+  uint8_t	cs3d[32];		/* Chip select 3D */
+  uint8_t	pad6[0x800000 - 0x600020];
+
+  uint8_t	serial_ints;	/* Enable/disable serial interrupts */
+  uint8_t	serial_resets;	/* Enable/disable serial resets */
+  uint8_t	serial_ack;	/* Acknowledge serial transfers */
+  uint8_t	pad8[0xA00000 - 0x800003];
+
+  uint8_t	iflash_writess;	/* Enable/disable internal-flash writes */
+  uint8_t	nflash_writess;	/* Enable/disable NAND-flash writes */
+  uint8_t	padA[0xC00000 - 0xA00002];
+} cpld_t;
+
+extern volatile cpld_t cpld;              /* defined in linkcmds */
+
+/* miscellaneous stuff assumed to exist */
+
+extern rtems_configuration_table BSP_Configuration;
+
+/*
+ *  Device Driver Table Entries
+ */
+
+/*
+ * NOTE: Use the standard Console driver entry
+ */
+
+/*
+ * NOTE: Use the standard Clock driver entry
+ */
+
+/*
+ * How many libio files we want
+ */
+
+#define BSP_LIBIO_MAX_FDS       20
+
+/* functions */
+
+void bsp_cleanup( void );
+
+rtems_isr_entry set_vector(                    /* returns old vector */
+  rtems_isr_entry     handler,                  /* isr routine        */
+  rtems_vector_number vector,                   /* vector number      */
+  int                 type                      /* RTEMS or RAW intr  */
+);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+/* end of include file */
Index: rtems/c/src/lib/libbsp/powerpc/ec555/include/coverhd.h
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/include/coverhd.h
@@ -0,0 +1,117 @@
+/*  coverhd.h
+ *
+ *  This include file has defines to represent the overhead associated
+ *  with calling a particular directive from C.  These are used in the
+ *  Timing Test Suite to ignore the overhead required to pass arguments
+ *  to directives.  On some CPUs and/or target boards, this overhead
+ *  is significant and makes it difficult to distinguish internal
+ *  RTEMS execution time from that used to call the directive.
+ *  This file should be updated after running the C overhead timing
+ *  test.  Once this update has been performed, the RTEMS Time Test
+ *  Suite should be rebuilt to account for these overhead times in the
+ *  timing results.
+ *
+ *  NOTE:  If these are all zero, then the times reported include
+ *         all calling overhead including passing of arguments.
+ *
+ *  COPYRIGHT (c) 1989-1998.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: coverhd.h,v 1.1 2004/04/12 21:52:13 joel Exp $
+ */
+
+#ifndef __COVERHD_h
+#define __COVERHD_h
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * 40 MHz processor, running from external 2-1-1-1 burst SRAM.
+ */
+#define CALLING_OVERHEAD_INITIALIZE_EXECUTIVE      0
+#define CALLING_OVERHEAD_SHUTDOWN_EXECUTIVE        0
+#define CALLING_OVERHEAD_TASK_CREATE               0
+#define CALLING_OVERHEAD_TASK_IDENT                0
+#define CALLING_OVERHEAD_TASK_START                0
+#define CALLING_OVERHEAD_TASK_RESTART              0
+#define CALLING_OVERHEAD_TASK_DELETE               0
+#define CALLING_OVERHEAD_TASK_SUSPEND              0
+#define CALLING_OVERHEAD_TASK_RESUME               0
+#define CALLING_OVERHEAD_TASK_SET_PRIORITY         0
+#define CALLING_OVERHEAD_TASK_MODE                 0
+#define CALLING_OVERHEAD_TASK_GET_NOTE             0
+#define CALLING_OVERHEAD_TASK_SET_NOTE             0
+#define CALLING_OVERHEAD_TASK_WAKE_WHEN            2
+#define CALLING_OVERHEAD_TASK_WAKE_AFTER           0
+#define CALLING_OVERHEAD_INTERRUPT_CATCH           0
+#define CALLING_OVERHEAD_CLOCK_GET                 2
+#define CALLING_OVERHEAD_CLOCK_SET                 3
+#define CALLING_OVERHEAD_CLOCK_TICK                0
+
+#define CALLING_OVERHEAD_TIMER_CREATE              0
+#define CALLING_OVERHEAD_TIMER_IDENT               0
+#define CALLING_OVERHEAD_TIMER_DELETE              0
+#define CALLING_OVERHEAD_TIMER_FIRE_AFTER          0
+#define CALLING_OVERHEAD_TIMER_FIRE_WHEN           3
+#define CALLING_OVERHEAD_TIMER_RESET               0
+#define CALLING_OVERHEAD_TIMER_CANCEL              0
+#define CALLING_OVERHEAD_SEMAPHORE_CREATE          0
+#define CALLING_OVERHEAD_SEMAPHORE_IDENT           0
+#define CALLING_OVERHEAD_SEMAPHORE_DELETE          0
+#define CALLING_OVERHEAD_SEMAPHORE_OBTAIN          0
+#define CALLING_OVERHEAD_SEMAPHORE_RELEASE         0
+#define CALLING_OVERHEAD_MESSAGE_QUEUE_CREATE      0
+#define CALLING_OVERHEAD_MESSAGE_QUEUE_IDENT       0
+#define CALLING_OVERHEAD_MESSAGE_QUEUE_DELETE      0
+#define CALLING_OVERHEAD_MESSAGE_QUEUE_SEND        0
+#define CALLING_OVERHEAD_MESSAGE_QUEUE_URGENT      0
+#define CALLING_OVERHEAD_MESSAGE_QUEUE_BROADCAST   0
+#define CALLING_OVERHEAD_MESSAGE_QUEUE_RECEIVE     0
+#define CALLING_OVERHEAD_MESSAGE_QUEUE_FLUSH       0
+
+#define CALLING_OVERHEAD_EVENT_SEND                0
+#define CALLING_OVERHEAD_EVENT_RECEIVE             0
+#define CALLING_OVERHEAD_SIGNAL_CATCH              0
+#define CALLING_OVERHEAD_SIGNAL_SEND               0
+#define CALLING_OVERHEAD_PARTITION_CREATE          0
+#define CALLING_OVERHEAD_PARTITION_IDENT           0
+#define CALLING_OVERHEAD_PARTITION_DELETE          0
+#define CALLING_OVERHEAD_PARTITION_GET_BUFFER      0
+#define CALLING_OVERHEAD_PARTITION_RETURN_BUFFER   0
+#define CALLING_OVERHEAD_REGION_CREATE             0
+#define CALLING_OVERHEAD_REGION_IDENT              0
+#define CALLING_OVERHEAD_REGION_DELETE             0
+#define CALLING_OVERHEAD_REGION_GET_SEGMENT        0
+#define CALLING_OVERHEAD_REGION_RETURN_SEGMENT     0
+#define CALLING_OVERHEAD_PORT_CREATE               0
+#define CALLING_OVERHEAD_PORT_IDENT                0
+#define CALLING_OVERHEAD_PORT_DELETE               0
+#define CALLING_OVERHEAD_PORT_EXTERNAL_TO_INTERNAL 0
+#define CALLING_OVERHEAD_PORT_INTERNAL_TO_EXTERNAL 0
+
+#define CALLING_OVERHEAD_IO_INITIALIZE             0
+#define CALLING_OVERHEAD_IO_OPEN                   0
+#define CALLING_OVERHEAD_IO_CLOSE                  0
+#define CALLING_OVERHEAD_IO_READ                   0
+#define CALLING_OVERHEAD_IO_WRITE                  0
+#define CALLING_OVERHEAD_IO_CONTROL                0
+#define CALLING_OVERHEAD_FATAL_ERROR_OCCURRED      0
+#define CALLING_OVERHEAD_RATE_MONOTONIC_CREATE     0
+#define CALLING_OVERHEAD_RATE_MONOTONIC_IDENT      0
+#define CALLING_OVERHEAD_RATE_MONOTONIC_DELETE     0
+#define CALLING_OVERHEAD_RATE_MONOTONIC_CANCEL     0
+#define CALLING_OVERHEAD_RATE_MONOTONIC_PERIOD     0
+#define CALLING_OVERHEAD_MULTIPROCESSING_ANNOUNCE  0
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+/* end of include file */
Index: rtems/c/src/lib/libbsp/powerpc/ec555/include/tm27.h
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/include/tm27.h
@@ -0,0 +1,54 @@
+/*
+ *  tm27.h
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: tm27.h,v 1.2 2004/04/23 04:47:38 ralf Exp $
+ */
+
+#ifndef _RTEMS_TMTEST27
+#error "This is an RTEMS internal file you must not include directly."
+#endif
+
+#ifndef __tm27_h
+#define __tm27_h
+
+/*
+ * Stuff for Time Test 27
+ *
+ * The following require that IRQ7 be jumpered to ground.  On the SS555,
+ * this can be done by shorting together CN5 pin 48 and CN5 pin 50.
+ */
+
+#define MUST_WAIT_FOR_INTERRUPT 1
+
+#define Install_tm27_vector( handler )					\
+{									\
+  extern rtems_irq_connect_data tm27IrqData;                            \
+  usiu.siel |= (1 << 17); 						\
+  usiu.sipend |= (1 << 17); 						\
+									\
+  tm27IrqData.hdl = (rtems_irq_hdl)handler;				\
+  BSP_install_rtems_irq_handler (&tm27IrqData);				\
+}
+
+#define Cause_tm27_intr()						\
+{									\
+  usiu.siel &= ~(1 << 17); 						\
+}
+
+#define Clear_tm27_intr()						\
+{									\
+  usiu.siel |= (1 << 17); 						\
+  usiu.sipend |= (1 << 17); 						\
+}
+
+#define Lower_tm27_intr()						\
+{									\
+  ppc_cached_irq_mask |= (1 << 17);					\
+  usiu.simask = ppc_cached_irq_mask;					\
+}
+
+#endif
Index: rtems/c/src/lib/libbsp/powerpc/ec555/irq/irq.h
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/irq/irq.h
@@ -0,0 +1,55 @@
+/* irq.h
+ *
+ *  This include file describe the data structure and the functions implemented
+ *  by rtems to write interrupt handlers.
+ *
+ *
+ *  SS555 port sponsored by Defence Research and Development Canada - Suffield
+ *  Copyright (C) 2004, Real-Time Systems Inc. (querbach@realtime.bc.ca)
+ *
+ *  Derived from libbsp/powerpc/mbx8xx/irq/irq.h:
+ *
+ *  CopyRight (C) 1999 valette@crf.canon.fr
+ *
+ *  This code is heavilly inspired by the public specification of STREAM V2
+ *  that can be found at :
+ *
+ *      <http://www.chorus.com/Documentation/index.html> by following
+ *  the STREAM API Specification Document link.
+ *
+ *  The license and distribution terms for this file may be
+ *  found in found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  $Id: irq.h,v 1.2 2004/04/21 10:43:03 ralf Exp $
+ */
+
+#ifndef LIBBSP_POWERPC_SS555_IRQ_IRQ_H
+#define LIBBSP_POWERPC_SS555_IRQ_IRQ_H
+
+#include <libcpu/irq.h>
+
+#ifndef ASM
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The SS555 has no external interrupt controller chip, so use the standard
+ * routines from the CPU-dependent code.
+ */
+#define BSP_install_rtems_irq_handler(ptr)	CPU_install_rtems_irq_handler(ptr)
+#define BSP_get_current_rtems_irq_handler(ptr)	CPU_get_current_rtems_irq_handler(ptr)
+#define BSP_remove_rtems_irq_handler(ptr) 	CPU_remove_rtems_irq_handler(ptr)
+#define BSP_rtems_irq_mngt_set(config)		CPU_rtems_irq_mngt_set(config)
+#define BSP_rtems_irq_mngt_get(config)		CPU_rtems_irq_mngt_get(config)
+#define BSP_rtems_irq_mng_init(cpuId)		CPU_rtems_irq_mng_init(cpuId)
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ASM */
+
+#endif /* LIBBSP_POWERPC_SS555_IRQ_IRQ_H */
Index: rtems/c/src/lib/libbsp/powerpc/ec555/startup/bspstart.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/startup/bspstart.c
@@ -0,0 +1,201 @@
+/*  bspstart.c
+ *
+ *  This set of routines starts the application.  It includes application,
+ *  board, and monitor specific initialization and configuration.
+ *  The generic CPU dependent initialization has been performed
+ *  before this routine is invoked.
+ *
+ *  COPYRIGHT (c) 1989-1998.
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ *
+ *  SS555 port sponsored by Defence Research and Development Canada - Suffield
+ *  Copyright (C) 2004, Real-Time Systems Inc. (querbach@realtime.bc.ca)
+ *
+ *  Derived from c/src/lib/libbsp/powerpc/mbx8xx/startup/bspstart.c:
+ *
+ *  Modifications for MBX860:
+ *  Copyright (c) 1999, National Research Council of Canada
+ *
+ *  $Id: bspstart.c,v 1.7 2005/04/26 23:16:21 joel Exp $
+ */
+
+#include <string.h>
+
+#include <rtems/libio.h>
+#include <rtems/libcsupport.h>
+#include <rtems/bspIo.h>
+#include <rtems/powerpc/powerpc.h>
+
+#include <libcpu/cpuIdent.h>
+#include <libcpu/spr.h>
+
+#include <bsp/irq.h>
+#include <bsp.h>
+
+SPR_RW(SPRG0)
+SPR_RW(SPRG1)
+
+/*
+ *  The original table from the application (in ROM) and our copy of it with
+ *  some changes. Configuration is defined in <confdefs.h>. Make sure that
+ *  our configuration tables are uninitialized so that they get allocated in
+ *  the .bss section (RAM).
+ */
+extern rtems_configuration_table Configuration;
+extern unsigned long intrStackPtr;
+rtems_configuration_table  BSP_Configuration;
+
+rtems_cpu_table Cpu_table;
+
+char *rtems_progname;
+
+/*
+ *  Use the shared implementations of the following routines.
+ *  Look in rtems/c/src/lib/libbsp/shared/bsppost.c and
+ *  rtems/c/src/lib/libbsp/shared/bsplibc.c.
+ */
+void bsp_postdriver_hook(void);
+void bsp_libc_init( void *, uint32_t, int );
+
+void BSP_panic(char *s)
+{
+  printk("%s PANIC %s\n",_RTEMS_version, s);
+  __asm__ __volatile ("sc");
+}
+
+void _BSP_Fatal_error(unsigned int v)
+{
+  printk("%s PANIC ERROR %x\n",_RTEMS_version, v);
+  __asm__ __volatile ("sc");
+}
+
+/*
+ *  bsp_pretasking_hook
+ *
+ *  Called when RTEMS initialization is complete but before interrupts and
+ *  tasking are enabled. Used to setup libc and install any BSP extensions.
+ *
+ *  Must not use libc (to do io) from here, since drivers are not yet
+ *  initialized.
+ *
+ *  Installed in the rtems_cpu_table defined in
+ *  rtems/c/src/exec/score/cpu/powerpc/rtems/new-exceptions/cpu.h by main()
+ *  below.  Called from rtems_initialize_executive() defined in
+ *  rtems/c/src/exec/sapi/src/init.c
+ *
+ *  Input parameters: NONE
+ *
+ *  Output parameters: NONE
+ *
+ *  Return values: NONE
+ */
+void bsp_pretasking_hook(void)
+{
+  /*
+   *  These are assigned addresses in the linkcmds file for the BSP. This
+   *  approach is better than having these defined as manifest constants and
+   *  compiled into the kernel, but it is still not ideal when dealing with
+   *  multiprocessor configuration in which each board as a different memory
+   *  map. A better place for defining these symbols might be the makefiles.
+   *  Consideration should also be given to developing an approach in which
+   *  the kernel and the application can be linked and burned into ROM
+   *  independently of each other.
+   */
+    uint8_t *_HeapStart =
+      (uint8_t *)BSP_Configuration.work_space_start
+           + BSP_Configuration.work_space_size;
+    extern uint8_t _HeapEnd[];
+
+    bsp_libc_init( _HeapStart, _HeapEnd - _HeapStart, 0 );
+
+#ifdef RTEMS_DEBUG
+  rtems_debug_enable( RTEMS_DEBUG_ALL_MASK );
+#endif
+}
+
+/*
+ *  bsp_start()
+ *
+ *  Board-specific initialization code. Called from the generic boot_card()
+ *  function defined in rtems/c/src/lib/libbsp/shared/main.c. That function
+ *  does some of the board independent initialization. It is called from the
+ *  SS555 entry point _start() defined in
+ *  rtems/c/src/lib/libbsp/powerpc/ss555/startup/start.S
+ *
+ *  _start() has set up a stack, has zeroed the .bss section, has set up the
+ *  .data section from contents stored in ROM, has turned off interrupts,
+ *  and placed the processor in the supervisor mode.  boot_card() has left
+ *  the processor in that state when bsp_start() was called.
+ *
+ *  Input parameters: NONE
+ *
+ *  Output parameters: NONE
+ *
+ *  Return values: NONE
+ */
+void bsp_start(void)
+{
+  extern char _WorkspaceBase[];
+
+  ppc_cpu_id_t myCpu;
+  ppc_cpu_revision_t myCpuRevision;
+  register unsigned char* intrStack;
+
+  /*
+   * Get CPU identification dynamically.  Note that the get_ppc_cpu_type()
+   * function stores the result in global variables so that it can be used
+   * later.
+   */
+  myCpu 	= get_ppc_cpu_type();
+  myCpuRevision = get_ppc_cpu_revision();
+
+  /*
+   * Initialize some SPRG registers related to irq handling
+   */
+  intrStack = (((unsigned char*)&intrStackPtr) - PPC_MINIMUM_STACK_FRAME_SIZE);
+  _write_SPRG1((unsigned int)intrStack);
+  /* signal them that we have fixed PR288 - eventually, this should go away */
+  _write_SPRG0(PPC_BSP_HAS_FIXED_PR288);
+
+  /*
+   * Install our own set of exception vectors
+   */
+  initialize_exceptions();
+
+  /*
+   *  Allocate the memory for the RTEMS Work Space.  This can come from
+   *  a variety of places: hard coded address, malloc'ed from outside
+   *  RTEMS world (e.g. simulator or primitive memory manager), or (as
+   *  typically done by stock BSPs) by subtracting the required amount
+   *  of work space from the last physical address on the CPU board.
+   *
+   *  In this case, the memory is not malloc'ed.  It is just
+   *  "pulled from the air".
+   */
+  BSP_Configuration.work_space_start = _WorkspaceBase;
+
+  /*
+   *  initialize the CPU table for this BSP
+   */
+  Cpu_table.pretasking_hook = bsp_pretasking_hook;  /* init libc, etc. */
+  Cpu_table.postdriver_hook = bsp_postdriver_hook;
+  if( Cpu_table.interrupt_stack_size < 4 * 1024 )
+      Cpu_table.interrupt_stack_size = 4 * 1024;
+
+  Cpu_table.clicks_per_usec = BSP_CRYSTAL_HZ / 4 / 1000000;
+  Cpu_table.clock_speed = BSP_CLOCK_HZ;	/* for SCI baud rate generator */
+
+  /*
+   * Call this in case we use TERMIOS for console I/O
+   */
+  m5xx_uart_reserve_resources( &BSP_Configuration );
+
+  /*
+   * Initalize RTEMS IRQ system
+   */
+  BSP_rtems_irq_mng_init(0);
+}
Index: rtems/c/src/lib/libbsp/powerpc/ec555/startup/iss555.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/startup/iss555.c
@@ -0,0 +1,148 @@
+/*
+ *  iss555.c
+ *
+ *  Intec SS555 initialization routines.
+ *
+ *  SS555 port sponsored by Defence Research and Development Canada - Suffield
+ *  Copyright (C) 2004, Real-Time Systems Inc. (querbach@realtime.bc.ca)
+ *
+ *  Derived from c/src/lib/libbsp/powerpc/mbx8xx/startup/imbx8xx.c:
+ *
+ *  Copyright (c) 1999, National Research Council of Canada
+ *
+ *  The license and distribution terms for this file may be
+ *  found in the file LICENSE in this distribution or at
+ *  http://www.rtems.com/license/LICENSE.
+ */
+
+#include <bsp.h>
+
+SPR_RW(ICTRL);
+SPR_RW(DEC);
+SPR_RW(TBWU);
+SPR_RW(TBWL);
+SPR_RO(IMMR);
+SPR_RW(MI_GRA);
+SPR_RW(L2U_GRA);
+SPR_RW(BBCMCR);
+
+/*
+ *  Initialize SS555
+ */
+void _InitSS555 (void)
+{
+  register uint32_t plprcr, msr;
+
+  /*
+   * Initialize the System Protection Control Register (SYPCR).
+   * The SYPCR can only be written once after Reset.
+   */
+  usiu.sypcr =
+      USIU_SYPCR_SWTC(WATCHDOG_TIMEOUT)	/* set watchdog timeout */
+    | USIU_SYPCR_BMT(0xFF) 		/* set bus monitor timeout */
+    | USIU_SYPCR_BME 			/* enable bus monitor */
+    | USIU_SYPCR_SWF			/* watchdog halted in freeze */
+#if WATCHDOG_TIMEOUT != 0xFFFF
+    | USIU_SYPCR_SWE			/* enable watchdog */
+#endif
+    | USIU_SYPCR_SWRI			/* watchdog forces reset */
+    | USIU_SYPCR_SWP;			/* prescale watchdog by 2048 */
+
+  TICKLE_WATCHDOG();			/* restart watchdog timer */
+
+  /*
+   * Re-tune the PLL to the desired system clock frequency.
+   */
+  usiu.plprck = USIU_UNLOCK_KEY;	/* unlock PLPRCR */
+  usiu.plprcr =
+      USIU_PLPRCR_TEXPS			/* assert TEXP always */
+    | USIU_PLPRCR_MF(BSP_CLOCK_HZ / BSP_CRYSTAL_HZ);
+  					/* PLL multiplication factor */
+  usiu.plprck = 0;			/* lock PLPRCR */
+
+  while (((plprcr = usiu.plprcr) & USIU_PLPRCR_SPLS) == 0)
+    ;					/* wait for PLL to re-lock */
+
+  /*
+   * Enable the timebase and decrementer, then initialize decrementer
+   * register to a large value to guarantee that a decrementer interrupt
+   * will not be generated before the kernel is fully initialized.
+   * Initialize the timebase register to zero.
+   */
+  usiu.tbscrk = USIU_UNLOCK_KEY;
+  usiu.tbscr |= USIU_TBSCR_TBE;		/* enable time base and decrementer */
+  usiu.tbscrk = 0;
+
+  usiu.tbk = USIU_UNLOCK_KEY;
+  _write_DEC(0x7FFFFFFF);
+  _write_TBWU(0x00000000 );
+  _write_TBWL(0x00000000 );
+  usiu.tbk = 0;
+
+  /*
+   * Run the Inter-Module Bus at full speed.
+   */
+  imb.uimb.umcr &= ~UIMB_UMCR_HSPEED;
+
+  /*
+   * Initialize Memory Controller for External RAM
+   *
+   * Initialize the Base and Option Registers (BR0-BR7 and OR0-OR7).  Note
+   * that for all chip selects, ORx should be programmed before BRx.
+   *
+   * If booting from internal flash ROM, configure the external RAM to
+   * extend the internal RAM.  If booting from external RAM, leave it at
+   * zero but set it up appropriately.
+   */
+  extern char int_ram_top[];		/* top of internal ram */
+
+  usiu.memc[0]._or =
+      USIU_MEMC_OR_512K			/* bank size */
+    | USIU_MEMC_OR_SCY(0)		/* wait states in first beat of burst */
+    | USIU_MEMC_OR_BSCY(0);		/* wait states in subsequent beats */
+
+  usiu.memc[0]._br =
+      USIU_MEMC_BR_BA(_read_IMMR() & IMMR_FLEN
+        ? (uint32_t)int_ram_top : 0)	/* base address */
+    | USIU_MEMC_BR_PS32			/* 32-bit data bus */
+    | USIU_MEMC_BR_TBDIP		/* toggle bdip */
+    | USIU_MEMC_BR_V;			/* base register valid */
+
+  /*
+   * Initialize Memory Controller for External CPLD
+   *
+   * The SS555 board includes a CPLD to control on-board features and
+   * off-board devices.  (Configuration taken from Intec's hwhook.c)
+   */
+  usiu.memc[3]._or =
+      USIU_MEMC_OR_16M			/* bank size */
+    | USIU_MEMC_OR_CSNT			/* negate CS/WE early */
+    | USIU_MEMC_OR_ACS_HALF		/* assert CS half cycle after address */
+    | USIU_MEMC_OR_SCY(15)		/* wait states in first beat of burst */
+    | USIU_MEMC_OR_TRLX;		/* relaxed timing */
+
+  usiu.memc[3]._br =
+      USIU_MEMC_BR_BA(&cpld)		/* base address */
+    | USIU_MEMC_BR_PS16			/* 16-bit data bus */
+    | USIU_MEMC_BR_BI			/* inhibit bursting */
+    | USIU_MEMC_BR_V;			/* base register valid */
+
+  /*
+   * Disable show cycles and serialization so that burst accesses will work
+   * properly.  A different value, such as 0x0, may be more appropriate for
+   * debugging, but can be set with the debugger, if needed.
+   */
+  _write_ICTRL(0x00000007);
+
+  /*
+   * Set up Burst Buffer Controller (BBC)
+   */
+  _write_BBCMCR(
+      BBCMCR_ETRE			/* enable exception relocation */
+    | BBCMCR_BE);			/* enable burst accesses */
+  _isync;
+
+  _CPU_MSR_GET(msr);
+  msr |= MSR_IP;		/* set prefix for exception relocation */
+  _CPU_MSR_SET(msr);
+}
Index: rtems/c/src/lib/libbsp/powerpc/ec555/startup/linkcmds
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/startup/linkcmds
@@ -0,0 +1,320 @@
+/*
+ * Linker command file for Intec SS555 board
+ *
+ * When debugging, we assume that the internal flash ROM will be replaced by
+ * the external RAM on the SS555 board.  All sections are stacked starting
+ * at address zero.  Nothing is placed in the internal RAM, since it's not
+ * contiguous with the external SRAM when the external RAM is placed at
+ * zero.
+ *
+ * For final production, we assume that the .text section will be burned
+ * into flash ROM starting at address zero.  The .data, .bss, heap, and
+ * workspace will reside in RAM, starting at the beginning of the internal
+ * RAM.  The system startup code will configure the external RAM to begin
+ * where the internal RAM ends, so as to make one large RAM block.
+ *
+ * Debugging mode is chosen when the RTEMS_DEBUG symbol is defined.  The
+ * RTEMS_DEBUG symbol is defined in the bsp_specs file whenever make(1) is
+ * invoked with VARIANT=DEBUG.
+ *
+ *  $Id: linkcmds,v 1.1 2004/04/12 21:52:13 joel Exp $
+ */
+
+OUTPUT_FORMAT("elf32-powerpc", "elf32-powerpc", "elf32-powerpc")
+OUTPUT_ARCH(powerpc) 
+ENTRY(start)
+
+int_ram_org	= 0x003F9800;		/* base of internal RAM */
+int_ram_top	= 0x00400000;		/* top of internal RAM */
+ext_ram_size	= 0x00080000;		/* size of external RAM */
+
+
+SECTIONS
+{
+  .vectors 0x0:
+  {
+    /*
+     * For the MPC555, we use the compressed vector table format which puts
+     * all of the exception vectors before 0x100.
+     */ 
+    *(.vectors)
+  }
+
+  .text 0x100:
+  {
+    /* Read-only sections, merged into text segment: */
+    
+    text.start = .;
+
+    /* Entry point is the .entry section */
+    *(.entry)
+    *(.entry2)
+
+    /* Actual code */
+    *(.text)
+    *(.text.*)
+	     
+    /* C++ constructors/destructors */
+    *(.gnu.linkonce.t*)
+	     
+    /*  Initialization and finalization code.
+     *
+     *  Various files can provide initialization and finalization functions.
+     *  The bodies of these functions are in .init and .fini sections. We
+     *  accumulate the bodies here, and prepend function prologues from
+     *  ecrti.o and function epilogues from ecrtn.o. ecrti.o must be linked
+     *  first; ecrtn.o must be linked last. Because these are wildcards, it
+     *  doesn't matter if the user does not actually link against ecrti.o and
+     *  ecrtn.o; the linker won't look for a file to match a wildcard.  The
+     *  wildcard also means that it doesn't matter which directory ecrti.o
+     *  and ecrtn.o are in. 
+     */
+    PROVIDE (_init = .);
+    *ecrti.o(.init)
+    *(.init)
+    *ecrtn.o(.init)
+    
+    PROVIDE (_fini = .);
+    *ecrti.o(.fini)
+    *(.fini)
+    *ecrtn.o(.init)
+
+    /* 
+     *  C++ constructors and destructors for static objects.
+     *  PowerPC EABI does not use crtstuff yet, so we build "old-style"
+     *  constructor and destructor lists that begin with the list length
+     *  end terminate with a NULL entry.
+     */
+    PROVIDE (__CTOR_LIST__ = .);	     
+    /* LONG((__CTOR_END__ - __CTOR_LIST__) / 4 - 2) */
+    *crtbegin.o(.ctors)
+    *(.ctors)
+    *crtend.o(.ctors)
+    LONG(0)
+    PROVIDE (__CTOR_END__ = .);
+	
+    PROVIDE (__DTOR_LIST__ = .);
+    /* LONG((__DTOR_END__ - __DTOR_LIST__) / 4 - 2) */
+    *crtbegin.o(.dtors)
+    *(.dtors)
+    *crtend.o(.dtors)
+    LONG(0)
+    PROVIDE (__DTOR_END__ = .);
+	
+    /*
+     * Special FreeBSD sysctl sections.
+     */
+    . = ALIGN (16);
+    __start_set_sysctl_set = .;
+    *(set_sysctl_*);
+    __stop_set_sysctl_set = ABSOLUTE(.);
+    *(set_domain_*);
+    *(set_pseudo_*);
+
+    /* Exception frame info */
+    *(.eh_frame)
+
+    /* Miscellaneous read-only data */
+    _rodata_start = . ;
+    *(.gnu.linkonce.r*)
+    *(.lit)
+    *(.shdata)
+    *(.rodata*)
+    *(.rodata1)
+    *.(eh_frame)
+    *(.descriptors)
+    *(rom_ver)
+    _erodata = .;
+
+    /* Various possible names for the end of the .text section */
+    etext = ALIGN(0x10);
+    _etext = .;
+    _endtext = .;
+    text.end = .;
+    PROVIDE (etext = .);
+    PROVIDE (__etext = .);
+
+    /* 
+     * .data section contents, copied to RAM at system startup. 
+     */
+    . = ALIGN(0x20);
+    data.contents.start = .;
+  }
+  text.size = text.end - text.start;
+
+  /*
+   * If debugging, stack the read/write sections directly after the text
+   * section.  Otherwise, stack the read/write sections starting at base of
+   * internal RAM.
+   */
+  . = DEFINED(RTEMS_DEBUG) ? . : int_ram_org;
+ 
+  .data : AT (data.contents.start)
+  {
+    data.start = .;
+    
+    *(.data)
+    *(.data.*)
+    *(.data1)
+    
+    PROVIDE (__SDATA_START__ = .);
+    *(.sdata)
+    *(.gnu.linkonce.d*)
+    *(.gnu.linkonce.s.*)
+    PROVIDE (__SDATA_END__ = .);
+    
+    PROVIDE (__EXCEPT_START__ = .);
+    *(.gcc_except_table)
+    PROVIDE (__EXCEPT_END__ = .);
+    
+    PROVIDE(__GOT_START__ = .);
+    *(.got.plt) 
+    *(.got)
+    PROVIDE(__GOT_END__ = .);
+	
+    *(.got1)
+    
+    PROVIDE (__GOT2_START__ = .);
+    PROVIDE (_GOT2_START_ = .);
+    *(.got2)
+    PROVIDE (__GOT2_END__ = .);
+    PROVIDE (_GOT2_END_ = .);
+	
+    PROVIDE (__FIXUP_START__ = .);
+    PROVIDE (_FIXUP_START_ = .);
+    *(.fixup)
+    PROVIDE (_FIXUP_END_ = .);
+    PROVIDE (__FIXUP_END__ = .);
+
+    /*  We want the small data sections together, so single-instruction
+     *   offsets can access them all.
+     */
+    PROVIDE (__SDATA2_START__ = .);
+    *(.sdata2)
+    *(.gnu.linkonce.s2.*)
+    PROVIDE (__SDATA2_END__ = .);
+
+    data.end = .;
+  }
+  data.size = data.end - data.start;
+	
+  .bss :
+  {
+    bss.start = .;
+	
+    PROVIDE (__SBSS2_START__ = .);
+    *(.sbss2)
+    PROVIDE (__SBSS2_END__ = .);
+	
+    PROVIDE (__SBSS_START__ = .);
+    *(.sbss)
+    PROVIDE (__SBSS_END__ = .);
+
+    *(.bss) 
+    *(COMMON)
+
+    . = ALIGN(4);
+    bss.end = .;
+  }
+  bss.size = bss.end - bss.start;
+
+  PROVIDE(_end = bss.end);
+
+  /*
+   * Initialization stack
+   */
+  InitStack_start = ALIGN(0x10);
+  . += 0x1000;
+  initStack = .;
+  PROVIDE(initStackPtr = initStack);
+
+  /*
+   * Interrupt stack
+   */
+  IntrStack_start = ALIGN(0x10);
+  . += 0x4000;
+  intrStack = .;
+  PROVIDE(intrStackPtr = intrStack);
+
+  _WorkspaceBase = .;
+  __WorkspaceBase = .;
+	
+  /*
+   * Heap
+   *
+   * The heap is configured at run-time to use all available memory.  It
+   * begins just after the end of the Workspace and continues to the end of
+   * the external RAM.
+   */
+  . = DEFINED(RTEMS_DEBUG) ? 0 + ext_ram_size : int_ram_top + ext_ram_size;
+  _HeapEnd = .;
+  __HeapEnd = .;
+ 
+        
+  /* 
+   * Internal I/O devices 
+   */
+  .usiu 0x002FC000:		/* unified system interface unit */
+  {
+    usiu = .;
+  }
+
+  .imb 0x00300000:		/* inter-module bus and devices */
+  {
+    imb = .;
+  }
+
+  .sram 0x00380000:		/* internal SRAM control registers */
+  {
+    sram = .;
+  }
+
+  /*
+   * SS555 external devices managed by on-board CPLD
+   */
+  .cpld 0xFF000000:		/* SS555 external CPLD devices */
+  {
+    cpld = .;
+  }
+
+
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+  
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+  /* DWARF 1 */
+  .debug          0 : { *(.debug) }
+  .line           0 : { *(.line) }
+  
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+  
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+  
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+  
+  /* SGI/MIPS DWARF 2 extensions */
+  .debug_weaknames 0 : { *(.debug_weaknames) }
+  .debug_funcnames 0 : { *(.debug_funcnames) }
+  .debug_typenames 0 : { *(.debug_typenames) }
+  .debug_varnames  0 : { *(.debug_varnames) }
+  /* These must appear regardless of  .  */
+}
Index: rtems/c/src/lib/libbsp/powerpc/ec555/startup/start.S
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/startup/start.S
@@ -0,0 +1,411 @@
+/*  start.S
+ *
+ *  This file contains the entry veneer for RTEMS programs on the Intec
+ *  SS555 board.  It jumps to the BSP which is responsible for performing
+ *  all remaining initialization.
+ *
+ * This file is based on several others:
+ *
+ * (1) start360.s from the gen68360 BSP by
+ *     W. Eric Norum (eric@skatter.usask.ca)
+ *     with the following copyright and license:
+ *
+ *     COPYRIGHT (c) 1989-1998.
+ *     On-Line Applications Research Corporation (OAR).
+ *
+ *     The license and distribution terms for this file may in
+ *     the file LICENSE in this distribution or at
+ *     http://www.rtems.com/license/LICENSE.
+ *
+ * (2) start.s for the eth_comm port by
+ *     Jay Monkman (jmonkman@fracsa.com),
+ *     which itself is based on the
+ *
+ * (3) dlentry.s for the Papyrus BSP, written by:
+ *     Andrew Bray <andy@i-cubed.co.uk>
+ *     with the following copyright and license:
+ *
+ *     COPYRIGHT (c) 1995 by i-cubed ltd.
+ *
+ * (4) start860.S for the MBX821/MBX860, written by:
+ *     Darlene A. Stewart <darlene.stewart@iit.nrc.ca>
+ *     Copyright (c) 1999, National Research Council of Canada
+ *
+ *     To anyone who acknowledges that this file is provided "AS IS"
+ *     without any express or implied warranty:
+ *         permission to use, copy, modify, and distribute this file
+ *         for any purpose is hereby granted without fee, provided that
+ *         the above copyright notice and this notice appears in all
+ *         copies, and that the name of i-cubed limited not be used in
+ *         advertising or publicity pertaining to distribution of the
+ *         software without specific, written prior permission.
+ *         i-cubed limited makes no representations about the suitability
+ *         of this software for any purpose.
+ *
+ * (5) Modifications (for MBX8xx) of respective RTEMS files:
+ *     Copyright (c) 1999, National Research Council of Canada
+ *
+ * SS555 port sponsored by Defence Research and Development Canada - Suffield
+ * Copyright (C) 2004, Real-Time Systems Inc. (querbach@realtime.bc.ca)
+ */
+
+#include <rtems/asm.h>
+#include <rtems/powerpc/registers.h>
+
+/*
+ *  The initial stack is set to the top of the internal RAM.
+ *
+ *  All the entry veneer has to do is to clear the .bss section and copy the
+ *  initializers into the .data section.
+ */
+
+/*
+ *  GDB likes to have debugging information for the entry veneer.
+ *  Play compiler and provide some DWARF information.
+ *
+ *  CHANGE TO SUIT YOUR SETUP!
+ */
+
+        .section .entry,"ax",@progbits
+.L_text_b:
+.L_LC1:
+	.previous
+
+.section 	.debug_sfnames
+.L_sfnames_b:
+	.byte "rtems/c/src/lib/libbsp/powerpc/ss555/startup/"
+	.byte 0
+.L_F0:
+	.byte "start.S"
+	.byte 0
+	.previous
+
+.section	.line
+.L_line_b:
+	.4byte	.L_line_e-.L_line_b
+	.4byte	.L_text_b
+.L_LE1:
+.L_line_last:
+	.4byte	0x0
+	.2byte	0xffff
+	.4byte	.L_text_e-.L_text_b
+.L_line_e:
+	.previous
+
+.section	.debug_srcinfo
+.L_srcinfo_b:
+	.4byte	.L_line_b
+	.4byte	.L_sfnames_b
+	.4byte	.L_text_b
+	.4byte	.L_text_e
+	.4byte	0xffffffff
+	.4byte	.L_LE1-.L_line_b
+	.4byte	.L_F0-.L_sfnames_b
+	.4byte	.L_line_last-.L_line_b
+	.4byte	0xffffffff
+	.previous
+
+.section	.debug_pubnames
+	.4byte	.L_debug_b
+	.4byte	.L_P0
+	.byte "start"
+	.byte 0
+	.4byte	0x0
+	.byte 0
+	.previous
+
+.section	.debug_aranges
+	.4byte	.L_debug_b
+	.4byte	.L_text_b
+	.4byte	.L_text_e-.L_text_b
+	.4byte	0
+	.4byte	0
+	.4byte	0
+	.4byte	0
+	.4byte	0
+	.4byte	0
+	.4byte	0x0
+	.4byte	0x0
+	.previous
+
+.section	.debug
+.L_debug_b:
+.L_D1:
+	.4byte	.L_D1_e-.L_D1
+	.2byte	0x11	/* TAG_compile_unit */
+	.2byte	0x12	/* AT_sibling */
+	.4byte	.L_D2
+	.2byte	0x38	/* AT_name */
+	.byte "start.S"
+	.byte 0
+	.2byte	0x258	/* AT_producer */
+	.byte "GAS 2.5.2"
+	.byte 0
+	.2byte	0x111	/* AT_low_pc */
+	.4byte	.L_text_b
+	.2byte	0x121	/* AT_high_pc */
+	.4byte	.L_text_e
+	.2byte	0x106	/* AT_stmt_list */
+	.4byte	.L_line_b
+	.2byte	0x1b8	/* AT_comp_dir */
+	.byte "rtems/c/src/lib/libbsp/powerpc/ss555/startup/"
+	.byte 0
+	.2byte	0x8006	/* AT_sf_names */
+	.4byte	.L_sfnames_b
+	.2byte	0x8016	/* AT_src_info */
+	.4byte	.L_srcinfo_b
+.L_D1_e:
+.L_P0:
+.L_D3:
+	.4byte	.L_D3_e-.L_D3
+	.2byte	0x6	/* TAG_global_subroutine */
+	.2byte	0x12	/* AT_sibling */
+	.4byte	.L_D4
+	.2byte	0x38	/* AT_name */
+	.byte "start"
+	.byte 0
+	.2byte	0x278	/* AT_prototyped */
+	.byte 0
+	.2byte	0x111	/* AT_low_pc */
+	.4byte	.L_text_b
+	.2byte	0x121	/* AT_high_pc */
+	.4byte	.L_text_e
+	.2byte	0x8041	/* AT_body_begin */
+	.4byte	.L_text_b
+	.2byte	0x8051	/* AT_body_end */
+	.4byte	.L_text_e
+.L_D3_e:
+
+.L_D4:
+	.4byte	.L_D4_e-.L_D4
+	.align 2
+.L_D4_e:
+.L_D2:
+	.previous
+
+/*
+ * Tell C's eabi-ctor's that we have an atexit function,
+ * and that it is to register __do_global_dtors.
+ */
+	EXTERN_PROC(atexit)
+	PUBLIC_VAR(__atexit)
+	.section ".sdata","aw"
+	.align	2
+SYM(__atexit):
+	EXT_PROC_REF(atexit)@fixup
+	.previous
+
+	.section ".fixup","aw"
+	.align	2
+	EXT_SYM_REF(__atexit)
+	.previous
+
+/* That should do it */
+
+/*
+ *  Put the entry point in its own section. That way, we can guarantee
+ *  to put it first in the .text section in the linker script.
+ */
+        .section .entry
+
+        PUBLIC_VAR (start)
+SYM(start):
+        bl      .startup	/* or bl .spin */
+base_addr:
+
+/*
+ * Parameters from linker
+ */
+stack_top:
+	.long	initStackPtr
+
+toc_pointer:
+        .long   __GOT_START__
+
+bss_length:
+        .long   bss.size
+bss_addr:
+        .long   bss.start
+
+data_length:
+        .long   data.size
+data_addr:
+        .long   data.start
+contents_addr:
+        .long   data.contents.start
+
+PUBLIC_VAR (text_addr)
+text_addr:
+        .long   text.start
+
+PUBLIC_VAR (text_length)
+text_length:
+        .long   text.size
+
+/*
+ * Spin, if necessary, to acquire control from debugger (CodeWarrior).
+ */
+spin:
+	.long	0x0001
+.spin:
+	lis	r3, spin@ha
+	lwz	r3, spin@l(r3)
+	cmpwi	r3, 0x1
+	beq	.spin
+
+/*
+ * Initialization code
+ */
+.startup:
+        /* Capture address of linker parameters. */
+        mflr    r3
+
+	/* Set initial stack pointer to end of internal RAM - 56. */
+	lwz	r1, stack_top-base_addr(r3)
+        addi    r1, r1, -56
+
+        /* Initialize essential registers. */
+        bl      initregs
+
+        /* Set TOC pointer */
+        lwz r2, toc_pointer-base_addr(r3)
+
+        /* Initialize the memory mapped MPC555 registers (done in C). */
+        EXTERN_PROC (_InitSS555)
+        bl	PROC (_InitSS555)
+
+        /* Clear the .bss section. */
+        bl      bssclr
+
+	/* Copy initializers into the .data section */
+	bl	datacopy
+
+	/* Enable floating point, since gcc sometimes uses the floating
+	 * point registers for data moves, even if the C source code doesn't
+	 * include floating point operations.
+	 */
+	mfmsr	r0
+	ori	r0, r0, MSR_FP
+	mtmsr	r0
+
+	/* Start system. */
+	lis	r5, environ@ha
+	la	r5,environ@l(r5)	/* environp */
+	li	r4, 0			/* argv */
+	li	r3, 0			/* argc */
+        EXTERN_PROC (boot_card)
+        bl       PROC (boot_card)	/* call the first C routine */
+
+        /* We should never return from boot_card, but in case we do ... */
+	/* The next instructions are dependent on your runtime environment. */
+
+stop_here:
+	b	stop_here
+
+/*
+ * datacopy - copy initializers into .data section
+ */
+datacopy:
+	lis	r3, base_addr@ha		/* point to linker data */
+	addi	r3, r3, base_addr@l
+
+        lwz     r4, contents_addr-base_addr(r3) /* .data contents in ROM */
+        lwz     r5, data_addr-base_addr(r3)     /* .data section in RAM */
+        lwz     r6, data_length-base_addr(r3)   /* length of .data */
+
+        rlwinm. r6, r6, 30, 0x3FFFFFFF          /* form length / 4 */
+        beqlr                                   /* no .data - return */
+
+        mtctr   r6                              /* set ctr reg */
+dc1:
+	lwz	r6, 0(r4)			/* get word */
+        stw     r6, 0(r5)                       /* store word */
+        addi    r4, r4, 0x4                     /* next source */
+        addi    r5, r5, 0x4                     /* next target */
+        bdnz    dc1                             /* dec counter and loop */
+
+        blr                                     /* return */
+
+/*
+ * bssclr - zero out bss
+ */
+bssclr:
+	lis	r3, base_addr@ha		/* point to linker data */
+	addi	r3, r3, base_addr@l
+
+        lwz     r4, bss_addr-base_addr(r3)      /* Start of bss */
+        lwz     r5, bss_length-base_addr(r3)    /* Length of bss */
+
+        rlwinm. r5, r5, 30, 0x3FFFFFFF          /* form length/4 */
+        beqlr                                   /* no bss - return */
+
+        mtctr   r5                              /* set ctr reg */
+        li      r5, 0x0000                      /* r5 = 0 */
+clear_bss:
+        stw     r5, 0(r4)                       /* store r6 */
+        addi    r4, r4, 0x4                     /* update r4 */
+        bdnz    clear_bss                       /* dec counter and loop */
+
+        blr                                     /* return */
+
+/*
+ * initregs
+ *	Initialize the MSR and basic core PowerPC registers
+ *
+ * Register usage:
+ *	r0 - scratch
+ */
+initregs:
+	/*
+	 * Set the processor for big-endian mode, exceptions vectored to
+	 * 0x000n_nnnn, no execution tracing, machine check exceptions
+	 * enabled, floating-point not available, supervisor priviledge
+	 * level, external interrupts disabled, power management disabled
+	 * (normal operation mode).
+	 */
+	li	r0, 0x1000	/* MSR_ME */
+	mtmsr	r0		/* Context-synchronizing */
+	isync
+
+	/*
+	 * Clear the exception handling registers.
+	 */
+	li	r0, 0x0000
+	mtdar   r0
+	mtspr	sprg0, r0
+	mtspr	sprg1, r0
+	mtspr	sprg2, r0
+	mtspr	sprg3, r0
+	mtspr	srr0, r0
+	mtspr	srr1, r0
+
+	mr	r6, r0
+	mr	r7, r0
+	mr	r8, r0
+	mr	r9, r0
+	mr	r10, r0
+	mr	r11, r0
+	mr	r12, r0
+	mr	r13, r0
+	mr	r14, r0
+	mr	r15, r0
+	mr	r16, r0
+	mr	r17, r0
+	mr	r18, r0
+	mr	r19, r0
+	mr	r20, r0
+	mr	r21, r0
+	mr	r22, r0
+	mr	r23, r0
+	mr	r24, r0
+	mr	r25, r0
+	mr	r26, r0
+	mr	r27, r0
+	mr	r28, r0
+	mr	r29, r0
+	mr	r30, r0
+	mr	r31, r0
+
+	blr			/* return */
+
+.L_text_e:
Index: rtems/c/src/lib/libbsp/powerpc/ec555/startup/tm27supp.c
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/startup/tm27supp.c
@@ -0,0 +1,29 @@
+/*
+ *  Support routines for TM27
+ *
+ *  $Id: tm27supp.c,v 1.1 2004/04/21 20:24:36 joel Exp $
+ */
+
+#include <bsp.h>
+
+void tm27On()								
+{									
+}									
+									
+void tm27Off()								
+{									
+}									
+									
+int tm27IsOn()								
+{									
+  return 1;								
+}									
+									
+rtems_irq_connect_data tm27IrqData = {					
+  CPU_USIU_EXT_IRQ_7,							
+  (rtems_irq_hdl)0,							
+  (rtems_irq_enable)tm27On,						
+  (rtems_irq_disable)tm27Off,						
+  (rtems_irq_is_enabled)tm27IsOn					
+};
+
Index: rtems/c/src/lib/libbsp/powerpc/ec555/times
===================================================================
--- /dev/null
+++ rtems/c/src/lib/libbsp/powerpc/ec555/times
@@ -0,0 +1,189 @@
+#
+#  Timing Test Suite Results for the Intec SS555
+#
+#  $Id: times,v 1.1 2004/04/12 21:52:13 joel Exp $
+#
+
+Board: SS555
+CPU: MPC555
+Clock Speed: 40 MHz
+Memory Configuration: 512k external 2-1-1-1 SRAM
+Wait States: 0
+
+Times Reported in: microseconds
+Timer Source: Timebase register (TMBCLK = (4 MHz crystal / 4) = 1.0 Mhz)
+
+#                          DESCRIPTION                                  A	 B
+== =================================================================   ====	====
+
+ 1 rtems_semaphore_create                                               21
+   rtems_semaphore_delete                                               22
+   rtems_semaphore_obtain: available                                     7
+   rtems_semaphore_obtain: not available -- NO_WAIT                      7
+   rtems_semaphore_release: no waiting tasks                            18
+
+ 2 rtems_semaphore_obtain: not available -- caller blocks               50
+
+ 3 rtems_semaphore_release: task readied -- preempts caller             41
+
+ 4 rtems_task_restart: blocked task -- preempts caller                  69
+   rtems_task_restart: ready task -- preempts caller                    67
+   rtems_semaphore_release: task readied -- returns to caller           23
+   rtems_task_create                                                    75
+   rtems_task_start                                                     30
+   rtems_task_restart: suspended task -- returns to caller              37
+   rtems_task_delete: suspended task                                    68
+   rtems_task_restart: ready task -- returns to caller                  38
+   rtems_task_restart: blocked task -- returns to caller                44
+   rtems_task_delete: blocked task                                      70
+
+ 5 rtems_task_suspend: calling task                                     40
+   rtems_task_resume: task readied -- preempts caller                   35
+
+ 6 rtems_task_restart: calling task                                     46
+   rtems_task_suspend: returns to caller                                16
+   rtems_task_resume: task readied -- returns to caller                 18
+   rtems_task_delete: ready task                                        71
+
+ 7 rtems_task_restart: suspended task -- preempts caller                64
+
+ 8 rtems_task_set_priority: obtain current priority                     13
+   rtems_task_set_priority: returns to caller                           24
+   rtems_task_mode: obtain current mode                                  4
+   rtems_task_mode: no reschedule                                        5
+   rtems_task_mode: reschedule -- returns to caller                      7
+   rtems_task_mode: reschedule -- preempts caller                       37
+   rtems_task_set_note                                                  13
+   rtems_task_get_note                                                  13
+   rtems_clock_set                                                      27
+   rtems_clock_get                                                       1
+
+ 9 rtems_message_queue_create                                           34
+   rtems_message_queue_send: no waiting tasks                           26
+   rtems_message_queue_urgent: no waiting tasks                         26
+   rtems_message_queue_receive: available                               24
+   rtems_message_queue_flush: no messages flushed                       12
+   rtems_message_queue_flush: messages flushed                          15
+   rtems_message_queue_delete                                           26
+
+10 rtems_message_queue_receive: not available -- NO_WAIT                15
+   rtems_message_queue_receive: not available -- caller blocks          52
+
+11 rtems_message_queue_send: task readied -- preempts caller            47
+
+12 rtems_message_queue_send: task readied -- returns to caller          29
+
+13 rtems_message_queue_urgent: task readied -- preempts caller          46
+
+14 rtems_message_queue_urgent: task readied -- returns to caller        29
+
+15 rtems_event_receive: obtain current events                            1
+   rtems_event_receive: not available -- NO_WAIT                        12
+   rtems_event_receive: not available -- caller blocks                  44
+   rtems_event_send: no task readied                                    13
+   rtems_event_receive: available                                       13
+   rtems_event_send: task readied -- returns to caller                  21
+
+16 rtems_event_send: task readied -- preempts caller                    41
+
+17 rtems_task_set_priority: preempts caller                             49
+
+18 rtems_task_delete: calling task                                      95
+
+19 rtems_signal_catch                                                   10
+   rtems_signal_send: returns to caller                                 15
+   rtems_signal_send: signal to self                                    20
+   exit ASR overhead: returns to calling task                           15
+   exit ASR overhead: returns to preempting task                        30
+
+20 rtems_partition_create                                               25
+   rtems_region_create                                                  38
+   rtems_partition_get_buffer: available                                14
+   rtems_partition_get_buffer: not available                            13
+   rtems_partition_return_buffer                                        15
+   rtems_partition_delete                                               16
+   rtems_region_get_segment: available                                  34
+   rtems_region_get_segment: not available -- NO_WAIT                   32
+   rtems_region_return_segment: no waiting tasks                        33
+   rtems_region_get_segment: not available -- caller blocks             68
+   rtems_region_return_segment: task readied -- preempts caller         67
+   rtems_region_return_segment: task readied -- returns to caller       48
+   rtems_region_delete                                                  30
+   rtems_io_initialize                                                   2
+   rtems_io_open                                                         1
+   rtems_io_close                                                        1
+   rtems_io_read                                                         1
+   rtems_io_write                                                        1
+   rtems_io_control                                                      1
+
+21 rtems_task_ident                                                     25
+   rtems_message_queue_ident                                            22
+   rtems_semaphore_ident                                                29
+   rtems_partition_ident                                                22
+   rtems_region_ident                                                   24
+   rtems_port_ident                                                     22
+   rtems_timer_ident                                                    22
+   rtems_rate_monotonic_ident                                           22
+
+22 rtems_message_queue_broadcast: task readied -- returns to caller     33
+   rtems_message_queue_broadcast: no waiting tasks                      20
+   rtems_message_queue_broadcast: task readied -- preempts caller       50
+
+23 rtems_timer_create                                                   13
+   rtems_timer_fire_after: inactive                                     22
+   rtems_timer_fire_after: active                                       24
+   rtems_timer_cancel: active                                           13
+   rtems_timer_cancel: inactive                                         12
+   rtems_timer_reset: inactive                                          21
+   rtems_timer_reset: active                                            22
+   rtems_timer_fire_when: inactive                                      26
+   rtems_timer_fire_when: active                                        26
+   rtems_timer_delete: active                                           18
+   rtems_timer_delete: inactive                                         16
+   rtems_task_wake_when                                                 49
+
+24 rtems_task_wake_after: yield -- returns to caller                    10
+   rtems_task_wake_after: yields -- preempts caller                     36
+
+25 rtems_clock_tick                                                      8
+
+26 _ISR_Disable                                                          1
+   _ISR_Flash                                                            1
+   _ISR_Enable                                                           1
+   _Thread_Disable_dispatch                                              1
+   _Thread_Enable_dispatch                                               7
+   _Thread_Set_state                                                     7
+   _Thread_Disptach (NO FP)                                             32
+   context switch: no floating point contexts                           25
+   context switch: self                                                 11
+   context switch: to another task                                      12
+   fp context switch: restore 1st FP task                               37
+   fp context switch: save idle, restore initialized                    34
+   fp context switch: save idle, restore idle                           48
+   fp context switch: save initialized, restore initialized             34
+   _Thread_Resume                                                        7
+   _Thread_Unblock                                                       6
+   _Thread_Ready                                                         7
+   _Thread_Get                                                           4
+   _Semaphore_Get                                                        2
+   _Thread_Get: invalid id                                               1
+
+27 interrupt entry overhead: returns to interrupted task                13
+   interrupt exit overhead: returns to interrupted task                 11
+   interrupt entry overhead: returns to nested interrupt                12
+   interrupt exit overhead: returns to nested interrupt                 10
+   interrupt entry overhead: returns to preempting task                 12
+   interrupt exit overhead: returns to preempting task                  38
+
+28 rtems_port_create                                                    16
+   rtems_port_external_to_internal                                      11
+   rtems_port_internal_to_external                                      11
+   rtems_port_delete                                                    16
+
+29 rtems_rate_monotonic_create                                          15
+   rtems_rate_monotonic_period: initiate period -- returns to caller    20
+   rtems_rate_monotonic_period: obtain status                           12
+   rtems_rate_monotonic_cancel                                          15
+   rtems_rate_monotonic_delete: inactive                                18
+   rtems_rate_monotonic_delete: active                                  20
+   rtems_rate_monotonic_period: conclude periods -- caller blocks       36
Index: rtems/make/custom/ec555.cfg
===================================================================
--- /dev/null
+++ rtems/make/custom/ec555.cfg
@@ -0,0 +1,49 @@
+#
+#  Config file for an Intec Automation SS555 MPC555-based card
+#
+#  This file is derived from:
+#
+#  Config file for a PowerPC MPC860-based MBX821-001 card.
+#  Config file for a PowerPC 403 based helas403 card
+#  Config file for MPC860 based Ethernet Comm Board
+#
+
+include $(RTEMS_ROOT)/make/custom/default.cfg
+
+RTEMS_CPU=powerpc
+GCC_CPU_MODEL=505
+RTEMS_CPU_MODEL=mpc555
+
+# This is the actual bsp directory used during the build process.
+RTEMS_BSP_FAMILY=ss555
+
+#  This contains the compiler options necessary to select the CPU model
+#  and (hopefully) optimize for it.
+#
+CPU_CFLAGS = -mcpu=$(GCC_CPU_MODEL) -D$(RTEMS_CPU_MODEL) -D$(RTEMS_BSP_FAMILY)
+
+# Debugging flags:  If we debug with optimization on, single-stepping
+# sometimes looks a little odd, but there won't be any surprises later.
+CFLAGS_DEBUG_V += -O4 -ggdb
+CXXFLAGS_DEBUG_V += -O4 -ggdb
+
+# optimize flag: typically -O, could use -O4 or -fast
+# -O4 is ok for RTEMS
+# NOTE: some level of -O may be actually required by inline assembler
+CFLAGS_OPTIMIZE_V=-O4 -fno-keep-inline-functions
+CXXFLAGS_OPTIMIZE_V=-O4
+
+define make-exe
+	$(LINK.c) $(AM_CFLAGS) $(AM_LDFLAGS) $(SS555_LDFLAGS) \
+	    -o $(basename $@)_sym.exe $(LINK_OBJS) $(LINK_LIBS)
+	$(NM) -g -n $(basename $@)_sym.exe > $(basename $@).nm
+	cp $(basename $@)_sym.exe $(basename $@).exe 
+	$(STRIP) $(basename $@).exe
+	$(SIZE) $(basename $@)_sym.exe
+endef
+
+# Miscellaneous additions go here
+
+# Override default start file
+START_BASE=
+
