Index: rtems/c/src/lib/libbsp/arm/csb336/times
===================================================================
--- rtems/c/src/lib/libbsp/arm/csb336/times	(revision 42)
+++ rtems/c/src/lib/libbsp/arm/csb336/times	(working copy)
@@ -18,155 +18,155 @@
 
                                              
 == ====================================================================  ===
- 1 rtems_semaphore_create                                                16
- 1 rtems_semaphore_delete                                                17
- 1 rtems_semaphore_obtain: available                                     2
- 1 rtems_semaphore_obtain: not available -- NO_WAIT                      2
- 1 rtems_semaphore_release: no waiting tasks                             5
+ 1 rtems_semaphore_create                                                15
+ 1 rtems_semaphore_delete                                                15
+ 1 rtems_semaphore_obtain: available                                     0
+ 1 rtems_semaphore_obtain: not available -- NO_WAIT                      0
+ 1 rtems_semaphore_release: no waiting tasks                             0
 
- 2 rtems_semaphore_obtain: not available -- caller blocks                20
+ 2 rtems_semaphore_obtain: not available -- caller blocks                12
 
- 3 rtems_semaphore_release: task readied -- preempts caller              16
+ 3 rtems_semaphore_release: task readied -- preempts caller              11
 
- 4 rtems_task_restart: blocked task -- preempts caller                   48
- 4 rtems_task_restart: ready task -- preempts caller                     36
- 4 rtems_semaphore_release: task readied -- returns to caller            9
- 4 rtems_task_create                                                     33
- 4 rtems_task_start                                                      12
- 4 rtems_task_restart: suspended task -- returns to caller               14
- 4 rtems_task_delete: suspended task                                     31
- 4 rtems_task_restart: ready task -- returns to caller                   14
- 4 rtems_task_restart: blocked task -- returns to caller                 19
- 4 rtems_task_delete: blocked task                                       32
+ 4 rtems_task_restart: blocked task -- preempts caller                   38
+ 4 rtems_task_restart: ready task -- preempts caller                     29
+ 4 rtems_semaphore_release: task readied -- returns to caller            5
+ 4 rtems_task_create                                                     24
+ 4 rtems_task_start                                                      8
+ 4 rtems_task_restart: suspended task -- returns to caller               9
+ 4 rtems_task_delete: suspended task                                     20
+ 4 rtems_task_restart: ready task -- returns to caller                   10
+ 4 rtems_task_restart: blocked task -- returns to caller                 11
+ 4 rtems_task_delete: blocked task                                       21
 
- 5 rtems_task_suspend: calling task                                      14
- 5 rtems_task_resume: task readied -- preempts caller                    12
+ 5 rtems_task_suspend: calling task                                      9
+ 5 rtems_task_resume: task readied -- preempts caller                    8
 
- 6 rtems_task_restart: calling task                                      14
- 6 rtems_task_suspend: returns to caller                                 6
- 6 rtems_task_resume: task readied -- returns to caller                  6
- 6 rtems_task_delete: ready task                                         32
+ 6 rtems_task_restart: calling task                                      8
+ 6 rtems_task_suspend: returns to caller                                 3
+ 6 rtems_task_resume: task readied -- returns to caller                  3
+ 6 rtems_task_delete: ready task                                         22
 
- 7 rtems_task_restart: suspended task -- preempts caller                 24
+ 7 rtems_task_restart: suspended task -- preempts caller                 14
 
- 8 rtems_task_set_priority: obtain current priority                      4
- 8 rtems_task_set_priority: returns to caller                            8
- 8 rtems_task_mode: obtain current mode                                  2
- 8 rtems_task_mode: no reschedule                                        2
- 8 rtems_task_mode: reschedule -- returns to caller                      4
- 8 rtems_task_mode: reschedule -- preempts caller                        19
- 8 rtems_task_set_note                                                   4
- 8 rtems_task_get_note                                                   4
- 8 rtems_clock_set                                                       9
+ 8 rtems_task_set_priority: obtain current priority                      1
+ 8 rtems_task_set_priority: returns to caller                            3
+ 8 rtems_task_mode: obtain current mode                                  0
+ 8 rtems_task_mode: no reschedule                                        0
+ 8 rtems_task_mode: reschedule -- returns to caller                      3
+ 8 rtems_task_mode: reschedule -- preempts caller                        13
+ 8 rtems_task_set_note                                                   1
+ 8 rtems_task_get_note                                                   1
+ 8 rtems_clock_set                                                       4
  8 rtems_clock_get                                                       0
 
- 9 rtems_message_queue_create                                            54
- 9 rtems_message_queue_send: no waiting tasks                            8
- 9 rtems_message_queue_urgent: no waiting tasks                          8
- 9 rtems_message_queue_receive: available                                7
- 9 rtems_message_queue_flush: no messages flushed                        4
- 9 rtems_message_queue_flush: messages flushed                           5
- 9 rtems_message_queue_delete                                            21
+ 9 rtems_message_queue_create                                            38
+ 9 rtems_message_queue_send: no waiting tasks                            4
+ 9 rtems_message_queue_urgent: no waiting tasks                          4
+ 9 rtems_message_queue_receive: available                                4
+ 9 rtems_message_queue_flush: no messages flushed                        2
+ 9 rtems_message_queue_flush: messages flushed                           3
+ 9 rtems_message_queue_delete                                            19
 
-10 rtems_message_queue_receive: not available -- NO_WAIT                 4
-10 rtems_message_queue_receive: not available -- caller blocks           20
+10 rtems_message_queue_receive: not available -- NO_WAIT                 2
+10 rtems_message_queue_receive: not available -- caller blocks           12
 
-11 rtems_message_queue_send: task readied -- preempts caller             18
+11 rtems_message_queue_send: task readied -- preempts caller             13
 
-12 rtems_message_queue_send: task readied -- returns to caller           11
+12 rtems_message_queue_send: task readied -- returns to caller           7
 
-13 rtems_message_queue_urgent: task readied -- preempts caller           19
+13 rtems_message_queue_urgent: task readied -- preempts caller           13
 
-14 rtems_message_queue_urgent: task readied -- returns to caller 11
+14 rtems_message_queue_urgent: task readied -- returns to caller         7
 
 15 rtems_event_receive: obtain current events                            0
-15 rtems_event_receive: not available -- NO_WAIT                         3
-15 rtems_event_receive: not available -- caller blocks                   17
-15 rtems_event_send: no task readied                                     3
-15 rtems_event_receive: available                                        5
-15 rtems_event_send: task readied -- returns to caller                   10
+15 rtems_event_receive: not available -- NO_WAIT                         1
+15 rtems_event_receive: not available -- caller blocks                   11
+15 rtems_event_send: no task readied                                     1
+15 rtems_event_receive: available                                        3
+15 rtems_event_send: task readied -- returns to caller                   7
 
-16 rtems_event_send: task readied -- preempts caller                     16
+16 rtems_event_send: task readied -- preempts caller                     12
 
-17 rtems_task_set_priority: preempts caller                              19
+17 rtems_task_set_priority: preempts caller                              13
 
-18 rtems_task_delete: calling task                                       41
+18 rtems_task_delete: calling task                                       26
 
-19 rtems_signal_catch                                                    6
-19 rtems_signal_send: returns to caller                                  15
-19 rtems_signal_send: signal to self                                     25
-19 exit ASR overhead: returns to calling task                            11
-19 exit ASR overhead: returns to preempting task                         12
+19 rtems_signal_catch                                                    5
+19 rtems_signal_send: returns to caller                                  12
+19 rtems_signal_send: signal to self                                     19
+19 exit ASR overhead: returns to calling task                            7
+19 exit ASR overhead: returns to preempting task                         10
 
-20 rtems_partition_create                                                22
-20 rtems_region_create                                                   30
-20 rtems_partition_get_buffer: available                                 10
-20 rtems_partition_get_buffer: not available                             4
-20 rtems_partition_return_buffer                                         9
-20 rtems_partition_delete                                                10
-20 rtems_region_get_segment: available                                   15
-20 rtems_region_get_segment: not available -- NO_WAIT                    16
-20 rtems_region_return_segment: no waiting tasks                         13
-20 rtems_region_get_segment: not available -- caller blocks              47
-20 rtems_region_return_segment: task readied -- preempts caller 45                                                          
-20 rtems_region_return_segment: task readied -- returns to caller 25
-20 rtems_region_delete                                                   23
-20 rtems_io_initialize                                                   1
+20 rtems_partition_create                                                21
+20 rtems_region_create                                                   33
+20 rtems_partition_get_buffer: available                                 9
+20 rtems_partition_get_buffer: not available                             3
+20 rtems_partition_return_buffer                                         8
+20 rtems_partition_delete                                                8
+20 rtems_region_get_segment: available                                   7
+20 rtems_region_get_segment: not available -- NO_WAIT                    7
+20 rtems_region_return_segment: no waiting tasks                         6
+20 rtems_region_get_segment: not available -- caller blocks              36
+20 rtems_region_return_segment: task readied -- preempts caller          33                                                 
+20 rtems_region_return_segment: task readied -- returns to caller        13
+20 rtems_region_delete                                                   18
+20 rtems_io_initialize                                                   0
 20 rtems_io_open                                                         0
 20 rtems_io_close                                                        0
 20 rtems_io_read                                                         0
 20 rtems_io_write                                                        0
 20 rtems_io_control                                                      0
 
-21 rtems_task_ident                                                      39
-21 rtems_message_queue_ident                                             38
-21 rtems_semaphore_ident                                                 43
-21 rtems_partition_ident                                                 38
-21 rtems_region_ident                                                    38
-21 rtems_port_ident                                                      37
-21 rtems_timer_ident                                                     38
-21 rtems_rate_monotonic_ident                                            38
+21 rtems_task_ident                                                      8
+21 rtems_message_queue_ident                                             8
+21 rtems_semaphore_ident                                                 9
+21 rtems_partition_ident                                                 8
+21 rtems_region_ident                                                    8
+21 rtems_port_ident                                                      8
+21 rtems_timer_ident                                                     8
+21 rtems_rate_monotonic_ident                                            8
 
 22 rtems_message_queue_broadcast: task readied -- returns to caller      27
-22 rtems_message_queue_broadcast: no waiting tasks                       6
-22 rtems_message_queue_broadcast: task readied -- preempts caller        22
+22 rtems_message_queue_broadcast: no waiting tasks                       2
+22 rtems_message_queue_broadcast: task readied -- preempts caller        16
 
-23 rtems_timer_create                                                    4
-23 rtems_timer_fire_after: inactive                                      7
-23 rtems_timer_fire_after: active                                        7
-23 rtems_timer_cancel: active                                            4
-23 rtems_timer_cancel: inactive                                          3
-23 rtems_timer_reset: inactive                                           6
-23 rtems_timer_reset: active                                             7
-23 rtems_timer_fire_when: inactive                                       9
-23 rtems_timer_fire_when: active                                         9
-23 rtems_timer_delete: active                                            5
-23 rtems_timer_delete: inactive                                          4
-23 rtems_task_wake_when                                                  21
+23 rtems_timer_create                                                    3
+23 rtems_timer_fire_after: inactive                                      4
+23 rtems_timer_fire_after: active                                        4
+23 rtems_timer_cancel: active                                            2
+23 rtems_timer_cancel: inactive                                          1
+23 rtems_timer_reset: inactive                                           3
+23 rtems_timer_reset: active                                             3
+23 rtems_timer_fire_when: inactive                                       4
+23 rtems_timer_fire_when: active                                         4
+23 rtems_timer_delete: active                                            3
+23 rtems_timer_delete: inactive                                          3
+23 rtems_task_wake_when                                                  12
 
-24 rtems_task_wake_after: yield -- returns to caller                     2
-24 rtems_task_wake_after: yields -- preempts caller                      12
+24 rtems_task_wake_after: yield -- returns to caller                     1
+24 rtems_task_wake_after: yields -- preempts caller                      9
 
-25 rtems_clock_tick                                                      13
+25 rtems_clock_tick                                                      10
 
-26 _ISR_Disable                                                           3
+26 _ISR_Disable                                                          3
 26 _ISR_Flash                                                            1
 26 _ISR_Enable                                                           0
 26 _Thread_Disable_dispatch                                              1
 26 _Thread_Enable_dispatch                                               3
 26 _Thread_Set_state                                                     6
-26 _Thread_Disptach (NO FP)                                              13
-26 context switch: no floating point contexts                            10
+26 _Thread_Disptach (NO FP)                                              9
+26 context switch: no floating point contexts                            7
 26 context switch: self                                                  1
 26 context switch: to another task                                       2
 26 fp context switch: restore 1st FP task -                              NA
 26 fp context switch: save idle, restore initialized -                   NA
 26 fp context switch: save idle, restore idle -                          NA
 26 fp context switch: save initialized, restore initialized -            NA
-26 _Thread_Resume                                                        9
-26 _Thread_Unblock                                                       8
-26 _Thread_Ready                                                         5
-26 _Thread_Get                                                           1
+26 _Thread_Resume                                                        8
+26 _Thread_Unblock                                                       7
+26 _Thread_Ready                                                         4
+26 _Thread_Get                                                           0
 26 _Semaphore_Get                                                        0
 26 _Thread_Get: invalid id                                               0
 
@@ -175,15 +175,15 @@
 27 interrupt entry overhead: returns to nested interrupt                 0
 27 interrupt exit overhead: returns to nested interrupt                  0
 
-28 rtems_port_create                                                     13
-28 rtems_port_external_to_internal                                       3
-28 rtems_port_internal_to_external                                       3
-28 rtems_port_delete                                                     11
+28 rtems_port_create                                                     10
+28 rtems_port_external_to_internal                                       1
+28 rtems_port_internal_to_external                                       1
+28 rtems_port_delete                                                     8
 
-29 rtems_rate_monotonic_create                                           13
-29 rtems_rate_monotonic_period: initiate period -- returns to caller     24
-29 rtems_rate_monotonic_period: obtain status                            5
-29 rtems_rate_monotonic_cancel                                           15
+29 rtems_rate_monotonic_create                                           12
+29 rtems_rate_monotonic_period: initiate period -- returns to caller     17
+29 rtems_rate_monotonic_period: obtain status                            3
+29 rtems_rate_monotonic_cancel                                           12
 29 rtems_rate_monotonic_delete: inactive                                 12
-29 rtems_rate_monotonic_delete: active                                   7
-29 rtems_rate_monotonic_period: conclude periods -- caller blocks        13
+29 rtems_rate_monotonic_delete: active                                   4
+29 rtems_rate_monotonic_period: conclude periods -- caller blocks        9
Index: rtems/c/src/lib/libbsp/arm/csb336/startup/bspstart.c
===================================================================
--- rtems/c/src/lib/libbsp/arm/csb336/startup/bspstart.c	(revision 42)
+++ rtems/c/src/lib/libbsp/arm/csb336/startup/bspstart.c	(working copy)
@@ -153,12 +169,12 @@
 /* Calcuate the frequency for perclk1 */
 int get_perclk1_freq(void)
 {
-    int fin;
-    int fpll;
-    int pd;
-    int mfd;
-    int mfi;
-    int mfn;
+    unsigned int fin;
+    unsigned int fpll;
+    unsigned int pd;
+    unsigned int mfd;
+    unsigned int mfi;
+    unsigned int mfn;
     uint32_t reg;
     int perclk1;
 
@@ -187,13 +203,14 @@
     printk("mfd = %d\n", mfd);
     printk("mfi = %d\n", mfi);
     printk("mfn = %d\n", mfn);
-    printk("(fin * mfi) / (pd + 1) = %d\n", (fin * mfi) / (pd + 1));
-    printk("(fin * mfn) / ((pd + 1) * (mfd + 1)) = %d\n",
-           (fin * mfn) / ((pd + 1) * (mfd + 1)));
+    printk("rounded (fin * mfi) / (pd + 1) = %d\n", (fin * mfi) / (pd + 1));
+    printk("rounded (fin * mfn) / ((pd + 1) * (mfd + 1)) = %d\n",
+           ((long long)fin * mfn) / ((pd + 1) * (mfd + 1)));
 #endif
 
-    fpll = 2 * ( ((fin * mfi) / (pd + 1)) +
-                 ((fin * mfn) / ((pd + 1) * (mfd + 1))) );
+    fpll = 2 * ( ((fin * mfi  + (pd + 1) / 2) / (pd + 1)) +
+                 (((long long)fin * mfn + ((pd + 1) * (mfd + 1)) / 2) / 
+		 ((pd + 1) * (mfd + 1))) );
 
     /* calculate the output of the PERCLK1 divider */
     reg = MC9328MXL_PLL_PCDR;
Index: rtems/c/src/lib/libbsp/arm/csb336/startup/linkcmds
===================================================================
--- rtems/c/src/lib/libbsp/arm/csb336/startup/linkcmds	(revision 42)
+++ rtems/c/src/lib/libbsp/arm/csb336/startup/linkcmds	(working copy)
@@ -75,9 +75,6 @@
     rtems_vector_table = .;
     . += (8 * 4);                     /* 8 ARM interrupts */
 	
-    bsp_vector_table = .;
-    . += (64 * 4);                    /* 64 MC9328MXL interrupts */
-
     . = ALIGN (0x100);
 
 
Index: rtems/c/src/lib/libbsp/arm/csb336/startup/exit.c
===================================================================
--- rtems/c/src/lib/libbsp/arm/csb336/startup/exit.c	(revision 42)
+++ rtems/c/src/lib/libbsp/arm/csb336/startup/exit.c	(working copy)
@@ -29,7 +29,7 @@
    */
   printk("\n");
   printk(line);
-  while (uart_poll_read(0) < 0) continue;
+  while (BSP_poll_char() < 0) continue;
 
   bsp_reset();
 
Index: rtems/c/src/lib/libbsp/arm/csb336/network/network.c
===================================================================
--- rtems/c/src/lib/libbsp/arm/csb336/network/network.c	(revision 42)
+++ rtems/c/src/lib/libbsp/arm/csb336/network/network.c	(working copy)
@@ -41,20 +41,20 @@
 /* RTEMS event used to start transmit daemon. */
 #define START_TRANSMIT_EVENT    RTEMS_EVENT_2
 
-static rtems_isr enet_isr(rtems_vector_number vector);
+static void enet_isr(rtems_irq_hdl_param);
 static void enet_isr_on(const rtems_irq_connect_data *unused);
 static void enet_isr_off(const rtems_irq_connect_data *unused);
 static int enet_isr_is_on(const rtems_irq_connect_data *irq);
 
 /* Replace the first value with the clock's interrupt name. */
-rtems_irq_connect_data mc9328mxl_enet_isr_data = {BSP_INT_GPIO_PORTA,
-                                                  (rtems_irq_hdl)enet_isr,
-                                                  enet_isr_on,
-                                                  enet_isr_off,
-                                                  enet_isr_is_on,
-                                                  3,    /* unused for ARM */
-                                                  0 };  /* unused for ARM */
-
+rtems_irq_connect_data mc9328mxl_enet_isr_data = {
+    .name    = BSP_INT_GPIO_PORTA,
+    .hdl     = (rtems_irq_hdl)enet_isr,
+    .handle  = (void *)BSP_INT_GPIO_PORTA,
+    .on      = enet_isr_on,
+    .off     = enet_isr_off,
+    .isOn    = enet_isr_is_on,
+};
 typedef struct {
   unsigned long rx_packets;        /* total packets received         */
   unsigned long tx_packets;        /* total packets transmitted      */
@@ -102,7 +102,8 @@
 void mc9328mxl_enet_sendpacket (struct ifnet *ifp, struct mbuf *m);
 void mc9328mxl_enet_rx_task(void *arg);
 void mc9328mxl_enet_stats(mc9328mxl_enet_softc_t *sc);
-static int mc9328mxl_enet_ioctl(struct ifnet *ifp, int command, caddr_t data);
+static int mc9328mxl_enet_ioctl(struct ifnet *ifp, 
+                                unsigned long command, caddr_t data);
 
 
 int rtems_mc9328mxl_enet_attach (
@@ -631,7 +632,7 @@
 
 /*  Driver ioctl handler */
 static int
-mc9328mxl_enet_ioctl (struct ifnet *ifp, int command, caddr_t data)
+mc9328mxl_enet_ioctl (struct ifnet *ifp, unsigned long command, caddr_t data)
 {
     mc9328mxl_enet_softc_t *sc = ifp->if_softc;
     int error = 0;
@@ -678,7 +679,7 @@
 }
 
 /* interrupt handler */
-rtems_isr enet_isr (rtems_vector_number v)
+static void enet_isr(rtems_irq_hdl_param unused)
 {
     uint16_t int_reg;
 
Index: rtems/c/src/lib/libbsp/arm/shared/irq/irq_init.c
===================================================================
--- rtems/c/src/lib/libbsp/arm/shared/irq/irq_init.c	(revision 42)
+++ rtems/c/src/lib/libbsp/arm/shared/irq/irq_init.c	(working copy)
@@ -30,21 +30,14 @@
 void  rtems_irq_mngt_init()
 {
     int 			i;
-    long			*vectorTable;
     rtems_interrupt_level       level;
 
-    vectorTable = (long *) VECTOR_TABLE;
-
     _CPU_ISR_Disable(level);
 
     /* First, connect the ISR_Handler for IRQ and FIQ interrupts */
     _CPU_ISR_install_vector(ARM_EXCEPTION_IRQ, _ISR_Handler, NULL);
     _CPU_ISR_install_vector(ARM_EXCEPTION_FIQ, _ISR_Handler, NULL);
 
-     /* Initialize the vector table contents with default handler */
-    for (i=0; i<BSP_MAX_INT; i++)
-      *(vectorTable + i) = (long)(default_int_handler);
-
     /* Initialize the INT at the BSP level */
     BSP_rtems_irq_mngt_init();
 }
Index: rtems/c/src/lib/libbsp/arm/edb7312/irq/bsp_irq_init.c
===================================================================
--- rtems/c/src/lib/libbsp/arm/edb7312/irq/bsp_irq_init.c	(revision 42)
+++ rtems/c/src/lib/libbsp/arm/edb7312/irq/bsp_irq_init.c	(working copy)
@@ -22,7 +22,16 @@
 void BSP_rtems_irq_mngt_init()
 {
 	long int_stat;
+        long *vectorTable;
+        int i;
 
+        vectorTable = (long *) VECTOR_TABLE;
+
+        /* Initialize the vector table contents with default handler */
+        for (i=0; i<BSP_MAX_INT; i++) {
+            *(vectorTable + i) = (long)(default_int_handler);
+        }
+
 	/* mask all interrupts */
 	*EP7312_INTMR1 = 0x0;
 	*EP7312_INTMR2 = 0x0;
Index: rtems/c/src/lib/libbsp/arm/gba/irq/bsp_irq_init.c
===================================================================
--- rtems/c/src/lib/libbsp/arm/gba/irq/bsp_irq_init.c	(revision 42)
+++ rtems/c/src/lib/libbsp/arm/gba/irq/bsp_irq_init.c	(working copy)
@@ -29,6 +29,16 @@
  */
 void BSP_rtems_irq_mngt_init(void)
 {
+  long *vectorTable;
+  int i;
+
+  vectorTable = (long *) VECTOR_TABLE;
+    
+  /* Initialize the vector table contents with default handler */
+  for (i=0; i<BSP_MAX_INT; i++) {
+      *(vectorTable + i) = (long)(default_int_handler);
+  }
+
   /* clear all interrupt status flags */
   GBA_REG_IF = 0xffff;
   /* disable all interrupts */
Index: rtems/c/src/lib/libcpu/arm/mc9328mxl/include/mc9328mxl.h
===================================================================
--- rtems/c/src/lib/libcpu/arm/mc9328mxl/include/mc9328mxl.h	(revision 42)
+++ rtems/c/src/lib/libcpu/arm/mc9328mxl/include/mc9328mxl.h	(working copy)
@@ -131,6 +131,33 @@
 #define MC9328MXL_UART2_MPR4  (*((volatile uint32_t *)((MC9328MXL_UART2_BASE) + 0xcc)))
 #define MC9328MXL_UART2_TS    (*((volatile uint32_t *)((MC9328MXL_UART2_BASE) + 0xd0)))
 
+typedef struct {
+    volatile uint32_t rxd;
+    volatile uint32_t _res0[15];
+    volatile uint32_t txd;
+    volatile uint32_t _res1[15];
+    volatile uint32_t cr1;
+    volatile uint32_t cr2;
+    volatile uint32_t cr3;
+    volatile uint32_t cr4;
+    volatile uint32_t fcr;
+    volatile uint32_t sr1;
+    volatile uint32_t sr2;
+    volatile uint32_t esc;
+    volatile uint32_t tim;
+    volatile uint32_t bir;
+    volatile uint32_t bmr;
+    volatile uint32_t brc;
+    volatile uint32_t ipr1;
+    volatile uint32_t ipr2;
+    volatile uint32_t ipr3;
+    volatile uint32_t ipr4;
+    volatile uint32_t mpr1;
+    volatile uint32_t mpr2;
+    volatile uint32_t mpr3;
+    volatile uint32_t mpr4;
+    volatile uint32_t ts;
+} mc9328mxl_uart_regs_t;
 
 #define MC9328MXL_UART_RXD_CHARRDY    (bit(15))
 #define MC9328MXL_UART_RXD_ERR        (bit(14))
@@ -205,6 +232,17 @@
 #define MC9328MXL_UART_CR4_OREN       (bit(1))
 #define MC9328MXL_UART_CR4_DREN       (bit(0))
 
+#define MC9328MXL_UART_FCR_TXTL(x)    (((x) & 0x3f) << 10)
+#define MC9328MXL_UART_FCR_RFDIV_1    (5 << 7)
+#define MC9328MXL_UART_FCR_RFDIV_2    (4 << 7)
+#define MC9328MXL_UART_FCR_RFDIV_3    (3 << 7)
+#define MC9328MXL_UART_FCR_RFDIV_4    (2 << 7)
+#define MC9328MXL_UART_FCR_RFDIV_5    (1 << 7)
+#define MC9328MXL_UART_FCR_RFDIV_6    (0 << 7)
+#define MC9328MXL_UART_FCR_RFDIV_7    (6 << 7)
+#define MC9328MXL_UART_FCR_RFDIV_MASK (7 << 7)
+#define MC9328MXL_UART_FCR_RXTL(x)    (((x) & 0x3f) << 0)
+
 #define MC9328MXL_UART_SR1_PARERR     (bit(15))
 #define MC9328MXL_UART_SR1_RTSS       (bit(14))
 #define MC9328MXL_UART_SR1_TRDY       (bit(13))
Index: rtems/c/src/lib/libcpu/arm/mc9328mxl/clock/clockdrv.c
===================================================================
--- rtems/c/src/lib/libcpu/arm/mc9328mxl/clock/clockdrv.c	(revision 42)
+++ rtems/c/src/lib/libcpu/arm/mc9328mxl/clock/clockdrv.c	(working copy)
@@ -28,13 +28,14 @@
 static int clock_isr_is_on(const rtems_irq_connect_data *irq);
 
 /* Replace the first value with the clock's interrupt name. */
-rtems_irq_connect_data clock_isr_data = {BSP_INT_TIMER1,
-                                         (rtems_irq_hdl)Clock_isr,
-                                         clock_isr_on,
-                                         clock_isr_off,
-                                         clock_isr_is_on,
-                                         3,     /* unused for ARM cpus */
-                                         0 };   /* unused for ARM cpus */
+rtems_irq_connect_data clock_isr_data = {
+    .name   = BSP_INT_TIMER1,
+    .hdl    = (rtems_irq_hdl)Clock_isr,
+    .handle = (void *)BSP_INT_TIMER1,
+    .on     = clock_isr_on,
+    .off    = clock_isr_off,
+    .isOn   = clock_isr_is_on,
+};
 
 /* If you follow the code, this is never used, so any value 
  * should work
@@ -82,7 +83,7 @@
         int cnt; \
         freq = get_perclk1_freq(); \
         printk("perclk1 freq is %d\n", freq); \
-        cnt = ((freq / 1000) * BSP_Configuration.microseconds_per_tick) / 1000;\
+        cnt = ((long long)freq * BSP_Configuration.microseconds_per_tick + 500000) / 1000000;\
         printk("cnt freq is %d\n", cnt); \
         MC9328MXL_TMR1_TCMP = cnt; \
         /* use PERCLK1 as input, enable timer */ \
Index: rtems/c/src/lib/libcpu/arm/mc9328mxl/irq/bsp_irq_asm.S
===================================================================
--- rtems/c/src/lib/libcpu/arm/mc9328mxl/irq/bsp_irq_asm.S	(revision 42)
+++ rtems/c/src/lib/libcpu/arm/mc9328mxl/irq/bsp_irq_asm.S	(working copy)
@@ -31,13 +31,15 @@
 
   /* find the ISR's address based on the vector */	
   ldr   r0, =bsp_vector_table
-  ldr	r0, [r0, r1, LSL #2]	/* Read the address */
+  mov   r1, r1, LSL #3          /* Shift vector to get offset into table */
+  add   r1, r0, r1              /* r1 has address of vector entry */
+  ldr   r0, [r1, #4]            /* Get the data pointer */
+  ldr	r1, [r1]	        /* Get the vector */
 
-
   stmdb	  sp!,{lr}
   ldr     lr, =IRQ_return         /* prepare the return from handler  */
 
-  mov     pc, r0		/* EXECUTE INT HANDLER */
+  mov     pc, r1		/* EXECUTE INT HANDLER */
 
 IRQ_return:
   ldmia sp!,{lr}
Index: rtems/c/src/lib/libcpu/arm/mc9328mxl/irq/irq.h
===================================================================
--- rtems/c/src/lib/libcpu/arm/mc9328mxl/irq/irq.h	(revision 42)
+++ rtems/c/src/lib/libcpu/arm/mc9328mxl/irq/irq.h	(working copy)
@@ -15,6 +15,8 @@
 #ifndef __IRQ_H__
 #define __IRQ_H__
 
+#include <rtems/irq.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -34,7 +36,7 @@
  * Constants
  **********************************************************************/
 
-/* possible interrupt sources on the AT91RM9200 */
+/* possible interrupt sources on the MC9328MXL */
 #define BSP_INT_UART3_PFERR       0 
 #define BSP_INT_UART3_RTS         1     
 #define BSP_INT_UART3_DTR         2     
@@ -101,64 +103,21 @@
 #define BSP_INT_WDT              63
 #define BSP_MAX_INT              64
               
-typedef unsigned char  rtems_irq_level;
-typedef unsigned char  rtems_irq_trigger;
+typedef struct {
+    rtems_irq_hdl       vector;
+    rtems_irq_hdl_param data;
+} mc9328mxl_irq_info_t;
 
-typedef unsigned int rtems_irq_number;
-struct  __rtems_irq_connect_data__;     /* forward declaratiuon */
 
-typedef void (*rtems_irq_hdl)       (void);
-typedef void (*rtems_irq_enable)    (const struct __rtems_irq_connect_data__*);
-typedef void (*rtems_irq_disable)   (const struct __rtems_irq_connect_data__*);
-typedef int  (*rtems_irq_is_enabled)(const struct __rtems_irq_connect_data__*);
 
-extern rtems_irq_hdl bsp_vector_table[BSP_MAX_INT];
-#define VECTOR_TABLE bsp_vector_table
-  											   
-typedef struct __rtems_irq_connect_data__ {
-    /* IRQ line */
-    rtems_irq_number              name;
+extern mc9328mxl_irq_info_t bsp_vector_table[BSP_MAX_INT];
 
-    /* Handler */
-    rtems_irq_hdl                 hdl;
-
-    /* function for enabling interrupts at device level. */
-    rtems_irq_enable              on;
-
-    /* function for disabling interrupts at device level. */
-    rtems_irq_disable             off;
-
-    /* Function to test if interrupt is enabled */
-    rtems_irq_is_enabled        isOn;
-
-    /* priority level of interrupt */
-    rtems_irq_level               irqLevel;
-
-    /* Trigger method (rising/falling edge or high/low level) */
-    rtems_irq_trigger             irqTrigger;
-} rtems_irq_connect_data;
-
 /*
  * function to initialize the interrupt for a specific BSP
  */
 void BSP_rtems_irq_mngt_init();
 
 
-/*
- * function to connect a particular irq handler.
- */
-int BSP_install_rtems_irq_handler       (const rtems_irq_connect_data*);
-
-/*
- * function to get the current RTEMS irq handler for ptr->name. 
- */
-int BSP_get_current_rtems_irq_handler   (rtems_irq_connect_data* ptr);
-
-/*
- * function to disconnect the RTEMS irq handler for ptr->name.
- */
-int BSP_remove_rtems_irq_handler        (const rtems_irq_connect_data*);
-
 #endif /* __asm__ */
 
 #ifdef __cplusplus
Index: rtems/c/src/lib/libcpu/arm/mc9328mxl/irq/bsp_irq_init.c
===================================================================
--- rtems/c/src/lib/libcpu/arm/mc9328mxl/irq/bsp_irq_init.c	(revision 42)
+++ rtems/c/src/lib/libcpu/arm/mc9328mxl/irq/bsp_irq_init.c	(working copy)
@@ -23,10 +23,11 @@
  */
 void BSP_rtems_irq_mngt_init()
 {
-#if 0
-    /* disable all interrupts */
-    AIC_CTL_REG(AIC_IDCR) = 0xffffffff;
-#endif
+    int i;
 
+    for (i = 0; i < BSP_MAX_INT; i++) {
+        bsp_vector_table[i].vector = default_int_handler;
+        bsp_vector_table[i].data   = NULL;
+    }
 }
 
Index: rtems/c/src/lib/libcpu/arm/mc9328mxl/irq/irq.c
===================================================================
--- rtems/c/src/lib/libcpu/arm/mc9328mxl/irq/irq.c	(revision 42)
+++ rtems/c/src/lib/libcpu/arm/mc9328mxl/irq/irq.c	(working copy)
@@ -16,6 +16,8 @@
 #include <rtems/score/apiext.h>
 #include <mc9328mxl.h>
 
+mc9328mxl_irq_info_t bsp_vector_table[BSP_MAX_INT];
+
 /*
  * This function check that the value given for the irq line
  * is valid.
@@ -36,9 +38,6 @@
 int BSP_install_rtems_irq_handler  (const rtems_irq_connect_data* irq)
 {
     rtems_interrupt_level level;
-    rtems_irq_hdl *bsp_tbl;
-
-    bsp_tbl = (rtems_irq_hdl *)&bsp_vector_table;
     
     if (!isValidInterrupt(irq->name)) {
       return 0;
@@ -47,8 +46,8 @@
     /*
      * Check if default handler is actually connected. If not issue an error.
      */
-    if (bsp_tbl[irq->name] != default_int_handler) {
-      return 0;
+    if (bsp_vector_table[irq->name].vector != default_int_handler) {
+        return 0;
     }
 
     _CPU_ISR_Disable(level);
@@ -56,7 +55,8 @@
     /*
      * store the new handler
      */
-    bsp_tbl[irq->name] = irq->hdl;
+    bsp_vector_table[irq->name].vector = irq->hdl;
+    bsp_vector_table[irq->name].data = irq->handle;
 
     /*
      * Enable interrupt on device
@@ -80,18 +80,15 @@
 int BSP_remove_rtems_irq_handler  (const rtems_irq_connect_data* irq)
 {
     rtems_interrupt_level level;
-    rtems_irq_hdl *bsp_tbl;
 
-    bsp_tbl = (rtems_irq_hdl *)&bsp_vector_table;
-  
     if (!isValidInterrupt(irq->name)) {
       return 0;
     }
     /*
      * Check if the handler is actually connected. If not issue an error.
      */
-    if (bsp_tbl[irq->name] != irq->hdl) {
-      return 0;
+    if (bsp_vector_table[irq->name].vector != irq->hdl) {
+        return 0;
     }
 
     _CPU_ISR_Disable(level);
@@ -106,8 +103,8 @@
     /*
      * restore the default irq value
      */
-    bsp_tbl[irq->name] = default_int_handler;
-    
+    bsp_vector_table[irq->name].vector = default_int_handler;
+    bsp_vector_table[irq->name].data = NULL;
 
     _CPU_ISR_Enable(level);
 
Index: rtems/c/src/lib/libcpu/arm/shared/arm920/mmu.c
===================================================================
--- rtems/c/src/lib/libcpu/arm/shared/arm920/mmu.c	(revision 42)
+++ rtems/c/src/lib/libcpu/arm/shared/arm920/mmu.c	(working copy)
@@ -151,7 +151,7 @@
 static inline uint32_t mmu_get_ctrl(void)
 {
     uint32_t val;
-    asm volatile ("msr 15, 0, %0, cr1, cr0\n" : "=r" (val));
+    asm volatile ("mrc 15, 0, %0, cr1, cr0\n" : "=r" (val));
     return val;
 }
 
@@ -240,3 +240,13 @@
         base[i] = MMU_SET_LVL1_INVAL;
     }
 }
+
+
+void mmu_set_cpu_async_mode(void)
+{
+    uint32_t reg;
+    reg = mmu_get_ctrl();
+    reg |= 0xc0000000;
+    mmu_set_ctrl(reg);
+}
+    
Index: rtems/c/src/lib/libcpu/arm/at91rm9200/irq/bsp_irq_init.c
===================================================================
--- rtems/c/src/lib/libcpu/arm/at91rm9200/irq/bsp_irq_init.c	(revision 42)
+++ rtems/c/src/lib/libcpu/arm/at91rm9200/irq/bsp_irq_init.c	(working copy)
@@ -23,6 +23,16 @@
  */
 void BSP_rtems_irq_mngt_init()
 {
+    long *vectorTable;
+    int i;
+
+    vectorTable = (long *) VECTOR_TABLE;
+
+    /* Initialize the vector table contents with default handler */
+    for (i=0; i<BSP_MAX_INT; i++) {
+        *(vectorTable + i) = (long)(default_int_handler);
+    }
+
     /* disable all interrupts */
     AIC_CTL_REG(AIC_IDCR) = 0xffffffff;
 }
Index: rtems/c/src/lib/libcpu/arm/s3c2400/irq/bsp_irq_init.c
===================================================================
--- rtems/c/src/lib/libcpu/arm/s3c2400/irq/bsp_irq_init.c	(revision 42)
+++ rtems/c/src/lib/libcpu/arm/s3c2400/irq/bsp_irq_init.c	(working copy)
@@ -20,6 +20,16 @@
 
 void BSP_rtems_irq_mngt_init() 
 {
+    long *vectorTable;
+    int i;
+
+    vectorTable = (long *) VECTOR_TABLE;
+
+    /* Initialize the vector table contents with default handler */
+    for (i=0; i<BSP_MAX_INT; i++) {
+        *(vectorTable + i) = (long)(default_int_handler);
+    }
+
     /*
      * Here is the code to initialize the INT for
      * the specified BSP
Index: rtems/make/custom/csb336.cfg
===================================================================
--- rtems/make/custom/csb336.cfg	(revision 42)
+++ rtems/make/custom/csb336.cfg	(working copy)
@@ -22,12 +22,12 @@
 # -O4 is ok for RTEMS
 # NOTE2: some level of -O may be actually required by inline assembler (at least
 # -O2 so far.
-CFLAGS_OPTIMIZE_V=-O3
+CFLAGS_OPTIMIZE_V=-O3 -g
 #CFLAGS_OPTIMIZE_V=-O4 -mmultiple -mstring -mstrict-align
 
 # debug flags: typically none, but at least -O1 is required due to this
 # BSP using inlined code
-CFLAGS_DEBUG_V = -O1
+CFLAGS_DEBUG_V = -O1 -g
 #CFLAGS_DEBUG_V = -O1 -mmultiple -mstring -mstrict-align
 
 
